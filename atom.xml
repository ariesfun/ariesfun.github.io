<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AriesfunのBlog</title>
  
  <subtitle>欢迎来到我の小破站!</subtitle>
  <link href="https://ariesfun.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://ariesfun.gitee.io/"/>
  <updated>2023-08-27T04:31:10.730Z</updated>
  <id>https://ariesfun.gitee.io/</id>
  
  <author>
    <name>Ariesfun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CUM15-445-P1 Buffer Pool Manager</title>
    <link href="https://ariesfun.gitee.io/posts/cmu445p1.html"/>
    <id>https://ariesfun.gitee.io/posts/cmu445p1.html</id>
    <published>2023-08-27T04:03:59.249Z</published>
    <updated>2023-08-27T04:31:10.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CMU15-445-P1-Buffer-Pool-Manager"><a href="#CMU15-445-P1-Buffer-Pool-Manager" class="headerlink" title="[CMU15-445] P1 Buffer Pool Manager"></a>[CMU15-445] P1 Buffer Pool Manager</h2><p><a href="https://www.bilibili.com/video/BV1VP4y1H7TL/?share_source=copy_web&vd_source=64863a79f6edd334371cb7b41a0df347">【视频 前置知识-缓冲池】</a></p><p><a href="https://15445.courses.cs.cmu.edu/spring2023/project1/">【文档 p1-lab详情地址】</a></p><h2 id="Task-1-LRU-K-Replacement-Policy"><a href="#Task-1-LRU-K-Replacement-Policy" class="headerlink" title="Task #1 - LRU-K Replacement Policy"></a>Task #1 - LRU-K Replacement Policy</h2><h3 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h3><p>This component is responsible for tracking page usage in the buffer pool. You will implement a new class called <code>LRUKReplacer</code> in <code>src/include/buffer/lru_k_replacer.h</code> and its corresponding implementation file in <code>src/buffer/lru_k_replacer.cpp</code>. Note that <code>LRUKReplacer</code> is a stand-alone class and is not related to any of the other <code>Replacer</code> classes. You are expected to implement only the LRU-K replacement policy. You don’t have to implement LRU or a clock replacement policy, even if there is a corresponding file for it.</p><p>The LRU-K algorithm evicts a frame whose backward k-distance is maximum of all frames in the replacer. Backward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access. A frame with fewer than k historical accesses is given +inf as its backward k-distance. </p><p><strong>When multiple frames have +inf backward k-distance, the replacer evicts the frame with the earliest overall timestamp (i.e., the frame whose least-recent recorded access is the overall least recent access, overall, out of all frames).</strong></p><p>LRU-K算法会淘汰在替换器中所有帧中，后向k距离最大的帧，即<code>backward k-distance</code></p><p><strong>后向k距离是当前时间戳和第k次以前访问的时间戳之间的差值。</strong></p><p>历史访问次数少于k的帧被赋予+inf作为其后向k距离。</p><p>当多个帧具有+inf的后向k距离时，替换器将淘汰具有最早整体时间戳（即最近记录的访问，是所有帧中最近的访问）的帧。</p><p><strong>总结：</strong></p><ul><li><p><strong>优先淘汰距离最大的frame (Backward k-distance)</strong></p></li><li><p><strong>少于K次访问，距离是无穷大inf，优先被淘汰。</strong></p></li><li><p><strong>当有多个无穷大时，优先淘汰整体时间戳最早的，FIFO策略</strong></p></li></ul><p>The maximum size for the <code>LRUKReplacer</code> is the same as the size of the buffer pool since it contains placeholders for all of the frames in the <code>BufferPoolManager</code>. However, at any given moment, not all the frames in the replacer are considered to be evictable. The size of <code>LRUKReplacer</code> is represented by the number of <em>evictable</em> frames. The <code>LRUKReplacer</code> is initialized to have no frames in it. Then, only when a frame is marked as evictable, replacer’s size will increase.</p><p><strong>LRUK替换器的最大大小与缓冲池的大小相同，因为它包含缓冲池管理器中所有帧的占位符。</strong>然而，在任何时刻，替换器中的并非所有帧都被视为可驱逐的。</p><p>LRU-K替换器的大小由可驱逐帧的数量表示。LRUK替换器被初始化为空，只有在标记某个帧为可驱逐时，替换器的大小才会增加。</p><p><strong>总结：</strong></p><ul><li><strong>只有被标记为可驱逐的frame 并且传入是要驱逐时，才能被驱逐，替换器的大小才会增加</strong></li></ul><p><strong>要求实现以下5个API,</strong></p><p>You will need to implement the <em>LRU-K</em> policy discussed in this course. You will need to implement the following methods as defined in the header file (<code>src/include/buffer/lru_k_replacer.h</code>) and in the source file (<code>src/buffer/lru_k_replacer.cpp</code>):</p><ul><li><p><code>Evict(frame_id_t* frame_id)</code> : Evict the frame with largest backward k-distance compared to all other <strong>evictable</strong> frames being tracked by the <code>Replacer</code>. Store the frame id in the output parameter and return <code>True</code>. If there are no evictable frames return <code>False</code>.</p><p><strong>淘汰：淘汰具有与替换器跟踪的所有其他可淘汰帧，相比最大后向k距离的帧。</strong></p><p>将<code>frame id</code>存储在输出参数中并返回True。  </p><p>如果没有可淘汰的帧，则返回False。</p></li><li><p><code>RecordAccess(frame_id_t frame_id)</code> : Record that given frame id is accessed at current timestamp. This method should be called after a page is pinned in the <code>BufferPoolManager</code>.</p><p><strong>访问帧：记录给定的帧ID在当前时间戳被访问。</strong></p><p>此方法应在页面在BufferPoolManager中固定之后调用。</p></li><li><p><code>Remove(frame_id_t frame_id)</code> : Clear all access history associated with a frame. This method should be called only when a page is deleted in the <code>BufferPoolManager</code>.</p><p><strong>移除帧：清除与帧相关联的所有访问历史记录。</strong></p><p>此方法仅在BufferPoolManager中删除页面时调用。</p></li><li><p><code>SetEvictable(frame_id_t frame_id, bool set_evictable)</code> : This method controls whether a frame is evictable or not. It also controls <code>LRUKReplacer</code>‘s size. You’ll know when to call this function when you implement the <code>BufferPoolManager</code>. To be specific, when pin count of a page reaches 0, its corresponding frame is marked evictable and replacer’s size is incremented.</p><p><strong>设置为可驱逐：此方法控制帧是否可淘汰。它还控制LRUKReplacer的大小。</strong></p><p>当您实现BufferPoolManager时，将会知道何时调用此函数。</p><p>具体而言，当页面的固定计数达到0时，其对应的帧将被标记为可淘汰，并增加替换器的大小。</p></li><li><p><code>Size()</code> : <strong>This method returns the number of evictable frames that are currently in the <code>LRUKReplacer</code>.</strong></p><p><strong>容量大小：此方法返回当前在LRUKReplacer中可淘汰的帧数，即LRU-K替换器的大小。</strong></p></li></ul><p>The implementation details are up to you. You are allowed to use built-in STL containers. You may assume that you will not run out of memory, but you must make sure that your implementation is thread-safe.</p><hr><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><blockquote><p><strong>通用的lab分析流程</strong></p><ul><li><p>从测试代码入手（TDD：测试驱动开发）</p></li><li><p>分析类的成员函数（实现5个API）</p></li><li><p>根据要求或提示，实现每个函数具体的细节</p></li><li><p>调试时格式化代码</p></li></ul></blockquote><hr><p> 这部分需要我们完成该组件中，<strong>负责跟踪缓冲池中的页面使用情况的实现，即LRU-K替换策略的实现</strong>    </p><ul><li><p>先要理清LRU-K的原理，这里使用两个队列来实现</p></li><li><p>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。</p><p><strong>只有当数据的访问次数达到K次的时候，才会将数据放入缓存队列。</strong></p><p><strong>当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</strong></p><p><a href="https://www.jianshu.com/p/c4e4d55706ff">【参考文档 LRU-K相关原理介绍】</a></p><p><a href="https://www.acwing.com/activity/content/code/content/6570221/">【题解 LeetCode 146. LRU缓存机制】</a></p><blockquote><p>01.历史队列</p><ul><li>历史队列中的数据为第一次访问时的位置，只要未达到k次访问频率，位置一直保持不变。</li><li>实现数据结构：双向链表+哈希表</li><li>淘汰策略：FIFO</li></ul><p>02.缓存队列</p><ul><li>大于等于k次的访问频率，需要根据最近的访问时间切换元素在队列中的位置，类似于LRU。</li><li>实现数据结构：双向链表+哈希表</li><li>淘汰策略：LRU</li></ul></blockquote></li></ul><h3 id="实现5个API"><a href="#实现5个API" class="headerlink" title="实现5个API"></a>实现5个API</h3><p><strong>每个<code>frame_id</code>都唯一对应一个<code>Page_Table</code>中的一个<code>page_id</code>, 可以理解为放入队列中槽的具体位置</strong></p><p>每次缓冲池的新建页表或者取出一个页表，都要进行LRU-K的策略(淘汰不常用的内存页面，来保证读写的高效性)</p><p><strong>注意事项:</strong></p><p><strong>构造函数要补充完整，给自定义成员变量完成初始化操作;</strong></p><p><strong>同时要保证多线程情况下是线程安全的;</strong></p><p><strong>考虑边界情况，进行入参判断。</strong></p><p><strong>具体处理逻辑:</strong></p><ul><li><p><code>RecordAccess(frame_id_t frame_id)</code></p><p><strong>访问帧操作，(考虑把帧放入历史队列还是缓存队列)</strong></p><p>利用哈希表，每次访问统计<code>frame_id</code>的出现频次</p><p>01.到达<code>LRU-K</code>的<code>K</code>次时，放入缓存队列</p><p>02.超过<code>K</code>次时，表明它已经在缓存队列里了，需要更新它在缓存队列的位置（放在队头）</p><p>03.小于<code>K</code>次时，只对于第一次访问时，放入历史队列（放在队头）</p></li><li><p><code>SetEvictable(frame_id_t frame_id, bool set_evictable)</code> </p><p><strong>通过传入的参数<code>set_evictable</code>，来设置当前<code>frame_id</code>是否可以淘汰/驱逐；</strong></p><p>根据原先的<code>is_accessible_[frame_id]</code> 和 当前<code>set_evictable</code>的状态，更新当前替换器的大小；</p><p>同时更新标记当前帧是否可驱逐掉的状态。</p></li><li><p><code>Evict(frame_id_t* frame_id)</code> FIFO策略 + LRU策略</p><p><strong>开始进行淘汰操作，返回的是实际被淘汰掉的帧id, 并且返回给<code>frame_id</code></strong></p><p>从两个队列的尾部开始遍历，找到一个可驱逐的帧id；</p><p>需要注意以下两个操作的实现步骤区别；</p><p>注意，这里先要移除hash表中的值，再从队列里的链表移除对应的指针（防止访问已经被释放的内存，防止出现内存泄漏）；</p><p>01.驱逐前先要将已有的帧信息清空(包括从哈希表中移除，*it才可得到帧id)     </p><p>02.后面才从队列移除it，并更新替换器的大小，让缓存池容量减1 </p></li><li><p><code>Remove(frame_id_t frame_id)</code> </p><p><strong>移除/删除操作，清理两个队列中的数据，清除与帧相关联的所有访问历史记录。</strong></p><p>未到<code>K</code>，在历史队列中，否则在缓存队列中，都要完成哈希表和对应队列的数据移除。</p></li></ul><ul><li><p><code>Size()</code></p><p>返回当前替换器的容量/缓存池的容量。</p></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>balabala…</p><hr><h2 id="Task-2-Buffer-Pool-Manager"><a href="#Task-2-Buffer-Pool-Manager" class="headerlink" title="Task #2 - Buffer Pool Manager"></a>Task #2 - Buffer Pool Manager</h2><h3 id="任务要求-1"><a href="#任务要求-1" class="headerlink" title="任务要求"></a>任务要求</h3><p>Next, implement the buffer pool manager (<code>BufferPoolManager</code>). The <code>BufferPoolManager</code> is responsible for fetching database pages from the <code>DiskManager</code> and storing them in memory. The <code>BufferPoolManager</code> can also write dirty pages out to disk when it is either explicitly instructed to do so or when it needs to evict a page to make space for a new page.</p><p><strong>// 负责实现从<code>BufferPoolManager</code>中获取数据库页面<code>DiskManager</code>并将其存储在内存中。</strong></p><p><strong>// <code>BufferPoolManager</code>当明确指示这样做或需要逐出页面以为新页面腾出空间时，也可以将脏页面写入磁盘。</strong></p><p><strong>// 刷脏的时机是什么？从缓冲池中淘汰掉一个帧页面；刷新内存页面到磁盘时；</strong></p><p>To make sure that your implementation works correctly with the rest of the system, we will provide you with some functions already filled in. You will also not need to implement the code that actually reads and writes data to disk (this is called the <code>DiskManager</code> in our implementation). We will provide that functionality.</p><p>All in-memory pages in the system are represented by <code>Page</code> objects. The <code>BufferPoolManager</code> does not need to understand the contents of these pages. But it is important for you as the system developer to understand that <code>Page</code> objects are just containers for memory in the buffer pool and thus are not specific to a unique page. That is, each <code>Page</code> object contains a block of memory that the <code>DiskManager</code> will use as a location to copy the contents of a <strong>physical page</strong> that it reads from disk. The <code>BufferPoolManager</code> will reuse the same <code>Page</code> object to store data as it moves back and forth to disk. This means that the same <code>Page</code> object may contain a different physical page throughout the life of the system. The <code>Page</code> object’s identifer (<code>page_id</code>) keeps track of what physical page it contains; if a <code>Page</code> object does not contain a physical page, then its <code>page_id</code> must be set to <code>INVALID_PAGE_ID</code>.</p><p><strong>// 如果<code>Page</code>对象不包含物理页，则<code>page_id</code>必须将其设置为<code>INVALID_PAGE_ID</code>。</strong></p><p>Each <code>Page</code> object also maintains a counter for the number of threads that have “pinned” that page. </p><p><strong>// 每个<code>Page</code>对象还维护一个计数器，用于记录“固定”该页面的线程数量。</strong></p><p><strong>// 引用计数是用来跟踪页面当前被多少个操作或线程引用的的一个机制。</strong></p><p>Your <code>BufferPoolManager</code> is not allowed to free a <code>Page</code> that is pinned. Each <code>Page</code> object also keeps track of whether it is dirty or not. It is your job to record whether a page was modified before it is unpinned. Your <code>BufferPoolManager</code> must write the contents of a dirty <code>Page</code> back to disk before that object can be reused.</p><p>Your <code>BufferPoolManager</code> implementation will use the <code>LRUKReplacer</code> class that you created in the previous steps of this assignment. The <code>LRUKReplacer</code> will keep track of when <code>Page</code> objects are accessed so that it can decide which one to evict when it must free a frame to make room for copying a new physical page from disk. When mapping <code>page_id</code> to <code>frame_id</code> in the <code>BufferPoolManager</code>, again be warned that STL containers are not thread-safe.</p><p>You will need to implement the following functions defined in the header file (<code>src/include/buffer/buffer_pool_manager.h</code>) and in the source file (<code>src/buffer/buffer_pool_manager.cpp</code>):</p><ul><li><code>FetchPage(page_id_t page_id)</code></li><li><code>UnpinPage(page_id_t page_id, bool is_dirty)</code></li><li><code>FlushPage(page_id_t page_id)</code></li><li><code>NewPage(page_id_t* page_id)</code></li><li><code>DeletePage(page_id_t page_id)</code></li><li><code>FlushAllPages()</code></li></ul><p>For <code>FetchPage</code>, you should return nullptr if no page is available in the free list and all other pages are currently pinned. <strong><code>FlushPage</code> should flush a page regardless of its pin status.</strong></p><p><strong>// <code>FlushPage</code>无论其引脚状态如何，都应该刷新页面。</strong></p><p>For <code>UnpinPage</code>, the is_dirty parameter keeps track of whether a page was modified while it was pinned.</p><p><strong>// 对于<code>UnpinPage</code>，is_dirty 参数跟踪页面在固定时是否被修改。</strong></p><p>The <code>AllocatePage</code> private method provides the <code>BufferPoolManager</code> a unique new page id when you want to create a new page in <code>NewPage()</code>. On the other hand, the <code>DeallocatePage()</code> method is a no-op that imitates freeing a page on the disk and you should call this in your <code>DeletePage()</code> implementation.</p><p><strong>// <code>DeallocatePage()</code>该方法是模拟释放磁盘上页面的操作。</strong></p><p><strong>Disk Manager</strong></p><p>The Disk Manager class (<code>src/include/storage/disk/disk_manager.h</code>) reads and writes the page data from and to the disk. Your buffer pool manager will use <code>DiskManager::ReadPage()</code> and <code>DiskManager::WritePage()</code> whenever it needs to fetch a page to the buffer pool or flush a page to the disk.</p><hr><h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><p><strong>BufferPoolManager</strong>，<strong>几个重要的成员变量信息</strong></p><blockquote><p>const size_t pool_size_; // 缓冲池的容量</p><p>Page *pages_; // 从磁盘读取数据放入内存中，带有(<code>meta-data</code>元数据 + 磁盘读取的Data)</p><p>std::unique_ptr<LRUKReplacer> replacer_; // Task#1的LRU-K替换策略类</p><p>std::unordered_map&lt;page_id_t, frame_id_t&gt; page_table_; // 内存页表，用来绑定<code>page_id</code>和<code>frame_id</code>间的映射关系</p><p>std::list<frame_id_t> free_list_; // 管理空闲帧的列表，大小受<code>pool_size</code>影响</p><p>std::mutex latch_; // 底层的锁(用于给配置加锁)</p></blockquote><p><code>内存Page</code>: 以数组形式记录每个内存Page的信息<strong>（meta-data + 磁盘中读到的数据）</strong></p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230826170744774.png" alt="image-20230826170744774" style="zoom:33%;" /><p>成员变量<code>pin_count</code>引用计数的含义和作用，</p><p><strong>“pin_count” 表示页面当前被固定（正在被使用）的次数，以确保在页面上进行操作时数据的一致性和可靠性。</strong></p><p>利用ChatGpt进行辅助理解，</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230826024651175.png" alt="image-20230826024651175" style="zoom:50%;" /><p><strong>一些问题的理解：</strong></p><p><strong>01.<code>内存Page</code>和<code>磁盘Page</code>有什么区别？</strong></p><p><strong>page_table</strong>是内存池上的索引，用于表示每个内存页面的<code>page_id</code>对应在缓冲池中的槽的位置<code>frame_id</code>，</p><p><strong>page_directory</strong>是磁盘上的数据文件索引，标识<code>page_id</code>对应的数据文件位置。</p><p><strong>区别：</strong></p><p><code>内存Page</code>的容量更小，可以提供快速的数据访问；</p><p><code>磁盘Page</code>通常是帮助<code>内存Page</code>从磁盘找到对应的页表数据的位置；</p><p>再从磁盘读到内存中，放入一个成员变量data中(磁盘Page中包含的实际数据)</p><p>【面向磁盘的关系型数据库输入读取过程】</p><p>据库系统倾向于将热门数据或索引保留在内存中，以提高性能。</p><p>下图展示了，当用户读取数据库中数据的一个流程，</p><p>**(SQL执行)执行器 —-&gt; 缓冲池 (找到，返回给执行器) **</p><p><strong>(SQL执行)执行器 —-&gt; 缓冲池（没找到）在对应磁盘Page中取 —-&gt; 载入缓冲池(free_list检测 + LRU替换策略) —-&gt; 返回给执行器</strong></p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230826172956486.png" alt="image-20230826172956486" style="zoom:50%;" /><hr><p><strong>02.<code>NewPage()</code>和<code>FetchPage()</code>操作的区别是什么？</strong></p><p><strong>NewPage</strong>是在缓冲池中新创建一个只在内存中的页面，磁盘上没有该页面，得到一个新初始化的新页面并返回；</p><p><strong>FetchPage</strong>是这个页面已经在缓冲池中存在了，我只需要取出来，并返回这个页面的信息；</p><hr><p><strong>03.刷脏的时机是什么？</strong></p><p>从缓冲池中淘汰掉一个帧页面时；刷新内存页面到磁盘时；</p><hr><h3 id="实现6个API"><a href="#实现6个API" class="headerlink" title="实现6个API"></a>实现6个API</h3><p>实现缓冲池管理器（<code>BufferPoolManager</code>）,负责<code>BufferPoolManager</code>从 中获取数据库页面<code>DiskManager</code>并将其存储在内存中。</p><p>构造函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BufferPoolManager</span>(<span class="type">size_t</span> pool_size, DiskManager *disk_manager, <span class="type">size_t</span> replacer_k = LRUK_REPLACER_K,</span><br><span class="line">  LogManager *log_manager = <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>初始时，利用缓冲池容量大小<code>pool_size</code>初始化了<strong>空闲链表<code>free_list</code>的大小，用来表示当前空闲着的帧列表</strong></p><p><strong>注意：</strong></p><p><code>FetchPage</code>操作没在缓存池中找到信息，需要从磁盘读取信息到内存，</p><p><code>Flush</code>操作不需要reset数据。</p><p><strong>具体处理逻辑:</strong></p><ul><li><p><code>NewPage(page_id_t* page_id)</code></p><p><strong>新建页面操作</strong></p><p>获取一个可用的<code>frame_id</code>；</p><ul><li><p>空闲链表里非空，还有帧id可用，直接从<code>free_list</code>末尾拿一个帧页面就行</p></li><li><p>空闲链表里没有空闲的帧时，需要从缓冲池中淘汰掉一个帧页面，得到可用的帧id（<code>Task#1 Evict()</code>淘汰机制）</p><p>注意：若当前页面是脏状态，需要先进行刷脏，将数据写入磁盘再继续操作</p><p>然后，删除每个页表对应的帧id的索引，解除映射关系</p></li></ul><p>与申请到的新的<code>new_page_id</code>和<code>frame_id</code>，建立一对新映射关系；</p><p>对于<code>page_table_</code>数组进行数据初始化<code>meta-data</code>，并reset清空Data信息；</p><p>同步也要在，在LRU-K的替换器中进行访问帧和驱逐帧的操作</p><p>返回这个新的<code>pages_</code></p></li></ul><ul><li><p><code>FetchPage(page_id_t page_id)</code></p><p><strong>从缓冲池中取出一个内存页，操作过程类似NewPage</strong></p><p>若page_id能在缓冲池找到，</p><ul><li><p>更新页面的引用计数</p></li><li><p>在LRU-K的替换器中进行访问帧和驱逐帧的操作</p></li></ul><p>缓冲池中没有找到，在磁盘中读取，</p><ul><li>先获取一个可用的<code>frame_id</code></li><li>初始化meta-data信息，从磁盘中<strong>读数据</strong>存入pages_的data成员变量中</li><li>要在LRU-K的替换器中进行访问帧和驱逐帧的操作</li></ul><p>返回当前拿到的<code>pages_</code></p></li><li><p><code>UnpinPage(page_id_t page_id, bool is_dirty)</code></p><p><strong>用于将目标页面从缓冲池中解除固定, 同时传入该内存页面的脏状态</strong></p><p>先是入参判断，传入的<code>page_id</code>要有效，并且可以在内存页表里找到</p><p>获取<code>page_id</code>对应的<code>frame_id</code></p><p>通过<strong>按位或</strong>来，更新页面的脏状态（将传入的 <code>is_dirty</code> 参数的状态合并到页面的脏状态中）</p><p><strong>（按位或：这样的做的目的，确保在更新页面状态时不会丢失页面的脏状态信息）</strong></p><p>当前页面的引用计数大于0，每次解除固定操作只会让<code>pin_count_</code>减1</p><ul><li>只有引用计数为零时，页面才可以被置换(驱逐)出缓冲池（<code>Task#1 Evict()</code>淘汰机制）</li></ul><p>返回解除操作是否成功</p></li><li><p><code>FlushPage(page_id_t page_id)</code></p><p><strong>刷新一个内存页面到磁盘，写入数据操作</strong></p><p>注意FlushPage, 只管刷新页面不管其pin的状态，内存页面也不必清空</p><p>该页面能够在<code>page_table_</code>中找到时，获取对应的<code>frame_id</code></p><p>进行刷脏，利用<code>disk_manager_</code>写入数据到磁盘中，并且更新页面的脏状态</p></li></ul><ul><li><p><code>FlushAllPages()</code></p><p><strong>刷新所有内存页面到磁盘</strong></p><p>当前页面是脏状态，并且<code>page_id</code>是有效的，就可以满足刷脏操作</p><p>利用<code>disk_manager_</code>写入数据到磁盘中，并且更新页面的脏状态</p></li></ul><ul><li><p><code>DeletePage(page_id_t page_id)</code></p><p><strong>删除缓冲池的内存页面</strong></p><p>边界考虑，</p><p>要删除的<code>page_id</code>并不存在，即不在缓冲池中，返回true，</p><p>该页面正在被使用时，不能删；</p><p>删除前，页面数据还没写入磁盘时，需要先刷脏</p><p>然后要清空页面中的<code>meta-data</code>信息，</p><p>注意<code>reset</code>清空data, 标记<code>page_id</code>为无效ID<code>INVALID_PAGE_ID</code>(Page对象不包含物理页);</p><p>最后在<code>page_table</code>、<code>replacer</code>、<code>free_list</code>中进行清除，</p><p>然后<code>DeallocatePage()</code>释放磁盘页面</p></li></ul><hr><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>注意：</strong></p><p>开始实现代码时，需要将<code>throw NotImplementedException()</code>的代码移除，以便于后续可以正常完成<code>GTest</code>.</p><p>balabala…</p><hr><h2 id="Task-3-Read-Write-Page-Guards"><a href="#Task-3-Read-Write-Page-Guards" class="headerlink" title="Task #3 - Read/Write Page Guards"></a>Task #3 - Read/Write Page Guards</h2><h3 id="任务要求-2"><a href="#任务要求-2" class="headerlink" title="任务要求"></a>任务要求</h3><p>In the Buffer Pool Manager, <code>FetchPage</code> and <code>NewPage</code> functions return pointers to pages that are already pinned. The pinning mechanism ensures that the pages are not evicted until there are no more reads and writes on the page. To indicate that the page is no longer needed in memory, the programmer has to manually call <code>UnpinPage</code>.</p><p>On the other hand, if the programmer forgets to call <code>UnpinPage</code>, the page will never be evicted out of the buffer pool. As the buffer pool operates with an effectively smaller number of frames, there will be more swapping of pages in and out of the disk. Not only the performance takes a hit, the bug is also difficult to be detected.</p><p>You will implement <code>BasicPageGuard</code> which store the pointers to <code>BufferPoolManager</code> and <code>Page</code> objects. </p><p><strong>// 你将实现<code>BasicPageGuard</code>存储指向<code>BufferPoolManager</code>和<code>Page</code>对象的指针，进行读/写页面的防护</strong></p><p>A page guard ensures that <code>UnpinPage</code> is called on the corresponding <code>Page</code> object as soon as it goes out of scope. Note that it should still expose a method for a programmer to manually unpin the page.</p><p>As <code>BasicPageGuard</code> hides the underlying <code>Page</code> pointer, it can also provide read-only/write data APIs that provide compile-time checks to ensure that the <code>is_dirty</code> flag is set correctly for each use case.</p><p>In the future projects, multiple threads will be reading and writing from the same pages, thus reader-writer latches are required to ensure the correctness of the data. Note that in the <code>Page</code> class, there are relevant latching methods for this purpose. Similar to unpinning of a page, a programmer can forget to unlatch a page after use. To mitigate the problem, you will implement <code>ReadPageGuard</code> and <code>WritePageGuard</code> which automatically unlatch the pages as soon as they go out of scope.</p><p>You will need to implement the following functions for all <code>BasicPageGuard</code>, <code>ReadPageGuard</code> and <code>WritePageGuard</code>.</p><ul><li><code>PageGuard(PageGuard &amp;&amp;that)</code> : Move constructor. <strong>// 移动构造函数</strong></li><li><code>operator=(PageGuard &amp;&amp;that)</code> : Move operator. <strong>// 移动操作符</strong></li><li><code>Drop()</code> : Unpin and/or unlatch. <strong>// 取消固定和或解锁</strong></li><li><code>~PageGuard()</code> : Destructor. </li></ul><p>With the new page guards, implement the following wrappers in <code>BufferPoolManager</code>.</p><ul><li><code>FetchPageBasic(page_id_t page_id)</code></li><li><code>FetchPageRead(page_id_t page_id)</code></li><li><code>FetchPageWrite(page_id_t page_id)</code></li><li><code>NewPageGuarded(page_id_t *page_id)</code></li></ul><p>Please refer to the header files (<code>lru_k_replacer.h</code>, <code>buffer_pool_manager.h</code>, <code>page_guard.h</code>) for more detailed specs and documentations.</p><hr><h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><p>移动构造函数和移动赋值运算符的使用</p><p><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170">【参考文档 移动构造函数和移动赋值运算符 (C++)】</a></p><blockquote><p><strong>创建移动构造函数</strong></p><p>01.定义一个空的构造函数方法，该方法采用一个对类类型的右值引用作为参数</p><p>02.在移动构造函数中，将源对象中的类数据成员添加到要构造的对象（拷贝操作）</p><p>03.将源对象的数据成员分配默认值。 这可以防止析构函数多次释放资源</p></blockquote><blockquote><p><strong>创建移动赋值运算符</strong></p><p>01.定义一个空的赋值运算符，该运算符采用一个对类类型的右值引用作为参数并返回一个对类类型的引用</p><p>02.在移动赋值运算符中，如果尝试将对象赋给自身，则添加不执行运算的条件语句</p><p>03.在条件语句中，从要将其赋值的对象中释放所有资源（如内存）</p><ul><li>执行移动构造函数的02,03步骤</li></ul><p>04.返回对当前对象的引用</p></blockquote><p><strong>注意事项：</strong></p><p>入参判断，检查操作的指针变量是否为空 </p><p>释放资源时，需要将Page页面从缓冲池中解除固定（<strong>UnpinPage()操作</strong>）</p><p>在<code>BufferPoolManager</code>中，缓冲池的读写操作都需要加锁</p><hr><h3 id="相关API的实现"><a href="#相关API的实现" class="headerlink" title="相关API的实现"></a>相关API的实现</h3><p>在<code>BasicPageGuard</code>中，需要实现<code>ReadPageGuard</code>和<code>WritePageGuard</code>。</p><ul><li><p><strong><code>PageGuard(PageGuard &amp;&amp;that)</code>：移动构造函数。</strong></p><p>01.不空时，先清空</p><p>02.拷贝另一个数据的成员变量</p><p>03.将源对象的数据成员变为默认值，来释放资源</p></li><li><p><strong><code>operator=(PageGuard &amp;&amp;that)</code>：移动操作符。</strong></p><p>边界情况：不是自己时才能进行赋值</p><p>01.先清空</p><p>02.拷贝数据成员</p><p>03.源对象置为默认值</p></li><li><p><strong><code>Drop()</code>：取消固定和读写的解锁。</strong></p><p>操作的指针非空的判断；</p><p>不空时，需要将Page页面从缓冲池中解除固定；</p><p>将该对象信息，置为默认值。</p><p>关于<code>ReadPageGuard</code>和<code>WritePageGuard</code>的<code>Drop</code>实现;</p><p>需要先释放对应页面的读锁或写锁;</p><p>然后释放<code>BasicPageGuard</code>对象<code>guard_</code>的资源。</p></li></ul><ul><li><p><strong><code>~PageGuard()</code>: 析构函数。</strong></p><p>调用上面的<code>Drop()</code></p><p>使用新的页面防护，在<code>BufferPoolManager</code>中.</p><p>利用Task#2的API操作实现，</p></li><li><p><code>FetchPageBasic(page_id_t page_id)</code></p><p>返回取到的内存页面</p></li><li><p><code>FetchPageRead(page_id_t page_id)</code></p><p>返回取到的内存页面前，需要先加读锁</p></li><li><p><code>FetchPageWrite(page_id_t page_id)</code></p><p>返回取到的内存页面前，需要先加写锁</p></li><li><p><code>NewPageGuarded(page_id_t *page_id)</code></p><p>返回新创建的页面</p></li></ul><hr><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>balabala…</p><hr><h2 id="代码提交评测"><a href="#代码提交评测" class="headerlink" title="代码提交评测"></a>代码提交评测</h2><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230826215737631.png" alt="image-20230826215737631" style="zoom:50%;" /><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CMU15-445-P1-Buffer-Pool-Manager&quot;&gt;&lt;a href=&quot;#CMU15-445-P1-Buffer-Pool-Manager&quot; class=&quot;headerlink&quot; title=&quot;[CMU15-445] P1 Buffer Pool M</summary>
      
    
    
    
    <category term="CMU15-445" scheme="https://ariesfun.gitee.io/categories/CMU15-445/"/>
    
    
    <category term="学习记录" scheme="https://ariesfun.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="C/C++" scheme="https://ariesfun.gitee.io/tags/C-C/"/>
    
    <category term="LAB学习" scheme="https://ariesfun.gitee.io/tags/LAB%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据库内核" scheme="https://ariesfun.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>CUM15-445-P0 C++ Primer</title>
    <link href="https://ariesfun.gitee.io/posts/cmu445p0.html"/>
    <id>https://ariesfun.gitee.io/posts/cmu445p0.html</id>
    <published>2023-08-27T04:03:40.136Z</published>
    <updated>2023-08-27T04:31:01.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CUM15-445-P0-C-Primer"><a href="#CUM15-445-P0-C-Primer" class="headerlink" title="[CUM15-445] P0 C++ Primer"></a>[CUM15-445] P0 C++ Primer</h2><p><a href="https://15445.courses.cs.cmu.edu/spring2023/project0/">【文档 p0-lab详情地址】</a></p><hr><h3 id="Task-1-Copy-On-Write-Trie"><a href="#Task-1-Copy-On-Write-Trie" class="headerlink" title="Task#1 Copy-On-Write Trie"></a>Task#1 Copy-On-Write Trie</h3><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>In this task, you will need to modify <code>trie.h</code> and <code>trie.cpp</code> to implement a copy-on-write trie. In a copy-on-write trie, operations do not directly modify the nodes of the original trie. Instead, new nodes are created for modified data, and a new root is returned for the newly-modified trie. Copy-on-write enables us to access the trie after each operation at any time with minimum overhead(最小开销). Consider inserting <code>(&quot;ad&quot;, 2)</code> in the above example. We create a new <code>Node2</code> by reusing two of the child nodes from the original tree, and creating a new value node 2. (See figure below)</p><p>If we then insert <code>(&quot;b&quot;, 3)</code>, we will create a new root, a new node and reuse the previous nodes. In this way, we can get the content of the trie before and after each insertion operation. As long as we have the root object (<code>Trie</code> class), we can access the data inside the trie at that time. (See figure below)</p><p>One more example: if we then insert <code>(&quot;a&quot;, &quot;abc&quot;)</code> and remove <code>(&quot;ab&quot;, 1)</code>, we can get the below trie. Note that parent nodes can have values, and you will need to purge all unnecessary nodes after removal.</p><p>Your trie should support 3 operations:</p><ul><li><code>Get(key)</code>: Get the value corresponding to the key.</li><li><code>Put(key, value)</code>: Set the corresponding value to the key. Overwrite existing value if the key already exists. <strong>Note that the type of the value might be non-copyable</strong> (i.e., <code>std::unique_ptr</code>). This method returns a new trie.</li><li><code>Delete(key)</code>: Delete the value for the key. This method returns a new trie.</li></ul><p>None of these operations should be performed directly on the trie itself. </p><p>You should create new trie nodes and reuse existing ones as much as possible. <strong>// 创建新的trie节点并尽可能重用现有节点。</strong></p><p>To create a new node, you should use the <code>Clone</code> function on the <code>TrieNode</code> class. To reuse an existing node in the new trie, you can copy <code>std::shared_ptr</code>: copying a shared pointer doesn’t copy the underlying data. You should not manually allocate memory by using <code>new</code> and <code>delete</code> in this project. <code>std::shared_ptr</code> will deallocate the object when no one has a reference to the underlying object.</p><p>For the full specifications of these operations, please refer to the comments in the starter code.</p><hr><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>任务要求我们实现一个写时复制树，并且补充完成插入、查询、删除的操作</p><p>01.<code>PUT()</code><strong>插入操作</strong>，</p><p>每次放入一对 <code>(key, value)</code></p><p>插入的Trie节点分为两种：(<code>TrieNode</code>和<code>TrieNodeWithValue&lt;T&gt;</code>)</p><p>Trie类成员变量：<code>root_</code></p><p>类关系图如下，<code>std::shared_ptr</code>是共享指针可以直接复制，</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230824103333232.png" alt="image-20230824103333232" style="zoom:67%;" /><p><strong>考虑边界情况：</strong></p><ul><li>插入时是空树</li><li>插入时key是空串</li></ul><p><strong>遍历key,构建一个由key字符路径组成的字典树:</strong></p><p>只遍历到倒数第二个字符，</p><ul><li><p>依次判断字符对应的孩子节点是否存在</p><p>1.不存在，就新建一个普通节点</p><p>2.存在，就使用<code>Clone</code>拷贝原有分支，让新树对应的指针指向拷贝分支</p></li></ul><p>特殊处理最后一个字符，</p><ul><li>最后字符对应的节点不存在，需要创建一个无孩子的数值节点</li><li>存在对应节点的那个分支，需要覆盖原有数值节点的内容，并且保留对应孩子节点</li></ul><p>最后返回Trie的根节点</p><p><strong>处理的流程图如下，</strong></p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230824165749379.png" alt="image-20230824165749379"></p><p>02.<code>Get()</code><strong>查询操作</strong></p><p><strong>考虑边界情况:</strong></p><p>查询到的是空树时，返回空</p><p><strong>使用临时指针遍历查询的key:</strong></p><p>看能否在Trie的分支中找到对应的字符节点，</p><ul><li>某个字符不能找到，返回空树</li><li>都能找到，指针会指向key的尾节点，需要继续判断</li></ul><p>当前节点是否为<code>is_value_node_</code>这个终止节点，</p><ul><li><p>为<code>false</code>，说明该节点为普通节点，返回空树</p></li><li><p>为<code>true</code>，说明是有对应的数值节点，那就返回对应节点的裸指针</p></li></ul><p><strong>处理流程如下，</strong></p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230824164321951.png" alt="image-20230824164321951"></p><p>03.<code>Remove()</code><strong>删除/移除操作</strong></p><p><strong>删除对应节点的值时，不能影响原有节点，操作都在新节点上执行</strong></p><p><strong>具体的思路，</strong></p><p><strong>自顶向下，从根节点开始遍历串key，采用DFS递归处理，每次记录递归的串下标</strong></p><p><strong>边界考虑（递归出口）:</strong></p><p><strong>处理叶子结点，遍历到最后一个字符，找到要删除的节点时</strong></p><ul><li><p>当前节点已经没有孩子，返回空</p></li><li><p>有孩子节点，新建一个普通节点（并且根据孩子节点来构造）</p><p><u>为普通节点时就相当于只把当前节点的值置空了（达到删除目的）</u></p></li></ul><p><strong>处理中间节点：</strong></p><p>当前遍历到的字符，可以在当前节点的孩子节点中找到时，</p><ul><li><p>就递归到下一层,并返回对应的孩子节点</p></li><li><p>每次拷贝当前节点的分支             </p><p>递归有返回值且不空—&gt;说明孩子节点存在，连接到新分支对应位置处</p><p>递归返回的节点为空—&gt;到查找字符路径的最后一个位置了，继续判断</p><ul><li><p>当前节点是数值节点，就可删除对应位置的节点（已经是字符路径的最后一个位置，就可删掉），变为普通节点</p></li><li><p>当前节点是普通节点且没有孩子时，返回空（理解为置空操作）</p></li></ul></li><li><p>每层返回拷贝后经修改后的节点</p></li></ul><p>如果键的下一个字符不存在于当前节点的孩子中，就没找到直接返回原节点<code>root</code>。</p><p><strong>处理流程图如下，</strong></p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230824164105191.png" alt="image-20230824164105191"></p><p><strong>结合Chatgpt辅助理解，节点删除的过程</strong></p><p>做出声明，当删除的节点已经是尾节点时，直接删掉这个数值节点，父节点的状态不变无需更新。</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230824121933506.png" alt="image-20230824121933506" style="zoom: 67%;" /><hr><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>balabala…</p><hr><h3 id="Task-2-Concurrent-Key-Value-Store"><a href="#Task-2-Concurrent-Key-Value-Store" class="headerlink" title="Task#2 Concurrent Key-Value Store"></a>Task#2 Concurrent Key-Value Store</h3><h4 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h4><p>Task #2 - Concurrent Key-Value Store</p><p>After you have a copy-on-write trie which can be used in a single-thread environment, implement a concurrent key-value store for a multithreaded environment. In this task, you will need to modify <code>trie_store.h</code> and <code>trie_store.cpp</code>. This key-value store also supports 3 operations:</p><ul><li><code>Get(key)</code> returns the value.</li><li><code>Put(key, value)</code>. No return value.</li><li><code>Remove(key)</code>. No return value.</li></ul><p>For the original Trie class, everytime we modify the trie, we need to get the new root to access the new content. But for the concurrent key-value store, the <code>put</code> and <code>delete</code> methods do not have a return value. This requires you to use concurrency primitives to synchronize reads and writes so that no data is lost through the process.</p><p>Your concurrent key-value store should concurrently serve multiple readers <em>and</em> a single writer. <strong>// 多个读者，一个写者</strong></p><p>That is to say, when someone is modifying the trie, reads can still be performed on the old root. When someone is reading, writes can still be performed without waiting for reads. <strong>// 当有人修改trie时，仍然可以在旧根上读取。当有人正在读取时，仍然可以执行写入，而无需等待读取。</strong></p><p>Also, if we get a reference to a value from the trie, we should be able to access it no matter how we modify the trie. The <code>Get</code> function from <code>Trie</code> only returns a pointer. If the trie node storing this value has been removed, the pointer will be dangling. Therefore, in <code>TrieStore</code>, we return a <code>ValueGuard</code> which stores both a reference to the value and the TrieNode corresponding to the root of the trie structure, so that the value can be accessed as we store the <code>ValueGuard</code>.</p><p>To achieve this, we have provided you with the pseudo code for <code>TrieStore::Get</code> in <code>trie_store.cpp</code>. Please read it carefully and think of how to implement <code>TrieStore::Put</code> and <code>TrieStore::Remove</code>.</p><h4 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h4><ul><li>并发访问将写时复制的多版本字典树，简化为两个版本，<strong>历史版本和当前版本。</strong></li><li>并发访问时，只有一个根节点，始终保存最新的数据。</li><li>并发控制原则：<strong>共享读、排他写</strong></li></ul><h4 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h4><p>根据伪代码的提示信息，</p><p>在多线程环境下，通过对根节点进行加锁或解锁操作，来实现并发键值存储</p><p><code>01.Get()</code></p><p>值得注意的是，在进行查找trie树节点时，我们<strong>拿到根节点后需要立即解锁</strong></p><p>原因是，<u>写时复制字典树，会保留历史版本信息，读的时候并不会受新Trie修改的影响（可以保证有多个读者）</u></p><p><code>02.Put()</code></p><p>插入Tire树的节点信息时，需要加读锁，确保此刻只有一个对象来进行修改操作。</p><p>插入完成后，同时要将新修改的信息拷贝给Trie的成员变量<code>root_</code>,让其持有最新的信息</p><p><code>03.Remove()</code></p><p>操作类似Put过程</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>balabala…</p><hr><h3 id="Task-3-Debugging"><a href="#Task-3-Debugging" class="headerlink" title="Task#3 Debugging"></a>Task#3 Debugging</h3><h4 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h4><p>In this task, you will learn the basic techniques of debugging. You can choose any way you prefer for debugging, including but not limited to: using <code>cout</code> and <code>printf</code>, using CLion / VSCode debugger, using gdb, etc.</p><p>Please refer to <code>trie_debug_test.cpp</code> for instructions. You will need to set a breakpoint after the trie structure is generated and answer a few questions. You will need to fill in the answer in <code>trie_answer.h</code>.</p><h4 id="使用Clion进行Debug"><a href="#使用Clion进行Debug" class="headerlink" title="使用Clion进行Debug"></a>使用Clion进行Debug</h4><p>这步要求我们在 <code>trie_debug_test.cpp</code> 进行Debug测试，通过debug信息得到题目要求的答案内容，</p><p>我使用Clion进行Debug测试后，三个答案的结果是<code>8 1 42</code>, 进行测试后答案并不对。</p><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><p>网上转了一圈发现别人也有类似的问题，通过修改为指定的测试样例，是可以解决的,替换TrieDebugger的内容如下，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> trie = <span class="built_in">Trie</span>();</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;65&quot;</span>, <span class="number">25</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;61&quot;</span>, <span class="number">65</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;82&quot;</span>, <span class="number">84</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;2&quot;</span>, <span class="number">42</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;16&quot;</span>, <span class="number">67</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;94&quot;</span>, <span class="number">53</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;20&quot;</span>, <span class="number">35</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;3&quot;</span>, <span class="number">57</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;93&quot;</span>, <span class="number">30</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;75&quot;</span>, <span class="number">29</span>);</span><br></pre></td></tr></table></figure><p>参考的解决方案：<a href="https://zhuanlan.zhihu.com/p/613920859">【文档 CMU15-445 Project 0 (Spring 2023)】</a></p><p><strong>需要注意：</strong></p><p>修改测试样例后，Debug后的答案是<code>7 2 30</code>，用<code>gtest</code>进行单测后还是不正确，<strong>这是没问题的，提交到评测网站上是可以通过的</strong>。</p><hr><h3 id="Task-4-SQL-String-Functions"><a href="#Task-4-SQL-String-Functions" class="headerlink" title="Task#4 SQL String Functions"></a>Task#4 SQL String Functions</h3><h4 id="要求-3"><a href="#要求-3" class="headerlink" title="要求"></a>要求</h4><p>Now it is time to dive into BusTub itself! You will need to implement <code>upper</code> and <code>lower</code> SQL functions. </p><p>This can be done in 2 steps: </p><p>(1) implement the function logic in <code>string_expression.h</code>. <strong>// 实现大小写的转换的逻辑函数</strong></p><p>(2) register the function in BusTub, so that the SQL framework can call your function when the user executes a SQL, in <code>plan_func_call.cpp</code>. <strong>// 在BusTub中实现注册函数，以便SQL框架可以在用户执行SQL时调用该函数</strong></p><h4 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h4><p><code>string_expression.h</code></p><p>执行SOL时，通过判断<code>expr_type_</code>的转换类型，使用<code>tolower()</code>和<code>toupper()</code>对传入的字符串进行处理</p><p><code>plan_func_call.cpp</code></p><p>检验参数的合法性，进行注册操作，按照伪代码提示完成。</p><hr><h4 id="拓展知识点"><a href="#拓展知识点" class="headerlink" title="拓展知识点"></a>拓展知识点</h4><p>SQL层调用链路框架图，</p><ol><li><strong>Bustub模块图</strong></li></ol><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230825085923699.png" alt="image-20230825085923699" style="zoom: 50%;" /><p><strong>Bustub调用链（到SQL层）</strong></p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230825090159651.png" alt="image-20230825090159651"></p><p>通过Debug，可以看到函数的调用栈  </p><p>执行shell, 启动bustub  </p><p>输入<code>select upper(&#39;AbCd&#39;), lower(&#39;AbCd&#39;);</code>来执行查询操作  <img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230825085717023.png" alt="image-20230825085717023"></p><hr><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>balabala…</p><hr><h3 id="代码提交评测"><a href="#代码提交评测" class="headerlink" title="代码提交评测"></a>代码提交评测</h3><p><a href="https://www.gradescope.com/courses/500628">【官方评测工具 代码评测地址】</a></p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230825103908981.png" alt="image-20230825103908981" style="zoom: 50%;" /><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CUM15-445-P0-C-Primer&quot;&gt;&lt;a href=&quot;#CUM15-445-P0-C-Primer&quot; class=&quot;headerlink&quot; title=&quot;[CUM15-445] P0 C++ Primer&quot;&gt;&lt;/a&gt;[CUM15-445] P0 C++ </summary>
      
    
    
    
    <category term="CMU15-445" scheme="https://ariesfun.gitee.io/categories/CMU15-445/"/>
    
    
    <category term="学习记录" scheme="https://ariesfun.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="C/C++" scheme="https://ariesfun.gitee.io/tags/C-C/"/>
    
    <category term="LAB学习" scheme="https://ariesfun.gitee.io/tags/LAB%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据库内核" scheme="https://ariesfun.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>CUM 15-445 2023-Spring Lab记录合集</title>
    <link href="https://ariesfun.gitee.io/posts/cmu15445.html"/>
    <id>https://ariesfun.gitee.io/posts/cmu15445.html</id>
    <published>2023-08-27T03:47:38.888Z</published>
    <updated>2023-08-27T04:42:07.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CUM-15-445-2023-Spring-lab记录合集"><a href="#CUM-15-445-2023-Spring-lab记录合集" class="headerlink" title="CUM 15-445 2023-Spring lab记录合集"></a>CUM 15-445 2023-Spring lab记录合集</h2><h3 id="一、课程介绍"><a href="#一、课程介绍" class="headerlink" title="一、课程介绍"></a>一、课程介绍</h3><p><strong>课程总体介绍：</strong><br>转自课程介绍部分：<a href="https://csdiy.wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/15445/">CMU 15-445: Database Systems</a></p><p>这是一门质量极高，资源极齐全的 Database 入门课，这门课的 Faculty 和背后的 CMU Database Group 将课程对应的基础设施(Autograder, Discord) 和课程资料 </p><p>(Lectures, Notes, Homework) 完全开源，让每一个愿意学习数据库的同学都可以享受到几乎等同于 CMU 本校学生的课程体验。</p><p>这门课的亮点在于 CMU Database Group 专门为此课开发了一个教学用的关系型数据库 <a href="https://github.com/cmu-db/bustub">bustub</a>，并要求你对这个数据库的组成部分进行修改，实现上述部件的功能。</p><p>具体来说，<strong>在 15-445 中你需要在四个 Project 的推进中，实现一个面向磁盘的传统关系型数据库 Bustub 中的部分关键组件。</strong></p><p>主要包括以下4块内容：</p><p><strong>Buffer Pool Manager (内存管理),</strong> </p><p><strong>B Plus Tree (存储引擎),</strong> </p><p><strong>Query Executors &amp; Query Optimizer (算子们 &amp; 优化器),</strong></p><p><strong>Concurrency Control (并发控制)，分别对应 <code>Project #1</code> 到 <code>Project #4</code>。</strong></p><p>值得一提的是，同学们在实现的过程中可以通过 <code>shell.cpp</code> 编译出 <code>bustub-shell</code> 来实时地观测自己实现部件的正确与否，正反馈非常足。</p><p>此外 bustub 作为一个 C++ 编写的中小型项目涵盖了<u>程序构建、代码规范、单元测试等众多要求，可以作为一个优秀的开源项目学习。</u></p><p><strong>lab涉及到的核心知识点：</strong>C++11/17、数据结构与算法、操作系统、数据库内核、Linux开发等</p><hr><h3 id="二、课程资源"><a href="#二、课程资源" class="headerlink" title="二、课程资源"></a>二、课程资源</h3><p><strong>可利用的一些官方资源:</strong></p><p>课程主页：<a href="https://15445.courses.cs.cmu.edu/spring2023/assignments.html">Assignments | CMU 15-445/645 : Intro to Database Systems (Spring 2023)</a></p><p>官方仓库：<a href="https://github.com/cmu-db/bustub">cmu-db/bustub: The BusTub Relational Database Management System (Educational) (github.com)</a></p><p>课程介绍：<a href="https://csdiy.wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/15445/">CMU 15-445: Database Systems</a></p><p>课程交流答疑区：<a href="https://discord.com/channels/724929902075445281/1064726457546457240">Discord社区</a></p><p>中文课程：<a href="https://www.bilibili.com/video/BV1bQ4y1Y7iT/?share_source=copy_web&vd_source=64863a79f6edd334371cb7b41a0df347">【中文讲解视频 CMU-15445 数据库内核】</a></p><p><strong>Bustub可视化工具:</strong></p><ul><li><a href="https://15445.courses.cs.cmu.edu/fall2022/bustub/">Bustub 网页版客户端</a></li><li><a href="https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/">Bustub B+树可视化</a></li><li><a href="https://cs186berkeley.net/resources/join-animations/">Hash Join 可视化动画</a></li></ul><hr><h3 id="三、实验过程记录"><a href="#三、实验过程记录" class="headerlink" title="三、实验过程记录"></a>三、实验过程记录</h3><p>文章内容大体上是对于课程实验中一些知识点的理解+总结；</p><p>任务完成后总结一些解题的思路及注意点，不公开代码具体实现的部分。</p><p>主要是帮自己理清某些操作过程的逻辑和脉络，以便于自己加深学习理解。</p><p>下面是实验完成中记录的笔记内容，</p><p><strong>共分为5个部分，(点击链接即可跳转)</strong></p><p><a href="https://ariesfun.gitee.io/posts/cmu445p0.html">【P0 C++ Primer】</a></p><p><a href="https://ariesfun.gitee.io/posts/cmu445p1.html">【P1 Buffer Pool Manager】</a></p><p><a href="https://ariesfun.gitee.io/posts/cmu445p2.html">【P2 B+Tree Index】</a></p><p><a href="https://ariesfun.gitee.io/posts/cmu445p3.html">【P3 Query Execution】</a></p><p><a href="https://ariesfun.gitee.io/posts/cmu445p4.html">【P4 Concurrency Control】</a></p><hr><h3 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h3><p>这里我主要是参考一些博客帖子，主要是CSDN或知乎上的，根据前人的经验来完成。</p><p>一些相关的参考学习视频<a href="https://space.bilibili.com/23722270">Moody老师</a>和<a href="https://space.bilibili.com/30639161/channel/collectiondetail?sid=1339102">姚军老师</a></p><hr><h3 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h3><p>有关学术诚信: <a href="https://zhuanlan.zhihu.com/p/40568346">【文章 代码抄袭：那些让985学生沉默，211学生流泪的真相 from jyy】</a></p><p>不要公开发表你的程序代码（尤其是那些及其有思维量的项目代码，以防止自己被抄hhh）</p><p><strong>说一些自己对代码抄袭的看法，</strong></p><p>对于计算机的同学来说，在课程作业及课程设计中仍能见到抄袭代做等不良现象，我是比较排斥的。</p><p>就拿OJ写题举例来说，自己动脑思考或者查阅资料完成一道AC题，是会很有成就感的，过程中难免有不理解或者缺乏的知识块，这都很正常；</p><p>只要你抱有一颗时刻谦虚学习的心态，主动去利用一些题解或者参考性的代码，去帮助自己更好地学习理解某些知识点和进而会做这类题；</p><p>这本就是学习过程中必不可少的环节，学会利用一些资源来帮助自己真正学到知识，而不是为了xx而xx，过程的产出往往是大于结果的。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CUM-15-445-2023-Spring-lab记录合集&quot;&gt;&lt;a href=&quot;#CUM-15-445-2023-Spring-lab记录合集&quot; class=&quot;headerlink&quot; title=&quot;CUM 15-445 2023-Spring lab记录合集&quot;&gt;</summary>
      
    
    
    
    <category term="CMU15-445" scheme="https://ariesfun.gitee.io/categories/CMU15-445/"/>
    
    
    <category term="学习记录" scheme="https://ariesfun.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="C/C++" scheme="https://ariesfun.gitee.io/tags/C-C/"/>
    
    <category term="LAB学习" scheme="https://ariesfun.gitee.io/tags/LAB%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据库内核" scheme="https://ariesfun.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>C++ 设计模式(单例+工厂)</title>
    <link href="https://ariesfun.gitee.io/posts/21e5.html"/>
    <id>https://ariesfun.gitee.io/posts/21e5.html</id>
    <published>2023-08-08T16:29:53.011Z</published>
    <updated>2023-08-09T02:03:00.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-设计模式-单例-工厂"><a href="#C-设计模式-单例-工厂" class="headerlink" title="C++ 设计模式(单例+工厂)"></a>C++ 设计模式(单例+工厂)</h2><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><p>推荐一个讲解单例视频，整体概述比较全面：<a href="https://www.bilibili.com/video/BV11P411N7mu/?share_source=copy_web&vd_source=64863a79f6edd334371cb7b41a0df347">【视频 C++单例模式：从设计到实现】</a></p><p>工作具体项目中的应用，可以看看这个视频，讲了单例的各种用法：<a href="https://www.bilibili.com/video/BV1U34y1t7Qb/?share_source=copy_web&vd_source=64863a79f6edd334371cb7b41a0df347">【视频 C++单例模式】</a></p><p>下面是我自己从上面视频中的整理的一些讲解的理解和代码实现，主要是懒汉式单例模式。</p><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="(1).概念"></a>(1).概念</h4><p>通过单例模式的方法创建的<strong>类在当前进程中有且仅有一个实例</strong>。单例模式，属于创建类型的一种常用的<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2117635?fromModule=lemma_inlink">软件设计模式</a>。</p><blockquote><p>具体细分：</p><ul><li><p>懒汉式单例，会提供一个创建对象的方法（需要使用时创建）</p></li><li><p>饿汉式单例，在类加载的时候就创建对象（程序运行时创建，比较着急）</p></li></ul><p>共同点：</p><p>01.要声明一个静态的类引用变量</p><p>02.类的构造函数要私有</p><p>03.提供一个公有的创建对象的方法，能够全局访问</p><p>区别：</p><p><strong>懒汉式单例是在方法调用时创建对象，而饿汉式是在类加载是创建对象；</strong></p><p>多线程情况下，懒汉式单例存在线程安全问题，饿汉式不存在线程安全问题。</p></blockquote><hr><h4 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="(2).应用场景"></a>(2).应用场景</h4><p><strong>对程序运行期间对全局唯一资源的统一访问。</strong></p><p>比如，配置管理、日志记录、线程池、连接池、内存池、对象池、消息队列等。</p><p>自己最近学习的tcp服务端，就用到了<strong>单例模式(懒汉式)<strong>，这种写法是使用</strong>局部静态变量方式</strong>(与进程生命周期同步)；</p><p>可以避免进行释放内存操作，这种单例模式的写法比较推荐；</p><p>这是因为静态局部变量在<strong>C++11标准</strong>之后的编译器实现中会进行线程安全的初始化，<strong>保证局部变量初始化严格发生一次。</strong></p><p>在初始化过程中，编译器会确保<strong>只有一个线程能够执行该静态局部变量的初始化代码</strong>，从而避免了多线程竞争的问题。</p><p>具体的说明，可以看这篇文档，<a href="https://zh.cppreference.com/w/cpp/language/storage_duration#.E9.9D.99.E6.80.81.E5.B1.80.E9.83.A8.E5.8F.98.E9.87.8F">【文档 静态局部变量】</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过静态成员变量实现单例</span></span><br><span class="line"><span class="comment">//懒汉式 （多数情况下，这种单例模式是安全的）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton &amp;<span class="title">GetInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton single;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>具体项目中应用的例子，</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230807084123870.png" alt="image-20230807084123870" style="zoom:50%;" /><hr><h4 id="3-实现单例模式-懒汉式较常用"><a href="#3-实现单例模式-懒汉式较常用" class="headerlink" title="(3).实现单例模式(懒汉式较常用)"></a>(3).实现单例模式(懒汉式较常用)</h4><p>在大的实际项目中可能有多个类用到了单例，不可能把他们单独放在一起集中来初始化，所以多用懒汉式单例，具体使用时来创建单例。</p><blockquote><ul><li><p>实现步骤 </p><ul><li>step1.将类的构造方法定义为私有。</li><li>step2.定义一个私有类的静态实例。</li><li>step3.提供一个公有的获取实例的静态方法。</li></ul></li><li><p>涉及的知识点</p><p>static静态成员变量，fiend友元类，template模板类</p></li></ul></blockquote><h5 id="3-1-单例模式实现-懒汉-饿汉"><a href="#3-1-单例模式实现-懒汉-饿汉" class="headerlink" title="(3-1).单例模式实现(懒汉+饿汉)"></a>(3-1).单例模式实现(懒汉+饿汉)</h5><p><strong>懒汉式单例，比较常用</strong></p><p><strong>代码实现：</strong><code>a.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// step1.让类的构造函数私有(或受保护)</span></span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">m_name</span>(<span class="string">&quot;A&quot;</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;other) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span> = (<span class="type">const</span> A &amp;other);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// step2.定义一个私有静态类的实例</span></span><br><span class="line">    <span class="type">static</span> A* m_instance;</span><br><span class="line">    std::string m_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// step3.提供公有的获取实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> A* <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;m_name: &quot;</span> &lt;&lt; m_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A* A::m_instance = <span class="literal">nullptr</span>; <span class="comment">// 静态变量初始化</span></span><br></pre></td></tr></table></figure><p><strong>主程序，</strong><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// #include &quot;b.h&quot; // 可仿照&quot;a.h&quot;可以写一个B类来实现单例模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">单例模式：保证全局有且仅有一个实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编写两个头文件让A类，B类都实现单例</span></span><br><span class="line">    A* a1 = A::<span class="built_in">instance</span>();</span><br><span class="line">    a1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1: &quot;</span> &lt;&lt; a1 &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">auto</span> a2 = A::<span class="built_in">instance</span>();</span><br><span class="line">    a2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2: &quot;</span> &lt;&lt; a2 &lt;&lt; endl; <span class="comment">// a1,a2都指向同一地址（表示是同一实例）</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码运行结果，</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m_name: A</span><br><span class="line">a1: 0x55b10376d270</span><br><span class="line">m_name: A</span><br><span class="line">a2: 0x55b10376d270</span><br></pre></td></tr></table></figure><hr><p><strong>饿汉式单例(不常用)，是线程安全的</strong></p><p><strong>代码实现：</strong><code>Singleton.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125; <span class="comment">// step1.将类的构造方法定义为私有。</span></span><br><span class="line">    <span class="comment">// 定义一个私有类的静态实例。(饿汉式单例类的实例会在类被加载时就创建好,多线程下是安全的)</span></span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getSingleton</span><span class="params">()</span> </span>&#123; <span class="comment">// 提供一个公有的获取实例的静态方法。</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>(); <span class="comment">// 在类外部进行初始化,确保了实例只会在程序启动时被创建一次</span></span><br></pre></td></tr></table></figure><p><strong>具体使用，</strong><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例模式测试</span></span><br><span class="line">    Singleton* a1 = Singleton::<span class="built_in">getSingleton</span>();</span><br><span class="line">    Singleton* a2 = Singleton::<span class="built_in">getSingleton</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a1&#x27;s addr: &quot;</span> &lt;&lt; a1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a2&#x27;s addr: &quot;</span> &lt;&lt; a2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果如下，</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1<span class="number">&#x27;</span>s addr: <span class="number">0x6c1780</span></span><br><span class="line">a2<span class="number">&#x27;</span>s addr: <span class="number">0x6c1780</span></span><br></pre></td></tr></table></figure><hr><h5 id="3-2-用类模板优化写法-懒汉式"><a href="#3-2-用类模板优化写法-懒汉式" class="headerlink" title="(3-2).用类模板优化写法(懒汉式)"></a>(3-2).用类模板优化写法(懒汉式)</h5><p>定义一个类模板，<code>singleton.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> ariesfun &#123;</span><br><span class="line"><span class="keyword">namespace</span> utility &#123;</span><br><span class="line"><span class="comment">// 使用模板类来实现单例模式</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>: <span class="comment">// 提供公有访问实例的方法</span></span><br><span class="line">        <span class="function"><span class="type">static</span> T* <span class="title">instance</span><span class="params">()</span> <span class="comment">// 多线程环境下，可能会出安全问题</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                m_instance = <span class="keyword">new</span> <span class="built_in">T</span>(); <span class="comment">// 这里要访问对应私有类的构造函数，需要将当前类在类A中声明为友元类</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> m_instance; <span class="comment">// 返回全局实例的指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&lt;T&gt; &amp;another);</span><br><span class="line">        ~<span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">        Singleton&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&lt;T&gt; &amp;another);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> T* m_instance;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意模板类的static成员要放在.h文件里初始化</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    T* Singleton&lt;T&gt;::m_instance = <span class="literal">nullptr</span>; <span class="comment">// 模板类的静态成员初始化</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改写</strong><code>a.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;singleton.h&quot;</span> <span class="comment">// 引入头文件和对应作用域</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ariesfun::utility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// step1.让类的构造函数私有(或受保护)</span></span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">m_name</span>(<span class="string">&quot;A&quot;</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;other) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span> = (<span class="type">const</span> A &amp;other);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// step2.定义一个私有静态类的实例</span></span><br><span class="line">    <span class="comment">// static A* m_instance; （在类模板中已经实现）</span></span><br><span class="line">    std::string m_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// step3.提供公有的获取实例的静态方法</span></span><br><span class="line">    <span class="comment">// static A* instance() &#123;...&#125; （在类模板中已经实现）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;m_name: &quot;</span> &lt;&lt; m_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;A&gt;; <span class="comment">// 让Singleton能访问A的私有成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A* A::m_instance = nullptr; // 静态变量初始化</span></span><br></pre></td></tr></table></figure><p><strong>新的</strong><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="comment">// #include &quot;b.h&quot;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;singleton.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ariesfun::utility;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// 编写类模板实现单例</span></span><br><span class="line">    <span class="keyword">auto</span> sa1 = Singleton&lt;A&gt;::<span class="built_in">instance</span>();</span><br><span class="line">    sa1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sa1: &quot;</span> &lt;&lt; sa1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> sa2 = Singleton&lt;A&gt;::<span class="built_in">instance</span>();</span><br><span class="line">    sa2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sa2: &quot;</span> &lt;&lt; sa2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码运行结果，</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m_name: A</span><br><span class="line">sa1: <span class="number">0x5568f0b07270</span></span><br><span class="line">m_name: A</span><br><span class="line">sa2: <span class="number">0x5568f0b07270</span></span><br></pre></td></tr></table></figure><hr><h5 id="3-3-其他拓展"><a href="#3-3-其他拓展" class="headerlink" title="(3-3).其他拓展"></a>(3-3).其他拓展</h5><p>你可能见到过有些官方源码还有其他人，写法是宏定义或者在使用默认构造、拷贝、赋值后，加上了一些关键字(defalut,delete)，这是一种优化的写法。</p><p>比如，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLETON(classname)                                    \</span></span><br><span class="line"><span class="meta">    friend class Singleton<span class="string">&lt;classname&gt;</span>;                          \</span></span><br><span class="line"><span class="meta">    private:                                                    \</span></span><br><span class="line"><span class="meta">        classname() = default;                                  \ <span class="comment">// 使用默认构造</span></span></span><br><span class="line">        <span class="built_in">classname</span>(<span class="type">const</span> classname &amp;) = <span class="keyword">delete</span>;                  \ <span class="comment">// 禁用拷贝构造</span></span><br><span class="line">        classname &amp; <span class="keyword">operator</span> = (<span class="type">const</span> classname &amp;) = <span class="keyword">delete</span>;    \ <span class="comment">// 禁用赋值操作符</span></span><br><span class="line">        ~<span class="built_in">classname</span>() = <span class="keyword">default</span>  <span class="comment">// 使用默认析构</span></span><br></pre></td></tr></table></figure><p>(1).<code>private:</code>: 这是一个访问权限标识符，表示以下成员都将是私有的，只能在类的内部访问。</p><p>(2).<code>classname() = default;</code>: 表示使用编译器生成默认的构造函数实现。在单例模式中，通常会将构造函数设为私有，以防止从外部直接创建类的实例。</p><p>(3).<code>classname(const classname &amp;) = delete;</code>: 使用 <code>= delete</code> 表示禁用拷贝构造函数。这样做是为了防止通过拷贝构造函数创建多个实例，从而维护单例的唯一性。</p><p>(4).<code>classname &amp; operator=(const classname &amp;) = delete;</code>: 使用 <code>= delete</code> 表示禁用赋值操作符。这也是为了避免通过赋值操作创建多个实例。</p><p>(5).<code>~classname() = default;</code>: 使用 <code>= default</code> 表示使用编译器生成默认的析构函数实现。在单例模式中，通常不需要特殊的析构函数逻辑。</p><p>这段代码的目的是创建一个单例模式的类，其中通过私有化构造函数、拷贝构造函数和赋值操作符，以及声明友元类，来确保只有 <code>Singleton</code> 类能够创建和管理<code>classname</code> 类的唯一实例。</p><p>使用 <code>= default</code> 和 <code>= delete</code> 是一种简洁的方式来指定默认的函数实现或禁用特定的函数。</p><hr><h4 id="4-考虑多线程下的安全问题-懒汉式"><a href="#4-考虑多线程下的安全问题-懒汉式" class="headerlink" title="(4).考虑多线程下的安全问题(懒汉式)"></a>(4).考虑多线程下的安全问题(懒汉式)</h4><p><strong>最佳解决是直接规避掉这个问题，而不是找方法去解决这个问题(加锁等)。 乱码哥牛啊，哈哈</strong></p><p>其他加锁的方法，实际有需求或遇到线程安全问题，可以参考一下这篇博客介绍的解决方案：<a href="https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2MANJ6kCMuMtkgLbxigwVHmKC55">【<strong>文档 再谈单例模式</strong>】</a></p><p>乱码哥建议，可在main函数中这样使用，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决多线程下的安全问题,可以使用如下的方案(来规避安全问题)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程中 (创建实例)</span></span><br><span class="line">Singleton&lt;A&gt;::<span class="built_in">instance</span>();</span><br><span class="line">Singleton&lt;B&gt;::<span class="built_in">instance</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程中 (使用)</span></span><br><span class="line">Singleton&lt;A&gt;::<span class="built_in">instance</span>()-&gt;<span class="built_in">show</span>();</span><br><span class="line">Singleton&lt;B&gt;::<span class="built_in">instance</span>()-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><hr><h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="(1).概念"></a>(1).概念</h4><p><strong>工厂模式：原来是要自己创建对象，现在是不需要自己创建对象，而是创建这个对象的工厂。</strong></p><p><strong>工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。</strong></p><p><a href="https://baike.baidu.com/item/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F?fromModule=lemma_search-box">百度百科-工厂模式</a>就相当于创建实例对象的new，我们经常要根据类<code>class</code>生成实例对象，</p><p>如<code>A a=new A();</code>工厂模式也是用来创建实例对象的，所以以后new时就要多个心眼，是否可以考虑使用工厂模式，</p><p>虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。</p><hr><h4 id="2-应用场景-1"><a href="#2-应用场景-1" class="headerlink" title="(2).应用场景"></a>(2).应用场景</h4><p>工厂模式的主要目的，<strong>是封装对象的创建过程，提供更高层次的抽象，降低代码之间的耦合度，使代码更加可扩展和可维护。</strong></p><p>让我们来学习一下ChatGpt的回答，讲得倒是很全面。</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230808180910381.png" alt="image-20230808180910381" style="zoom: 50%;" /><hr><h4 id="3-实现工厂模式-工厂方法模式"><a href="#3-实现工厂模式-工厂方法模式" class="headerlink" title="(3).实现工厂模式(工厂方法模式)"></a>(3).实现工厂模式(工厂方法模式)</h4><p>工厂方法模式是一种创建型设计模式，用于创建对象的接口在父类中定义，但是让子类决定实例化的类是哪一个。</p><p>在工厂方法模式中，工厂类负责创建产品对象，具体的产品创建由子类的工厂类决定。</p><p>下面用创建一个车的工厂来举例，</p><p>先定义两个父类的头文件，车类和车工厂类，并尝试用CMake管理，采用多文件编写。</p><p><strong>项目目录如下，</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── docs</span><br><span class="line">├── include</span><br><span class="line">│   ├── Baoma.h</span><br><span class="line">│   ├── BaomaFactory.h</span><br><span class="line">│   ├── Benchi.h</span><br><span class="line">│   ├── BenchiFactory.h</span><br><span class="line">│   ├── Car.h</span><br><span class="line">│   ├── CarFactory.h</span><br><span class="line">│   └── singleton.h  # 可以忽略，这是测试单例模式时使用的类</span><br><span class="line">└── src</span><br><span class="line">    ├── Baoma.cpp</span><br><span class="line">    ├── BaomaFactory.cpp</span><br><span class="line">    ├── Benchi.cpp</span><br><span class="line">    ├── BenchiFactory.cpp</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><p><code>Car.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FACTORY_PATTERN_CAR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FACTORY_PATTERN_CAR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">get_name</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 定义虚函数，让子类来实现</span></span><br><span class="line">    <span class="built_in">Car</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//FACTORY_PATTERN_CAR_H</span></span></span><br></pre></td></tr></table></figure><p><code>CarFactory.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FACTORY_PATTERN_CARFACTORY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FACTORY_PATTERN_CARFACTORY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Car.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Car* <span class="title">getCar</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//FACTORY_PATTERN_CARFACTORY_H</span></span></span><br></pre></td></tr></table></figure><p>当我们需要创建一个车对象（奔驰车）时，我们需要创建这个车和对于这个车工厂（继承各自父类），当我们要使</p><p>用这个车时，直接从它工厂里拿就行。</p><p>下面以创建奔驰车对象为例，</p><p><strong>奔驰车类</strong>，<code>Benchi.h</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FACTORY_PATTERN_BENCHI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FACTORY_PATTERN_BENCHI_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Car.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Benchi</span> :<span class="keyword">public</span> Car &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">get_name</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// 加override，可帮助编译器检查是否正确地重写了父类的虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//FACTORY_PATTERN_BENCHI_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对应的源文件里写函数声明的实现</span></span><br><span class="line"><span class="string">&quot;Benchi.cpp&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Benchi.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Benchi::get_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;benchi&quot;</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><strong>奔驰车工厂，</strong><code>BenchiFactory.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FACTORY_PATTERN_BENCHIFACTORY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FACTORY_PATTERN_BENCHIFACTORY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CarFactory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BenchiFactory</span> :<span class="keyword">public</span> CarFactory &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Car* <span class="title">getCar</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//FACTORY_PATTERN_BENCHIFACTORY_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对应的源文件里写函数声明的实现</span></span><br><span class="line"><span class="string">&quot;BenchiFactory.cpp&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BenchiFactory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Benchi.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Car* <span class="title">BenchiFactory::getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Benchi</span>();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>在这个例子中，基类<code>CarFactory</code>定义了一个抽象的<code>getCar</code>函数，由子类来实现具体的创建过程。</p><p><code>BenchiFactory</code>是一个具体的子类，它继承了<code>CarFactory</code>并实现了<code>getCar</code>函数，返回一个<code>Benchi</code>对象。</p><p>这种模式的好处是，当需要添加新的汽车品牌时，只需创建一个新的子类并实现相应的<code>getCar</code>函数即可，不会对</p><p>已有的代码产生影响。</p><p><strong>编写测试类</strong>，<code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Car.h&quot;</span></span></span><br><span class="line"><span class="comment">// #include &quot;Benchi.h&quot;</span></span><br><span class="line"><span class="comment">// #include &quot;BenchiFactory.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Baoma.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BaomaFactory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 原来创建对象</span></span><br><span class="line"><span class="comment">    Car* c = new Benchi();</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;Car name: &quot; &lt;&lt; c-&gt;get_name() &lt;&lt; std::endl; // Car name: benchi</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工厂模式测试</span></span><br><span class="line">    <span class="comment">// 使用工厂来创建一辆奔驰车</span></span><br><span class="line">    Car* c1 = (<span class="keyword">new</span> BenchiFactory)-&gt;<span class="built_in">getCar</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Car1 name: &quot;</span> &lt;&lt; c1-&gt;<span class="built_in">get_name</span>() &lt;&lt; std::endl; <span class="comment">// Car1 name: benchi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样，我们使用工厂来创建一辆宝马车(写法与奔驰车类似)</span></span><br><span class="line">    <span class="comment">// Car* c2 = (new BaomaFactory)-&gt;getCar();</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Car2 name: &quot; &lt;&lt; c2-&gt;get_name() &lt;&lt; std::endl; // Car2 name: baoma</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><strong>单例模式：</strong></p><p><a href="https://hkrb7870j3.feishu.cn/docx/doxcnLkN4DIVd5sEz35QRnBdMeh">【文档 单例模式】</a></p><p><a href="https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2MANJ6kCMuMtkgLbxigwVHmKC55">【文档 再谈单例模式】</a></p><p><a href="https://www.bilibili.com/video/BV11P411N7mu/?share_source=copy_web&vd_source=64863a79f6edd334371cb7b41a0df347">【视频 C++单例模式：从设计到实现】</a></p><p><a href="https://www.bilibili.com/video/BV1U34y1t7Qb/?share_source=copy_web&vd_source=64863a79f6edd334371cb7b41a0df347">【视频 C++单例模式】</a></p><p><a href="https://www.bilibili.com/video/BV1LS4y1t7eE/?share_source=copy_web&vd_source=64863a79f6edd334371cb7b41a0df347">【视频 C++单例模式总结】</a></p><p><a href="https://www.bilibili.com/video/BV1du411V7ns/?share_source=copy_web&vd_source=64863a79f6edd334371cb7b41a0df347">【视频 Java单例设计模式】</a></p><p><strong>工厂模式：</strong></p><p><a href="https://www.bilibili.com/video/BV1bd4y1D7on/?share_source=copy_web&vd_source=64863a79f6edd334371cb7b41a0df347">【视频 C/C++项目实战-前置知识】</a></p><p><a href="https://github.com/SYaoJun/SystemProgramming/tree/fa98dfd6aac2e7ece663bbeb0b3ff0956bcdcc5d">【仓库代码 SYaoJun/SystemProgramming】</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-设计模式-单例-工厂&quot;&gt;&lt;a href=&quot;#C-设计模式-单例-工厂&quot; class=&quot;headerlink&quot; title=&quot;C++ 设计模式(单例+工厂)&quot;&gt;&lt;/a&gt;C++ 设计模式(单例+工厂)&lt;/h2&gt;&lt;h3 id=&quot;1-单例模式&quot;&gt;&lt;a href=&quot;#1</summary>
      
    
    
    
    <category term="CPP学习笔记" scheme="https://ariesfun.gitee.io/categories/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习记录" scheme="https://ariesfun.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="C/C++" scheme="https://ariesfun.gitee.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C/C++ 内存四区总结</title>
    <link href="https://ariesfun.gitee.io/posts/6d6b.html"/>
    <id>https://ariesfun.gitee.io/posts/6d6b.html</id>
    <published>2023-08-08T16:29:53.008Z</published>
    <updated>2023-08-08T16:35:15.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-C-内存四区总结"><a href="#C-C-内存四区总结" class="headerlink" title="C/C++ 内存四区总结"></a>C/C++ 内存四区总结</h2><h3 id="0-简单概述"><a href="#0-简单概述" class="headerlink" title="0.简单概述"></a>0.简单概述</h3><p>C/C++程序在执行时，将内存大方向划分为<strong>4个区域</strong>（内存四区）来存放所有数据。</p><blockquote><p> 程序运行前产生</p><ul><li><p><strong>代码区</strong>：存放函数体的二进制代码，由操作系统进行管理的</p></li><li><p><strong>全局区</strong>：存放全局变量、静态变量以及常量</p></li></ul><p> 程序运行后产生</p><ul><li><p><strong>栈区</strong>：<strong>由编译器自动分配释放</strong>, 存放函数的参数值、局部变量等</p></li><li><p><strong>堆区</strong>：**由程序员分配和释放,**若程序员不释放,程序结束时由操作系统回收</p></li></ul><p> <strong>内存四区意义：</strong><u>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程。</u></p></blockquote><p>按是否在全局区来划分变量和常量：</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230805161358288.png" alt="image-20230805161358288" style="zoom: 67%;" /><p><strong>虚拟地址空间（操作系统的视角）</strong></p><p>虚拟地址空间被分配给进程，用于存储程序代码、数据和堆栈等。</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230707120709782.png" alt="image-20230707120709782" style="zoom:50%;" /><hr><p><strong>小总结：</strong></p><p>(1).全局区存放哪些数据？</p><p><strong>全局变量、静态变量、常量（字符串常量，const修饰的全局常量或变量）</strong></p><p>(2).不在全局区中的有哪些？</p><p><strong>局部变量（栈区），const修饰的局部常量或变量</strong></p><p>(3).区分const修饰的局部常量或变量：</p><p><code>const</code> 修饰的局部常量或变量<strong>在声明时必须初始化</strong>，并且一旦初始化后，就不能再改变它们的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">修饰常量：</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_VALUE = <span class="number">100</span>; <span class="comment">// 这里用const声明并初始化了一个常量，其值不能被修改</span></span><br><span class="line"></span><br><span class="line">修饰指针变量：</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = &amp;x; <span class="comment">// ptr是一个指向常量的指针，指针内容不可修改</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr2 = &amp;y; <span class="comment">// ptr2是一个常量指针，指针本身地址不可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr3 = &amp;z; <span class="comment">// ptr3是一个指向常量的常量指针，指针本身及内容都不可修改</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr = &amp;x; <span class="comment">// ptr 是一个指向常量的指针，指向的内容不能通过指针修改</span></span><br><span class="line">    <span class="comment">// *ptr = 10; error</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> y = <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> ptr2 = &amp;y; <span class="comment">// ptr2 是一个常量指针，指针本身不能被修改</span></span><br><span class="line">    *ptr2 = <span class="number">20</span>; <span class="comment">// 指向的内容可以修改，可以修改y的值</span></span><br><span class="line">    <span class="comment">// ptr2 = &amp;x; error 常量指针本身地址不能被修改</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> z = <span class="number">25</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr3 = &amp;z; <span class="comment">// ptr3 是一个指向常量的常量指针，既不能修改指针本身，也不能通过指针修改指向的内容</span></span><br><span class="line">    <span class="comment">// *ptr3 = 30; error</span></span><br><span class="line">    <span class="comment">// ptr3 = &amp;x; error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-程序运行前"><a href="#1-程序运行前" class="headerlink" title="1.程序运行前"></a>1.程序运行前</h3><p>在C++程序编译后，Windows环境下生成了<code>.exe</code>可执行程序，<u><strong>未执行该程序前</strong>分为两个区域：代码区和全局区。</u></p><p><strong>程序运行前总结：</strong></p><blockquote><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是<strong>共享和只读</strong></li><li>全局区中存放<strong>全局变量、静态变量、常量</strong></li><li>常量区中存放 <strong>const修饰的全局常量 和 字符串常量</strong></li></ul></blockquote><h4 id="01-代码区"><a href="#01-代码区" class="headerlink" title="01.代码区"></a>01.代码区</h4><p>特点：只读、共享</p><p>存放 CPU 执行的机器指令（即二进制0101）</p><p>代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令；</p><p>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码可。</p><hr><h4 id="02-全局区"><a href="#02-全局区" class="headerlink" title="02.全局区"></a>02.全局区</h4><p><strong>全局变量和静态变量</strong>，还包含<strong>常量区, 字符串常量和其他常量</strong>也存放在此。</p><p><strong>该区域的数据在程序结束后由操作系统释放。</strong></p><p><strong>代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局区(存放的变量): 全局变量、静态变量、常量（字符串常量，const修饰的全局常量或变量）</span></span><br><span class="line"><span class="comment">// 数据在程序结束后，由操作系统释放</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const修饰的全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;在全局区中&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量g_a的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>) &amp;g_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量g_b的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>) &amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;静态变量s_a的地址：&quot;</span> &lt;&lt; (<span class="type">int</span>) &amp;s_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;静态变量s_b的地址：&quot;</span> &lt;&lt; (<span class="type">int</span>) &amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量</span></span><br><span class="line"><span class="comment">// 字符串常量(双引号引起来的) 即&quot;xxxxxxx&quot;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;字符串常量的地址：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hhhhh&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const修饰的全局(global)常量</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;const修饰的全局常量c_g_a的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>) &amp;c_g_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;const修饰的全局常量c_g_b的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>) &amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不在全局区中&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建普通局部变量(写在函数体内)，局部变量存放在栈区</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量a的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量b的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const修饰的局部(local)常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">110</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;const修饰的局部常量c_l_a的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;const修饰的局部常量c_l_b的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在全局区中</span><br><span class="line">全局变量g_a的地址为：<span class="number">653516800</span></span><br><span class="line">全局变量g_b的地址为：<span class="number">653516804</span></span><br><span class="line">静态变量s_a的地址：<span class="number">653516808</span></span><br><span class="line">静态变量s_b的地址：<span class="number">653516812</span></span><br><span class="line">字符串常量的地址：<span class="number">653504136</span></span><br><span class="line"><span class="type">const</span>修饰的全局常量c_g_a的地址为：<span class="number">653503408</span></span><br><span class="line"><span class="type">const</span>修饰的全局常量c_g_b的地址为：<span class="number">653503412</span></span><br><span class="line">------------------------------------------------</span><br><span class="line">不在全局区中</span><br><span class="line">局部变量a的地址为：<span class="number">1060109108</span></span><br><span class="line">局部变量b的地址为：<span class="number">1060109140</span></span><br><span class="line"><span class="type">const</span>修饰的局部常量c_l_a的地址为：<span class="number">1060109172</span></span><br><span class="line"><span class="type">const</span>修饰的局部常量c_l_b的地址为：<span class="number">1060109204</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-程序运行后"><a href="#2-程序运行后" class="headerlink" title="2.程序运行后"></a>2.程序运行后</h3><p>程序运行后分为栈区和堆区。</p><h4 id="01-栈区"><a href="#01-栈区" class="headerlink" title="01.栈区"></a>01.栈区</h4><p>由编译器管理开辟和释放, <strong>存放局部变量、函数的形参等。</strong></p><p>注意事项：<strong>不要返回局部变量的地址或引用</strong></p><p>(1).返回局部变量的地址，<code>warning: address of local variable ‘a’ returned</code></p><p>当一个函数返回指向栈内存的地址时，栈上的局部变量会被释放，这意味着返回的地址将指向一个已经不再有效的内存区域。</p><p>在后续使用该地址时，相当于访问已经释放的内存，可能会导致程序崩溃或产生不可预测的行为。</p><p>(2).返回局部变量的引用，<code>warning: reference to local variable ‘a’ returned</code></p><p>当函数执行完毕后，局部变量 <code>a</code> 将被销毁，这意味着返回的引用将成为悬挂引用 (dangling reference)。这个操作比较危险，会导致数据不可控。</p><p><strong>悬挂引用是指指向已经被销毁的内存的引用。</strong></p><p>当调用者试图使用这个引用时，会访问一个无效的内存位置，导致未定义的行为，很可能会导致程序崩溃或产生不可预测的结果。</p><p><strong>(3).解决方案：</strong></p><p>如果函数需要返回一个局部变量的值，可以通过值传递的方式返回，</p><p>或者返回一个动态分配的内存对象，可以使用智能指针（如 <code>std::unique_ptr</code> 或 <code>std::shared_ptr</code>）来管理动态内存的释放。</p><p><strong>代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈区：局部变量，形参</span></span><br><span class="line"><span class="comment">// 栈区注意事项，不要返回局部变量的地址</span></span><br><span class="line"><span class="comment">// 栈区的数据由编译器管理开辟和释放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">(<span class="type">int</span> b)</span> </span>&#123; <span class="comment">// 写法一</span></span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">// 栈上，局部变量存放在栈区，函数执行完后自动释放</span></span><br><span class="line"><span class="keyword">return</span> &amp;a; <span class="comment">// 返回了局部变量的地址（不建议）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="comment">// 写法二</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">return</span> a; <span class="comment">// 返回了局部变量的引用 (不建议)</span></span><br><span class="line">&#125; <span class="comment">// int &amp;temp = a;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">func</span>(<span class="number">1</span>); </span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">// 第一次，编译器做了保留，可以打印正确的值（visual studio里可以正常打印）</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">// 第二次，这个数据就不会被保留了，相当于是访问已经释放的内存，这是非法操作。</span></span><br><span class="line">    <span class="comment">// error 程序运行发生 Segmentation fault，段错误</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp; q = <span class="built_in">func1</span>();</span><br><span class="line">cout &lt;&lt; q &lt;&lt; endl; <span class="comment">// error 也发生了 Segmentation fault，段错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改后的函数如下,</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用值传递</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a; <span class="comment">// 返回局部变量的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回动态分配的内存对象</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">func</span><span class="params">(<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> ptr; <span class="comment">// 返回 std::unique_ptr，它会负责释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="02-堆区"><a href="#02-堆区" class="headerlink" title="02.堆区"></a>02.堆区</h4><p>在C++中主要利用<code>new</code>关键字，<strong>在堆区开辟内存；</strong></p><p>堆区开辟的数据，由程序员手动开辟，手动释放，**释放利用操作符<code>delete</code>**；若程序员不释放, 程序结束时则由操作系统回收。</p><p>语法：<code> new 数据类型</code></p><p><strong>利用new创建的数据，会返回该数据对应的类型的指针。</strong></p><p><strong>小总结：</strong></p><blockquote><p>堆区数据由程序员管理开辟和释放</p><p>堆区数据利用<code>new关键字</code>进行开辟内存</p></blockquote><p>指针是放在栈区（局部变量），指针存放的数据在堆区。</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230805181400667.png" alt="image-20230805181400665" style="zoom:50%;" /><p><strong>代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆区，由程序员来管理</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 利用new关键字，可以将数据开辟到堆区</span></span><br><span class="line"><span class="comment">// 指针是放在栈区（局部变量）,指针存放的数据在堆区</span></span><br><span class="line">    <span class="comment">// new返回的是该数据类型的指针</span></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* x = <span class="built_in">func</span>();</span><br><span class="line">cout &lt;&lt; *x &lt;&lt; endl; <span class="comment">// 100</span></span><br><span class="line">cout &lt;&lt; *x &lt;&lt; endl; <span class="comment">// 100</span></span><br><span class="line"><span class="keyword">delete</span> x; <span class="comment">// 释放堆区数据</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; *x &lt;&lt; endl; // error 释放的空间不可访问，非法访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在堆区利用new开辟数组</span></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">// 创建一个有10个元素的地址</span></span><br><span class="line"><span class="comment">// 返回对应类型的指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">arr[i] = i + <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; endl; <span class="comment">// 100 ~109</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放数组</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//test1();</span></span><br><span class="line"><span class="built_in">test2</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.bilibili.com/video/BV1et411b73Z/?p=84&share_source=copy_web&vd_source=64863a79f6edd334371cb7b41a0df347">【视频 黑马程序员 C++教程 p84开始】</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-C-内存四区总结&quot;&gt;&lt;a href=&quot;#C-C-内存四区总结&quot; class=&quot;headerlink&quot; title=&quot;C/C++ 内存四区总结&quot;&gt;&lt;/a&gt;C/C++ 内存四区总结&lt;/h2&gt;&lt;h3 id=&quot;0-简单概述&quot;&gt;&lt;a href=&quot;#0-简单概述&quot; cla</summary>
      
    
    
    
    <category term="CPP学习笔记" scheme="https://ariesfun.gitee.io/categories/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习记录" scheme="https://ariesfun.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="C/C++" scheme="https://ariesfun.gitee.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Hot100 分类刷题汇总</title>
    <link href="https://ariesfun.gitee.io/posts/7d34.html"/>
    <id>https://ariesfun.gitee.io/posts/7d34.html</id>
    <published>2023-07-24T19:29:53.728Z</published>
    <updated>2023-07-24T19:35:03.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-Hot100-分类刷题汇总"><a href="#LeetCode-Hot100-分类刷题汇总" class="headerlink" title="LeetCode Hot100 分类刷题汇总"></a>LeetCode Hot100 分类刷题汇总</h2><p><strong>目前进度</strong>：<code>68/100</code></p><p>对于算法底子不好的我，认为分类汇总的刷题的效率会高很多，通过这些总结希望自己回顾复习时能更快的回忆起解题思路。</p><p>如果发现我的代码有误或者你有不理解的地方，欢迎交流，可以在评论区留言。</p><h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h3><ul><li><p><a href="">数组</a></p></li><li><p><a href="">位运算</a></p></li><li><p><a href="">二分查找</a></p></li><li><p><a href="">双指针</a></p></li><li><p><a href="">链表</a></p></li><li><p><a href="">栈和队列</a></p></li><li><p><a href="">单调栈</a></p></li><li><p><a href="">哈希表</a></p></li><li><p><a href="">树</a></p></li><li><p><a href="">图</a></p></li><li><p><a href="">回溯和 DFS</a></p></li><li><p><a href="">BFS</a></p></li><li><p><a href="">动态规划</a></p></li><li><p><a href="">贪心</a></p></li></ul><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><table><thead><tr><th>题目</th><th>难度</th><th>标签</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/next-permutation">【31. 下一个排列】</a></td><td>MID</td><td><strong>双指针、字典序</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6468396/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/rotate-image">【48. 旋转图像】</a></td><td>EASY</td><td><strong>矩阵翻转</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6526399/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/majority-element">【169. 多数元素】</a></td><td>EASY</td><td><strong>摩尔投票法、数组处理</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6561723/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array">【215. 数组中的第K个最大元素】</a></td><td>MID</td><td><strong>快速选择排序</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6561735/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/product-of-array-except-self">【238. 除自身以外数组的乘积】</a></td><td>MID</td><td><strong>前缀和、前后缀分解</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6564194/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array">【448. 找到所有数组中消失的数字】</a></td><td>EASY</td><td><strong>数组处理</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6564180/">题解</a></td></tr></tbody></table><hr><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><table><thead><tr><th>题目</th><th>难度</th><th>标签</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/counting-bits">【338. 比特位计数】</a></td><td>EASY</td><td><strong>位运算、枚举</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6545287/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/single-number">【136. 只出现一次的数字】</a></td><td>EASY</td><td><strong>位运算、异或性质</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6545320/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/hamming-distance">【461. 汉明距离】</a></td><td>EASY</td><td><strong>位运算、异或性质</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6545337/">题解</a></td></tr></tbody></table><hr><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><table><thead><tr><th>题目</th><th>难度</th><th>标签</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays">4. 寻找两个正序数组的中位数</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array">【33. 搜索旋转排序数组】</a></td><td>MID</td><td><strong>二分、二段性</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6471982/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">【34. 在排序数组中查找元素的第一个和最后一个位置】</a></td><td>MID</td><td><strong>二分、二段性</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6472018/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii">【240. 搜索二维矩阵 II】</a></td><td>MID</td><td><strong>矩阵搜索、双指针</strong>  二分？？？</td><td><a href="https://www.acwing.com/activity/content/code/content/6557514/">题解</a></td></tr></tbody></table><hr><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><table><thead><tr><th>题目</th><th>难度</th><th>标签</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">【3. 无重复字符的最长子串】</a></td><td>MID</td><td><strong>双指针算法、哈希表、最长连续不重复子序列</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6429109/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-palindromic-substring">【5. 最长回文子串】</a></td><td>MID</td><td><strong>双指针、最长回文子串、枚举</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6429171/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/container-with-most-water">【11. 盛最多水的容器】</a></td><td>MID</td><td><strong>双指针、贪心、木桶短板效应</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6454030/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/3sum">【15. 三数之和】</a></td><td>MID</td><td><strong>双指针、单调性、枚举</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6454287/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/sort-colors">【75. 颜色分类】</a></td><td>MID</td><td><strong>三指针、排序</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6495219/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-window-substring">【76. 最小覆盖子串】</a></td><td>HARD</td><td><strong>滑动窗口、双指针、哈希表、字符串处理</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6495181/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/move-zeroes">【283. 移动零】</a></td><td>EASY</td><td><strong>双指针</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6557514/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number">【287. 寻找重复数】</a></td><td>MID</td><td><strong>双指针、快慢指针</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6550485/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/palindromic-substrings">【647. 回文子串】</a></td><td>MID</td><td><strong>双指针、回文子串</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6557514/">题解</a></td></tr></tbody></table><hr><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><table><thead><tr><th>题目</th><th>难度</th><th>标签</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/add-two-numbers">【2. 两数相加】</a></td><td>MID</td><td><strong>单链表、两数相加</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6428980/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">【19. 删除链表的倒数第 N 个结点】</a></td><td>MID</td><td><strong>单链表、头删法</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6458939/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">21. 合并两个有序链表</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists">【23. 合并K个升序链表】</a></td><td>HARD</td><td><strong>归并排序、优先队列、STL</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6464007/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list">114. 二叉树展开为链表</a></td><td></td><td></td><td><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/by-tonngw-m6ek/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/linked-list-cycle">【141. 环形链表】</a></td><td>EASY</td><td><strong>环形链表、双指针、快慢指针</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6491267/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">【142. 环形链表 II】</a></td><td>MID</td><td><strong>环形链表、双指针、快慢指针</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6570221/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/lru-cache">【146. LRU 缓存】</a></td><td>MID</td><td><strong>双链表、LRU缓存机制</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6570221/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/sort-list">【148. 排序链表】</a></td><td>MID</td><td><strong>链表排序、非递归、归并排序</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6572945/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists">【160. 相交链表】</a></td><td>EASY</td><td><strong>双指针</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6570225/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-linked-list">【206. 反转链表】</a></td><td>EASY</td><td><strong>翻转链表、双指针、递归</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6486782/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/palindrome-linked-list">【234. 回文链表】</a></td><td>EASY</td><td><strong>翻转链表、双指针</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6575388/">题解</a></td></tr></tbody></table><hr><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><table><thead><tr><th>题目</th><th>难度</th><th>标签</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/valid-parentheses">【20. 有效的括号】</a></td><td>EASY</td><td><strong>栈操作、括号匹配</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6459125/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/min-stack">【155. 最小栈】</a></td><td>MID</td><td><strong>栈操作</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6604680/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/decode-string">【394. 字符串解码】</a></td><td>MID</td><td><strong>递归、DFS</strong> 栈？？？</td><td><a href="https://www.acwing.com/activity/content/code/content/6585322/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/sliding-window-maximum">【239. 滑动窗口最大值】</a></td><td>HARD</td><td><strong>单调队列、滑动窗口</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6502870/">题解</a></td></tr></tbody></table><hr><hr><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><table><thead><tr><th>题目</th><th>难度</th><th>标签</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/trapping-rain-water">42. 接雨水</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram">84. 柱状图中最大的矩形</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximal-rectangle">85. 最大矩形</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/daily-temperatures">739. 每日温度</a></td><td></td><td></td><td></td></tr></tbody></table><hr><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><table><thead><tr><th>题目</th><th>难度</th><th>标签</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/two-sum">【1. 两数之和】</a></td><td>EASY</td><td><strong>哈希表、模拟</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6428849/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/group-anagrams">49. 字母异位词分组</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence">【128. 最长连续序列】</a></td><td>MID</td><td><strong>哈希表<code>unordered_set</code>应用</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6607682/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/top-k-frequent-elements">【347. 前 K 个高频元素】</a></td><td>MID</td><td><strong>哈希表、优先队列、小根堆</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6614070/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string">【438. 找到字符串中所有字母异位词】</a></td><td>MID</td><td><strong>哈希表、双指针、滑动窗口</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6614321/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k">【560. 和为 K 的子数组】</a></td><td>MID</td><td><strong>前缀和、哈希表</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6617375/">题解</a></td></tr></tbody></table><hr><h3 id="二叉树-考点：链表，递归，DFS"><a href="#二叉树-考点：链表，递归，DFS" class="headerlink" title="二叉树 (考点：链表，递归，DFS)"></a>二叉树 (考点：链表，递归，DFS)</h3><table><thead><tr><th>题目</th><th>难度</th><th>标签</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">【94. 二叉树的中序遍历】</a></td><td>EASY</td><td><strong>中序遍历、DFS、栈操作</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6620509/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/unique-binary-search-trees">【96. 不同的二叉搜索树】</a></td><td>MID</td><td><strong>二叉树形态映射、动态规划、乘法原理</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6626361/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/validate-binary-search-tree">【98. 验证二叉搜索树】</a></td><td>MID</td><td><strong>递归、DFS</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6626451/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/symmetric-tree">【101. 对称二叉树】</a></td><td>EASY</td><td><strong>递归、DFS</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6640827/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal">【102. 二叉树的层序遍历】</a></td><td>MID</td><td><strong>层序遍历、BFS</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6640823/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">【104. 二叉树的最大深度】</a></td><td>EASY</td><td><strong>二叉树深度、DFS</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6646300/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">【105. 从前序与中序遍历序列构造二叉树】</a></td><td>MID</td><td><strong>构造二叉树、前序(中序)遍历、哈希表</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6646330/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list">【114. 二叉树展开为链表】</a></td><td>MID</td><td><strong>先序遍历</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6567094/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum">【124. 二叉树中的最大路径和】</a></td><td>HARD</td><td><strong>二叉树遍历、递归、最近公共祖先(LCA)思想</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6761563/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/invert-binary-tree">【226. 翻转二叉树】</a></td><td>EASY</td><td><strong>翻转二叉树、递归</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6652388/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree">【236. 二叉树的最近公共祖先】</a></td><td>MID</td><td><strong>二叉树最近公共祖先、DFS</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6752442/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree">297. 二叉树的序列化与反序列化</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/house-robber-iii">【337. 打家劫舍 III】</a></td><td>MID</td><td><strong>树形DP、动态规划</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6742438/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/path-sum-iii">【437. 路径总和 III】</a></td><td>MID</td><td><strong>前序遍历、哈希表、前缀和、DFS</strong></td><td><a href="https://www.acwing.com/file_system/file/content/whole/index/content/9693651/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree">【538. 把二叉搜索树转换为累加树】</a></td><td>MID</td><td><strong>二叉搜索树、DFS</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6742778/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree">【543. 二叉树的直径】</a></td><td>EASY</td><td><strong>二叉树直径、DFS</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6743058/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/merge-two-binary-trees">617. 合并二叉树</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree">208. 实现 Trie (前缀树)</a></td><td></td><td></td><td></td></tr></tbody></table><hr><h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><table><thead><tr><th>题目</th><th>难度</th><th>标签</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/evaluate-division">【399. 除法求值】</a></td><td>MID</td><td><strong>图论、Floyd求最短路</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6652448/">题解</a></td></tr></tbody></table><hr><h3 id="回溯及DFS"><a href="#回溯及DFS" class="headerlink" title="回溯及DFS"></a>回溯及DFS</h3><table><thead><tr><th>题目</th><th>难度</th><th>标签</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number">【17. 电话号码的字母组合】</a></td><td>MID</td><td><strong>回溯及DFS、字符串处理</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6454348/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/generate-parentheses">【22. 括号生成】</a></td><td>MID</td><td><strong>括号序列、递归、卡特兰数(组合计数)</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6463882/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/combination-sum">【39. 组合总和】</a></td><td>MID</td><td><strong>回溯及DFS</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6516173/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/permutations">【46. 全排列】</a></td><td>MID</td><td><strong>回溯及DFS</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6526346/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/subsets">【78. 子集】</a></td><td>MID</td><td><strong>回溯、位运算、二进制枚举</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6529664/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/word-search">【79. 单词搜索】</a></td><td>MID</td><td><strong>回溯及DFS</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6537975/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-islands">【200. 岛屿数量】</a></td><td>MID</td><td><strong>DFS、Flood-fill算法</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6657902/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses">【301. 删除无效的括号】</a></td><td>HARD</td><td><strong>DFS、剪枝、双指针</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6538010/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/target-sum">【494. 目标和】重复1次</a></td><td>MID</td><td><strong>回溯及DFS、动态规化(不好理解)</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6725148/">题解</a></td></tr></tbody></table><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><table><thead><tr><th>题目</th><th>难度</th><th>标签</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/course-schedule">207. 课程表</a></td><td></td><td></td><td></td></tr></tbody></table><hr><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><table><thead><tr><th>题目</th><th>难度</th><th>标签</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/regular-expression-matching">10. 正则表达式匹配</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-valid-parentheses">32. 最长有效括号</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-subarray">53. 最大子数组和</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/unique-paths">62. 不同路径</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-path-sum">64. 最小路径和</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/climbing-stairs">70. 爬楼梯</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/edit-distance">72. 编辑距离</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">121. 买卖股票的最佳时机</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/word-break">139. 单词拆分</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-product-subarray">152. 乘积最大子数组</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximal-square">221. 最大正方形</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/perfect-squares">279. 完全平方数</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">【300. 最长递增子序列】</a></td><td>MID</td><td><strong>经典DP、最长上升子序列问题、二分</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6558615/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">309. 最佳买卖股票时机含冷冻期</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/burst-balloons">312. 戳气球</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/coin-change">322. 零钱兑换</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/house-robber-iii">【337. 打家劫舍 III】</a></td><td>MID</td><td><strong>树形DP、动态规划</strong></td><td><a href="https://www.acwing.com/activity/content/code/content/6742438/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum">416. 分割等和子集</a></td><td></td><td></td><td></td></tr></tbody></table><hr><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><table><thead><tr><th>题目</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/jump-game">55. 跳跃游戏</a></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height">406. 根据身高重建队列</a></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/task-scheduler">621. 任务调度器</a></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/meeting-rooms-ii">253. 会议室 II</a>「会员题」</td><td></td></tr></tbody></table><hr><p><strong>其他待整理</strong></p><p>82 删除链表重复元素 <a href="https://www.acwing.com/activity/content/code/content/6486863/">https://www.acwing.com/activity/content/code/content/6486863/</a></p><p>83 排序链表去重 <a href="https://www.acwing.com/activity/content/code/content/6491029/">https://www.acwing.com/activity/content/code/content/6491029/</a></p><p>150 栈操作，求中缀表达式 <a href="https://www.acwing.com/activity/content/code/content/6502857/">https://www.acwing.com/activity/content/code/content/6502857/</a></p><p>328 奇偶链表，链表合并 <a href="https://www.acwing.com/activity/content/code/content/6491188/">https://www.acwing.com/activity/content/code/content/6491188/</a></p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="(https://www.acwing.com/activity/content/31/)">【AcWing - LeetCode究极班】</a></p><p><a href="https://github.com/tonngw/LeetCode021/blob/master/LeetCode%20Hot%20100%20%E5%88%86%E7%B1%BB%E7%89%88.md#%E5%9B%9E%E6%BA%AF%E5%92%8C-dfs">【文档 LeetCode Hot100 分类版 by tonngw】</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LeetCode-Hot100-分类刷题汇总&quot;&gt;&lt;a href=&quot;#LeetCode-Hot100-分类刷题汇总&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Hot100 分类刷题汇总&quot;&gt;&lt;/a&gt;LeetCode Hot100 分类刷题</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://ariesfun.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://ariesfun.gitee.io/tags/C-C/"/>
    
    <category term="刷题记录" scheme="https://ariesfun.gitee.io/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>C++ 算法刷题 - 常用技巧汇总</title>
    <link href="https://ariesfun.gitee.io/posts/8b7.html"/>
    <id>https://ariesfun.gitee.io/posts/8b7.html</id>
    <published>2023-07-20T17:36:58.938Z</published>
    <updated>2023-07-20T18:21:31.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-算法刷题-常用技巧汇总"><a href="#C-算法刷题-常用技巧汇总" class="headerlink" title="C++ 算法刷题 - 常用技巧汇总"></a>C++ 算法刷题 - 常用技巧汇总</h2><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><h3 id="自带的宏常量"><a href="#自带的宏常量" class="headerlink" title="自带的宏常量"></a>自带的宏常量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> N = INT_MAX; <span class="comment">// 2147483647</span></span><br><span class="line"><span class="type">int</span> M = INT_MIN; <span class="comment">// -2147483648</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3</span>; INF: <span class="comment">// 66319347，在图论中通常用来代替最大值，防止运算过程中溢出</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;N: &quot;</span> &lt;&lt; N &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;M: &quot;</span> &lt;&lt; M &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;INF: &quot;</span> &lt;&lt; INF &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><hr><h2 id="字符串及字符处理"><a href="#字符串及字符处理" class="headerlink" title="字符串及字符处理"></a>字符串及字符处理</h2><h3 id="字符串初始化"><a href="#字符串初始化" class="headerlink" title="字符串初始化"></a>字符串初始化</h3><p>让字符串重复，利用构造函数来初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;h&#x27;</span>)</span></span>; </span><br><span class="line">std::cout &lt;&lt; str &lt;&lt; std::endl; <span class="comment">// 会输出10个h</span></span><br></pre></td></tr></table></figure><hr><h3 id="字符串判断函数"><a href="#字符串判断函数" class="headerlink" title="字符串判断函数"></a>字符串判断函数</h3><blockquote><p><code>isdigit(c)</code> // 判断给定字符是否是数字字符</p><p><code>isalpha(c)</code> // 判断字符是否是字母</p><p><code>isalnum(c)</code> // 判断字符是否是字符或数字</p><p><code>tolower(c)</code>// 转为小写</p><p><code>toupper(c)</code> // 转为大写    </p><p><code>transform(str.begin(), str.end(), str.begin(), ::tolower;</code> // 所有字符转为小写</p></blockquote><p><strong>代码示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">char</span>&gt; res = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : res) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(x)) &#123;</span><br><span class="line">        std::cout &lt;&lt; (x - <span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 字符数字转整数,5,6,7</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(std::<span class="built_in">isalnum</span>(x)) &#123; <span class="comment">// 是否是字母数字，res=6</span></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;cnt: &quot;</span> &lt;&lt; cnt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : res) &#123; <span class="comment">//使用 &amp;x 可以通过引用修改原始容器中的元素</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isalpha</span>(x)) &#123;</span><br><span class="line">        x = <span class="built_in">toupper</span>(x); <span class="comment">// x是引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// x: A B C 5 6 7</span></span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> t : res) std::cout &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 变为大写</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::string str1 = <span class="string">&quot;TOM, jack&quot;</span>;</span><br><span class="line"><span class="built_in">transform</span>(str1.<span class="built_in">begin</span>(), str1.<span class="built_in">end</span>(), str1.<span class="built_in">begin</span>(), ::uplower); <span class="comment">// 加头文件&lt;algorithm&gt;</span></span><br><span class="line">std::cout &lt;&lt; str1; <span class="comment">// 都变为小写: tom, jack</span></span><br></pre></td></tr></table></figure><hr><h3 id="字符串和数字间的转化"><a href="#字符串和数字间的转化" class="headerlink" title="字符串和数字间的转化"></a>字符串和数字间的转化</h3><h4 id="00-字符串转整数（秦九韶算法）"><a href="#00-字符串转整数（秦九韶算法）" class="headerlink" title="00.字符串转整数（秦九韶算法）"></a>00.字符串转整数（秦九韶算法）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    res = res * <span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;res: &quot;</span> &lt;&lt; res &lt;&lt; std::endl; <span class="comment">// int: 123456</span></span><br></pre></td></tr></table></figure><p><strong>应用题型：</strong></p><p><a href="https://www.acwing.com/problem/content/4948/">【AcWing 4945. 比大小 - 进位制、秦九韶】</a>    <a href="https://www.acwing.com/activity/content/code/content/6125715/">题解</a></p><p><a href="https://leetcode.cn/problems/string-to-integer-atoi/description/">【LeetCode 8. 字符串转换整数 (类atoi)】</a>    <a href="https://www.acwing.com/file_system/file/content/whole/index/content/9598807/">题解</a></p><p>Ps:相关函数: <code>to_string(num)</code> <strong>整型转字符串</strong></p><hr><h4 id="01-stoi-字符串转整数"><a href="#01-stoi-字符串转整数" class="headerlink" title="01.stoi() 字符串转整数"></a>01.stoi() 字符串转整数</h4><p><code>int stoi( const std::string&amp; str, std::size_t* pos = 0, int base = 10 );</code></p><p>pos: 可选参数，指向第一个无效字符位置的指针    base: 进制数, 默认是10</p><p><code>std::to_string(num)</code>数字转字符串，包含double</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line">std::string str = std::<span class="built_in">to_string</span>(num); <span class="comment">// 数字转字符串</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">stoi</span>(str); <span class="comment">// 字符串转整型，stol()转长整型</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; <span class="string">&quot;n: &quot;</span>  &lt;&lt; n &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><hr><h4 id="02-atoi-C风格字符串转整数"><a href="#02-atoi-C风格字符串转整数" class="headerlink" title="02.atoi() C风格字符串转整数"></a>02.atoi() C风格字符串转整数</h4><p><code>int atoi(const char* str);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot; 41.9999&quot;</span>;</span><br><span class="line"><span class="type">int</span> n  = std::<span class="built_in">atoi</span>(str); <span class="comment">// 只能处理简单的整数转换</span></span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; std::endl; <span class="comment">// n: 41</span></span><br></pre></td></tr></table></figure><hr><h4 id="03-atof-C风格字符串转浮点数"><a href="#03-atof-C风格字符串转浮点数" class="headerlink" title="03.atof() C风格字符串转浮点数"></a>03.atof() C风格字符串转浮点数</h4><p><code>double atof(const char* str);</code></p><p><code>atof()</code>会从字符串中解析出有效的浮点数，无法解析时，会返回0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;  -2.45x6&quot;</span>;</span><br><span class="line"><span class="type">double</span> f = std::<span class="built_in">atof</span>(str);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;f: &quot;</span> &lt;&lt; f &lt;&lt; std::endl; <span class="comment">// f: 2.45</span></span><br></pre></td></tr></table></figure><p>Ps:</p><p><code>atof()</code>（只能处理以null结尾的C风格字符串（<em><em>const char</em> str</em>*), </p><p>若是处理C++里的<code>std::string</code>，需要使用<code>.c_str()</code>方法获取其地址，然后在进行转换</p><p><strong>代码示例，</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot; -3.141/5&quot;</span>;</span><br><span class="line"><span class="type">double</span> f = std::<span class="built_in">atof</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;f: &quot;</span> &lt;&lt; f &lt;&lt; std::endl; <span class="comment">// f: 3.141</span></span><br></pre></td></tr></table></figure><hr><h4 id="04-str-c-str-用法"><a href="#04-str-c-str-用法" class="headerlink" title="04.str.c_str()用法"></a>04.<code>str.c_str()</code>用法</h4><p><code>const CharT* c_str() const;</code></p><p>返回值，指向底层字符存储的指针。</p><p><code>s.c_str()</code>函数,返回一<strong>个指向C字符串的指针常量</strong>, 内容与本string串相同.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* s = &#123;&#125;;</span><br><span class="line">s = str.<span class="built_in">c_str</span>(); <span class="comment">// const char* 类型</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;s: &quot;</span> &lt;&lt; s &lt;&lt; std::endl; <span class="comment">// s: hello</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str.<span class="built_in">c_str</span>()); <span class="comment">// 使用C风格的printf输出 </span></span><br></pre></td></tr></table></figure><p><code>c_str()</code>返回的是一个临时指针，不能对其进行操作</p><p><strong>代码示例，</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确用法</span></span><br><span class="line"><span class="type">char</span> c[<span class="number">10</span>];</span><br><span class="line">std::string str = <span class="string">&quot;good morning&quot;</span>;</span><br><span class="line"><span class="comment">// &lt;cstring&gt; 头文件</span></span><br><span class="line"><span class="built_in">strcpy</span>(c, str.<span class="built_in">c_str</span>());<span class="comment">// 这样才不会出错，c_str()返回的是一个临时指针，不能对其进行操作</span></span><br><span class="line">std::cout &lt;&lt; c &lt;&lt; std::endl; <span class="comment">// c: good morning</span></span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/blog/content/27673/">【s.c_str()使用详情】</a></p><hr><h4 id="相关拓展-取出数字的每一位"><a href="#相关拓展-取出数字的每一位" class="headerlink" title="相关拓展: 取出数字的每一位"></a>相关拓展: 取出数字的每一位</h4><blockquote><p>int t = x % 10; // 循环，从低位到高位取每一位数字<br>x /= 10; </p></blockquote><p><strong>代码示例，</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">45678</span>;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="keyword">while</span>(x) &#123; <span class="comment">// 取出x的每位数字 ( 从低位到高位取)</span></span><br><span class="line">    <span class="type">int</span> t = x % <span class="number">10</span>;</span><br><span class="line">    res.<span class="built_in">push_back</span>(t);</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> n : res) &#123;</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 45678</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**应用题型：</p><p><a href="https://www.acwing.com/problem/content/description/1247/">蓝桥杯 1245. 特别数的和</a>    <a href="https://www.acwing.com/activity/content/code/content/6726140/">题解</a></p><p><a href="https://haicoder.net/cpp/cpp-string-reverse.html">知识点：【reserve() 字符串反转】</a></p><hr><h3 id="字符串按空格分隔"><a href="#字符串按空格分隔" class="headerlink" title="字符串按空格分隔"></a>字符串按空格分隔</h3><p>将字符串按空格进行分割，类似其他语言的<code>split()</code>方法</p><p><strong>代码示例，</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入头文件 &lt;sstream&gt;</span></span><br><span class="line">std::string str = <span class="string">&quot;hello I  am fine  hhh&quot;</span>;</span><br><span class="line"><span class="function">std::stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">std::string s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ss &gt;&gt; s) &#123; <span class="comment">// 可忽略多个空格</span></span><br><span class="line">    cnt++; <span class="comment">// 统计分隔的数量</span></span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; cnt &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 输出结果为，</span></span><br><span class="line">hello</span><br><span class="line">I</span><br><span class="line">am</span><br><span class="line">fine</span><br><span class="line">hhh</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>相关题型，</strong></p><p><a href="https://www.acwing.com/problem/content/772/">【AcWing 770. 单词替换 】</a>    <a href="https://www.acwing.com/activity/content/code/content/5815055/">【题解】</a></p><hr><h3 id="字符串按格式拆分"><a href="#字符串按格式拆分" class="headerlink" title="字符串按格式拆分"></a>字符串按格式拆分</h3><p><strong>可以按自定义格式进行拆分</strong></p><p><code>void* memcpy(void* dest, const void* src, std::size_t count);</code></p><p>用于将<code>src</code>指针指向的内存区域的数据复制到<code>dest</code>指针指向的内存区域，复制的字节数由<code>count</code>指定。注意<code>memcpy</code>不会添加末尾空字符</p><p><code>int sscanf(const char* str, const char* format, ...);</code></p><p>从一个字符串中读取数据并根据指定的格式进行解析。</p><p><strong>代码示例，</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::string a = <span class="string">&quot;12:36:40&quot;</span>;</span><br><span class="line">std::string b = <span class="string">&quot;45s67,55&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(str, a.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(a.<span class="built_in">c_str</span>())); <span class="comment">// strlen() 需引入&lt;cstring&gt;</span></span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">&quot;%d:%d:%d&quot;</span>, &amp;u, &amp;v, &amp;w); <span class="comment">// 按指定格式从字符数组中来读</span></span><br><span class="line">std::cout &lt;&lt; u &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; w &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 12 36 40</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str1[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(str1, b.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(b.<span class="built_in">c_str</span>()));</span><br><span class="line"><span class="type">int</span> x,y,z;</span><br><span class="line"><span class="built_in">sscanf</span>(str1, <span class="string">&quot;%ds%d,%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; z &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 45 67 55</span></span><br></pre></td></tr></table></figure><p><strong>另外一种写法，</strong></p><p>``istringstream` <strong>自动截取分隔符号</strong></p><p>需要注意的是，将<code>std::string</code>类型的字符串转换成<code>char</code>类型的字符数组</p><p>并使用<code>sscanf</code>的方式不是C++中推荐的做法。C++提供了更加安全和便捷的方式来解析字符串，</p><p>例如使用<code>std::istringstream</code>，这样可以避免手动内存管理和潜在的缓冲区溢出问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::string c = <span class="string">&quot;1s2-4,5?99&quot;</span>;</span><br><span class="line"><span class="function">std::istringstream <span class="title">iss</span><span class="params">(c)</span></span>; <span class="comment">// 需引入&lt;sstream&gt;</span></span><br><span class="line"><span class="type">char</span> delimiter;</span><br><span class="line"><span class="type">int</span> x,y,m,n,q;</span><br><span class="line">iss &gt;&gt; x &gt;&gt; delimiter &gt;&gt; y &gt;&gt; delimiter &gt;&gt; m &gt;&gt; delimiter &gt;&gt; n &gt;&gt; delimiter &gt;&gt; q; <span class="comment">// iss会自动截取分隔符号(空格不行)</span></span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; m &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; q &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1 2 4 5 99</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;hello I am fine hhh&quot;</span>;</span><br><span class="line"><span class="function">std::stringstream <span class="title">ss</span><span class="params">(str)</span></span>; <span class="comment">// 需引入头文件 &lt;sstream&gt;</span></span><br><span class="line">std::string s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ss &gt;&gt; s) &#123;</span><br><span class="line">    cnt++; <span class="comment">// 统计读取串的数量</span></span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; cnt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果为</span></span><br><span class="line">hello</span><br><span class="line">I</span><br><span class="line">am</span><br><span class="line">fine</span><br><span class="line">hhh</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><hr><h3 id="利用字符串四舍五入保留小数"><a href="#利用字符串四舍五入保留小数" class="headerlink" title="利用字符串四舍五入保留小数"></a>利用字符串四舍五入保留小数</h3><p>在C++语言中，**<code>printf</code>函数本身并不提供四舍五入的功能。**</p><p><code>printf</code>是一个格式化输出函数，用于将数据按照指定格式输出到标准输出或其他输出流中，但它并不会对数据进行四舍五入操作。</p><p><strong>方法一：</strong>利用字符串</p><p><code>sprintf()</code>函数是C语言标准库中的一个函数，用于将格式化的数据写入到字符串中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="type">double</span> num = <span class="number">123.456</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">&quot;%.2f&quot;</span>, num);</span><br><span class="line">std::string s = str; <span class="comment">// 转为字符串，会有自动的隐式类型转换：string(const char* s);</span></span><br><span class="line">std::cout &lt;&lt; s &lt;&lt; std::endl; <span class="comment">// 结果：123.3</span></span><br></pre></td></tr></table></figure><p><strong>方法二：</strong>利用库函数</p><p>使用头文件中的<code>std::fixed </code>和 <code>std::setprecision</code> ,来指定保留的小数位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入头文件 &lt;iomanip&gt;</span></span><br><span class="line"><span class="type">double</span> num = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">int</span> k = <span class="number">3</span>; <span class="comment">// 设置要保留的小数位数</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(k) &lt;&lt; num &lt;&lt; std::endl; <span class="comment">// 结果： 3.142</span></span><br></pre></td></tr></table></figure><hr><h2 id="迭代器的二分"><a href="#迭代器的二分" class="headerlink" title="迭代器的二分"></a>迭代器的二分</h2><blockquote><p>// 一般升序使用</p><p><code>lower_bound(nums.begin(), nums.end(), 44) - nums.begin();</code> // 用于查找大于等于给定值的第一个元素</p><p><code>upper_bound(nums.begin(), nums.end(), 55) - nums.begin();</code> // 用于查找大于给定值的第一个元素</p></blockquote><p><strong>代码示例，</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>&#125;;</span><br><span class="line"><span class="comment">// 第一个大于等于目标值的迭代器位置</span></span><br><span class="line"><span class="type">int</span> k = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">44</span>) - nums.<span class="built_in">begin</span>(); <span class="comment">// 下标为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第一个大于目标值的迭代器位置</span></span><br><span class="line"><span class="type">int</span> m = <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">55</span>) - nums.<span class="built_in">begin</span>(); <span class="comment">// 下标为5 ， 查66小标为6</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;k: &quot;</span> &lt;&lt; k &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;m: &quot;</span> &lt;&lt; m &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><hr><h2 id="大根堆和小根堆"><a href="#大根堆和小根堆" class="headerlink" title="大根堆和小根堆"></a>大根堆和小根堆</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">// 默认是大根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq; <span class="comment">// 定义成小根堆的方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可支持以下操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> <span class="comment">// 引入头文件</span></span></span><br><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">push</span>()  插入一个元素</span><br><span class="line"><span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line"><span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">q = <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;(); 初始化队列 相当于clear</span><br></pre></td></tr></table></figure><p><strong>代码示例，</strong></p><p><a href="https://www.luogu.com.cn/problem/P3378">【洛谷 模拟堆操作 - 模板题】</a>，<strong>STL实现小根堆的增删改</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap; <span class="comment">// 定义小根堆</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n, op;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            heap.<span class="built_in">push</span>(x); <span class="comment">// 插入元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, heap.<span class="built_in">top</span>()); <span class="comment">// 输出堆顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            heap.<span class="built_in">pop</span>(); <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>相关应用，</strong></p><p><a href="https://www.luogu.com.cn/problem/P3378">【洛谷 模拟堆操作 - 模板题】</a></p><p><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">【剑指 - Offer 40. 最小的k个数】</a>    <a href="https://www.acwing.com/activity/content/code/content/6185450/">【题解】</a></p><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/description/">【LeetCode 47. 前 K 个高频元素】</a>    <a href="https://www.acwing.com/activity/content/code/content/6614070/">【题解】</a></p><p><a href="https://www.acwing.com/problem/content/840/">【AcWing 堆排序 - 模板题】</a>    <a href="https://www.acwing.com/activity/content/code/content/6729882/">【题解】</a></p><p><a href="https://www.acwing.com/problem/content/841/">【AcWing 模拟堆 - 模板题】</a>    <a href="https://www.acwing.com/activity/content/code/content/6731326/">【题解】</a></p><hr><h2 id="快速初始化数组"><a href="#快速初始化数组" class="headerlink" title="快速初始化数组"></a>快速初始化数组</h2><p><code>memset()</code>, <strong>按字节来初始化元素的值或清空数组，常用于图论题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意需要包含头文件 &lt;cstring&gt;</span></span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">0</span>, <span class="keyword">sizeof</span> nums); </span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">-1</span>, <span class="keyword">sizeof</span> nums);</span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> nums);</span><br></pre></td></tr></table></figure><hr><h2 id="bitset-压位"><a href="#bitset-压位" class="headerlink" title="bitset 压位"></a>bitset 压位</h2><p>自己目前还没遇到过这类题型，可能是考察的少(应该是刷题少了)，后续有做到类似的题再补充</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的功能是将给定的32位无符号整数（uint32_t）表示的数字的二进制位反转，并返回反转后的新数字。</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span>)</span> </span>&#123;</span><br><span class="line">    string s = <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(n).<span class="built_in">to_string</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(s).<span class="built_in">to_ulong</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="一些C-11新特性"><a href="#一些C-11新特性" class="headerlink" title="一些C++11新特性"></a>一些C++11新特性</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(); <span class="comment">// auto，会自动推断返回的类型</span></span><br><span class="line">Node* pre = <span class="literal">nullptr</span>; <span class="comment">// 用nullptr代替NULL</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map; <span class="comment">// 哈希表， 内部无序</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; st; <span class="comment">// 无序集合</span></span><br></pre></td></tr></table></figure><hr><h2 id="自定义排序规则"><a href="#自定义排序规则" class="headerlink" title="自定义排序规则"></a>自定义排序规则</h2><h4 id="结构体排序"><a href="#结构体排序" class="headerlink" title="结构体排序"></a>结构体排序</h4><p><strong>代码示例，</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp;_node) <span class="type">const</span> &#123; <span class="comment">// 重载小于号，自定义升序排列</span></span><br><span class="line">        <span class="keyword">if</span>(a != _node.a) <span class="keyword">return</span> a &lt; _node.a; <span class="comment">// 按第一关键排</span></span><br><span class="line">        <span class="keyword">return</span> b &lt; _node.b; <span class="comment">// 第一关键字相等按第二关键字排</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;node&gt; arr;</span><br><span class="line">    arr.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    arr.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line">    arr.<span class="built_in">push_back</span>(&#123;<span class="number">2</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    arr.<span class="built_in">push_back</span>(&#123;<span class="number">2</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>()); <span class="comment">// 按照自定义排序规则</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node : arr) &#123;</span><br><span class="line">       std::cout &lt;&lt; node.a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; node.b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果为</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>类似用法，</strong></p><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/6685680/">【文档 结构体排序的四种方法】</a></p><hr><h4 id="优先队列自定义排序"><a href="#优先队列自定义排序" class="headerlink" title="优先队列自定义排序"></a>优先队列自定义排序</h4><p><strong>代码示例，</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="comment">// 注意，优先队列的排序是相反的，这里指a大的排在前面，a相同时，b大的排前面</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp;_node) <span class="type">const</span> &#123; <span class="comment">// 重载小于号，这里实际是一个降序序列</span></span><br><span class="line">        <span class="keyword">if</span>(a != _node.a) <span class="keyword">return</span> a &lt; _node.a; <span class="comment">// 按第一关键排</span></span><br><span class="line">        <span class="keyword">return</span> b &lt; _node.b; <span class="comment">// 第一关键字相等按第二关键字排</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::priority_queue&lt;node&gt; heap; <span class="comment">// （优先队列默认是大根堆）自定义排序规则，这里维护的是一个大根堆</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">1</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">2</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">2</span>,<span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; heap.<span class="built_in">top</span>().a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; heap.<span class="built_in">top</span>().b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 这样输出的结果是降序排列的，是大根堆</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果为，</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>类似题型，</strong></p><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/description/">【LeetCode 47. 前 K 个高频元素】</a>    <a href="https://www.acwing.com/activity/content/code/content/6614070/">【题解】</a></p><hr><h4 id="pair二元组关键字排序"><a href="#pair二元组关键字排序" class="headerlink" title="pair二元组关键字排序"></a>pair二元组关键字排序</h4><p>pair 默认对first升序，当first相同时对second升序</p><p><strong>相关题型，</strong></p><p><a href="https://www.acwing.com/problem/content/3428/">【AcWing 3425. 小白鼠排队】</a>    <a href="https://www.acwing.com/file_system/file/content/whole/index/content/9155751/">【题解】</a></p><p><a href="https://www.acwing.com/problem/content/3454/">【AcWing 3451. 字符串排序II】</a>    <a href="https://www.acwing.com/file_system/file/content/whole/index/content/9155991/">【题解】</a></p><hr><h4 id="sort-自定义排序，需重载比较函数"><a href="#sort-自定义排序，需重载比较函数" class="headerlink" title="sort()自定义排序，需重载比较函数"></a>sort()自定义排序，需重载比较函数</h4><p><strong>sort()常规用法，</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; res = &#123;<span class="number">4</span>,<span class="number">92</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>()); <span class="comment">// 默认升序排列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : res) &#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种降序排列写法</span></span><br><span class="line"><span class="built_in">sort</span>(res.<span class="built_in">rbegin</span>(), res.<span class="built_in">rend</span>()); <span class="comment">// 降序排列写法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : res) &#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : res) &#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果为：</span></span><br><span class="line"><span class="number">-1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">92</span></span><br><span class="line"><span class="number">92</span> <span class="number">4</span> <span class="number">4</span> <span class="number">1</span> <span class="number">-1</span></span><br><span class="line"><span class="number">92</span> <span class="number">4</span> <span class="number">4</span> <span class="number">1</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>其他用法，</strong></p><p><a href="https://blog.csdn.net/liguojie12/article/details/113800426#sort__2">【文档 C++ 二维vector排序(sort用法)】</a></p><hr><h2 id="其他一些常用库函数"><a href="#其他一些常用库函数" class="headerlink" title="其他一些常用库函数"></a>其他一些常用库函数</h2><h3 id="求最值，max-min"><a href="#求最值，max-min" class="headerlink" title="求最值，max,min"></a>求最值，max,min</h3><p>需要引入``<algorithm>`头文件, 使用初始化列表形式来传参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ma = std::<span class="built_in">max</span>(&#123;<span class="number">99</span>,<span class="number">1</span>,<span class="number">30</span>,<span class="number">0</span>&#125;); <span class="comment">// 比较多个数大小，可以采用初始化列表的方式</span></span><br><span class="line"><span class="type">int</span> mi = std::<span class="built_in">min</span>(&#123;<span class="number">1</span>,<span class="number">-33</span>,<span class="number">10</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; ma &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; mi &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><hr><h3 id="查找最值元素下标，max-element-min-element"><a href="#查找最值元素下标，max-element-min-element" class="headerlink" title="查找最值元素下标，max_element min_element"></a>查找最值元素下标，max_element min_element</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">99</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">max_element</span>(a,a+<span class="number">5</span>)-a &lt;&lt; std::endl; <span class="comment">// index: 4</span></span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">min_element</span>(a,a+<span class="number">5</span>)-a &lt;&lt; std::endl; <span class="comment">// index: 0</span></span><br></pre></td></tr></table></figure><hr><h3 id="求排列，prev-permutation-next-permutation"><a href="#求排列，prev-permutation-next-permutation" class="headerlink" title="求排列，prev_permutation next_permutation"></a>求排列，prev_permutation next_permutation</h3><p><code>prev_permutation</code>函数是生成给定序列的上一个较小的排列。</p><p><code>next_permutation</code>函数是求下一个全排列。</p><p><strong>相关应用，</strong></p><p><a href="https://blog.csdn.net/bettle_king/article/details/117607173">【prev_permutation函数】</a></p><p><a href="https://www.acwing.com/activity/content/code/content/6185851/">【AcWing 51. 数字排列】</a></p><hr><p>好了，暂时先收录这些，有新内容了在抽空更新整理吧</p><p>….</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.yuque.com/jackyao/ifeq8i/vyigt9">【文档 C++ 刷题常用技巧】</a></p><p><a href="https://www.bilibili.com/video/BV1pv4y1w7GY/?share_source=copy_web&vd_source=64863a79f6edd334371cb7b41a0df347">【视频 C/C++常用刷题技巧】</a></p><p><a href="https://www.bilibili.com/video/BV1JL4y1h76U/?spm_id_from=333.999.0.0&vd_source=e9f1ced96b267a4bc02ec41ca31d850a">【视频 C++ 那些写起来简单方便的函数】</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-算法刷题-常用技巧汇总&quot;&gt;&lt;a href=&quot;#C-算法刷题-常用技巧汇总&quot; class=&quot;headerlink&quot; title=&quot;C++ 算法刷题 - 常用技巧汇总&quot;&gt;&lt;/a&gt;C++ 算法刷题 - 常用技巧汇总&lt;/h2&gt;&lt;h2 id=&quot;定义变量&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://ariesfun.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://ariesfun.gitee.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 常用STL及用法 - 速查文档</title>
    <link href="https://ariesfun.gitee.io/posts/8b87.html"/>
    <id>https://ariesfun.gitee.io/posts/8b87.html</id>
    <published>2023-07-20T17:36:58.935Z</published>
    <updated>2023-07-20T18:21:31.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-常用STL及用法-速查文档"><a href="#C-常用STL及用法-速查文档" class="headerlink" title="C++ 常用STL及用法 - 速查文档"></a>C++ 常用STL及用法 - 速查文档</h2><p><strong>具体使用方法，先用现查即可！！！</strong></p><p><strong>相关文档推荐，</strong></p><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/3598249/">【文档：C++语法基础 第8讲 常用STL】</a></p><p><a href="https://blog.csdn.net/m0_73896521/article/details/128153203">【文档：从c语言到c++（stl容器/stl函数总结）】</a></p><hr><h3 id="stirng-字符串"><a href="#stirng-字符串" class="headerlink" title="stirng 字符串"></a><code>stirng</code> 字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>()/<span class="built_in">length</span>()  返回字符串长度</span><br><span class="line"><span class="built_in">empty</span>() 返回<span class="type">bool</span>类型</span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line">    </span><br><span class="line"><span class="built_in">substr</span>(起始下标，(子串长度))  返回子串</span><br><span class="line"><span class="built_in">c_str</span>()  返回字符串所在字符数组的起始地址</span><br></pre></td></tr></table></figure><hr><h3 id="vector-变长数组"><a href="#vector-变长数组" class="headerlink" title="vector 变长数组"></a><code>vector</code> <strong>变长数组</strong></h3><p><strong>倍增的思想</strong></p><p>特点：系统为某一程序分配空间时，<strong>所需时间</strong>与空间大小无关，只与申请的次数有关。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>()  返回元素个数</span><br><span class="line"><span class="built_in">empty</span>()  返回是否为空</span><br><span class="line"><span class="built_in">clear</span>()   将清空</span><br><span class="line"></span><br><span class="line"><span class="built_in">front</span>()/<span class="built_in">back</span>() <span class="comment">// back()是返回最后一个元素</span></span><br><span class="line"><span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>() <span class="comment">// 元素的增删，在末尾进行</span></span><br><span class="line"><span class="built_in">begin</span>()/<span class="built_in">end</span>() 迭代器</span><br><span class="line">[] <span class="comment">// 支持随机寻址</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>()); <span class="comment">// 数组元素翻转</span></span><br><span class="line"></span><br><span class="line">支持比较运算，按字典序</span><br></pre></td></tr></table></figure><p><strong>代码示例，</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>, <span class="number">3</span>)</span></span>; <span class="comment">// 数组初始化，指定元素个数及值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 10个3</span></span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// vector的另外两种遍历方式</span></span><br><span class="line">    std::cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(std::vector&lt;<span class="type">int</span>&gt;::iterator i = a.<span class="built_in">begin</span>(); i != a.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">    std::cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><hr><h3 id="pair-lt-int-int-gt-二元组"><a href="#pair-lt-int-int-gt-二元组" class="headerlink" title="pair&lt;int, int&gt; 二元组"></a><code>pair&lt;int, int&gt;</code> 二元组</h3><p>类似结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first, 第一个元素</span><br><span class="line">second, 第二个元素</span><br><span class="line"></span><br><span class="line">支持比较运算，以first为第一关键字，以second为第二关键字（字典序）（帮我们实现了排序）</span><br></pre></td></tr></table></figure><hr><h3 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue, 队列"></a><code>queue</code>, 队列</h3><p>(没有清空函数)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">push</span>()  向队尾插入一个元素</span><br><span class="line"><span class="built_in">front</span>()  返回队头元素</span><br><span class="line"><span class="built_in">back</span>()  返回队尾元素</span><br><span class="line"><span class="built_in">pop</span>()  弹出队头元素</span><br></pre></td></tr></table></figure><hr><h3 id="priority-queue-优先队列"><a href="#priority-queue-优先队列" class="headerlink" title="priority_queue, 优先队列"></a><code>priority_queue</code>, <strong>优先队列</strong></h3><p>默认是大根堆(用堆；来实现的)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> <span class="comment">// 引入头文件</span></span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">// 默认是大根堆</span></span><br><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">push</span>()  插入一个元素</span><br><span class="line"><span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line"><span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">    </span><br><span class="line">定义成小根堆的方式：</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure><hr><h3 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack, 栈"></a><code>stack</code>, 栈</h3><p> (优先队列跟栈类似)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">push</span>()  向栈顶插入一个元素</span><br><span class="line"><span class="built_in">top</span>()  返回栈顶元素</span><br><span class="line"><span class="built_in">pop</span>()  弹出栈顶元素</span><br></pre></td></tr></table></figure><hr><h3 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque, 双端队列"></a><code>deque</code>, 双端队列</h3><p>(加强版的vector)，但效率较低</p><p>头尾都可以插入或删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line"><span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line"><span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line"><span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line"><span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">[] <span class="comment">// 支持随机访问</span></span><br></pre></td></tr></table></figure><hr><h3 id="set-map-multiset-multimap-哈希表"><a href="#set-map-multiset-multimap-哈希表" class="headerlink" title="set, map, multiset, multimap 哈希表"></a><code>set, map, multiset, multimap</code> 哈希表</h3><p> 基于平衡二叉树（红黑树实现），动态维护有序序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line"><span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">### `set/multiset`</span><br><span class="line"></span><br><span class="line"> 区别：set不能有重复元素</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="built_in">insert</span>()  插入一个数</span><br><span class="line"><span class="built_in">find</span>()  查找一个数</span><br><span class="line"><span class="built_in">count</span>()  返回某一个数的个数</span><br><span class="line">    </span><br><span class="line"><span class="built_in">erase</span>() </span><br><span class="line">两种参数：</span><br><span class="line">(<span class="number">1</span>) 输入是一个数x，删除所有<span class="function">x   <span class="title">O</span><span class="params">(k + logn)</span>， k是x的个数</span></span><br><span class="line"><span class="function"><span class="params">(<span class="number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span></span><br></pre></td></tr></table></figure><hr><h3 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound()/upper_bound()"></a><code>lower_bound()/upper_bound()</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lower_bound</span>(x)  返回大于等于x的最小的数的迭代器  <span class="comment">// 一般升序使用</span></span><br><span class="line"><span class="built_in">upper_bound</span>(x)  返回大于x的最小的数的迭代器</span><br></pre></td></tr></table></figure><hr><h3 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a><code>map/multimap</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>()  插入的数是一个pair,两个数</span><br><span class="line"><span class="built_in">erase</span>()  输入的参数是pair或者迭代器</span><br><span class="line"><span class="built_in">find</span>()</span><br><span class="line">[]  注意multimap不支持此操作。 时间复杂度是 <span class="built_in">O</span>(logn)</span><br><span class="line"><span class="built_in">lower_bound</span>()/<span class="built_in">upper_bound</span>()</span><br></pre></td></tr></table></figure><hr><h3 id="unordered-set-unordered-map-unordered-multiset-unordered-multimap-哈希表"><a href="#unordered-set-unordered-map-unordered-multiset-unordered-multimap-哈希表" class="headerlink" title="unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表"></a><code>unordered_set, unordered_map, unordered_multiset, unordered_multimap</code>, 哈希表</h3><p><strong>好处：和上面类似，增删改查的时间复杂度是 O(1)</strong></p><p>区别：不支持 lower_bound()/upper_bound() 的排序操作， 迭代器的++，–</p><hr><h3 id="bitset-圧位"><a href="#bitset-圧位" class="headerlink" title="bitset, 圧位"></a><code>bitset</code>, 圧位</h3><p>（位存储，状态压缩），可以省存储空间（省8位空间，节省1/8存储）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;10000&gt; s;</span><br><span class="line">~, &amp;, |, ^</span><br><span class="line">&gt;&gt;, &lt;&lt;</span><br><span class="line">==, !=</span><br><span class="line">[] <span class="comment">// 取出来每一位</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line"><span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line"><span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line"><span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">flip</span>()  等价于~</span><br><span class="line"><span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/3598249/">【文档：C++语法基础 第8讲 常用STL】</a></p><p><a href="https://blog.csdn.net/m0_73896521/article/details/128153203">【文档：从c语言到c++（stl容器/stl函数总结）】</a></p><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/488704/">【视频：1.8 STL、位运算、常用库函数 - 49min左右】</a></p><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/4799/">【视频：第二章 数据结构（三）常用STL 1h10min左右】</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-常用STL及用法-速查文档&quot;&gt;&lt;a href=&quot;#C-常用STL及用法-速查文档&quot; class=&quot;headerlink&quot; title=&quot;C++ 常用STL及用法 - 速查文档&quot;&gt;&lt;/a&gt;C++ 常用STL及用法 - 速查文档&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;具体</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://ariesfun.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://ariesfun.gitee.io/tags/C-C/"/>
    
    <category term="STL" scheme="https://ariesfun.gitee.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础 第五讲 Git</title>
    <link href="https://ariesfun.gitee.io/posts/43cd.html"/>
    <id>https://ariesfun.gitee.io/posts/43cd.html</id>
    <published>2023-06-15T17:17:11.987Z</published>
    <updated>2023-07-20T17:37:31.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux基础-第五讲-Git"><a href="#Linux基础-第五讲-Git" class="headerlink" title="Linux基础 第五讲 Git"></a>Linux基础 第五讲 Git</h2><h2 id="1-Git教程"><a href="#1-Git教程" class="headerlink" title="1.Git教程"></a>1.Git教程</h2><p><a href="git.acwing.com">AcWing代码托管平台</a></p><p><a href="https://learngitbranching.js.org/?locale=zh_CN">Git可视化学习网站-游戏</a></p><p><a href="https://gitee.com/all-about-git">Git大全 - 教程综合</a></p><hr><h3 id="1-1-Git基本概念"><a href="#1-1-Git基本概念" class="headerlink" title="1.1 Git基本概念"></a>1.1 Git基本概念</h3><p>Git 是一个版本控制工具，可以记录我们每次提交到 Git 中的版本，便于版本控制；上传到云端可以对本地的Git版本进行存档，以及进行多人协作开发。</p><p><strong>Git是用树的结构来维护所有的版本记录，最开始节点是一个空的根节点。</strong></p><p><strong>HEAD根节点会始终指向最新提交的那个节点</strong>。</p><p>概念</p><p><strong>工作区：仓库的目录</strong>。</p><p><strong>暂存区</strong>：<strong>数据暂时存放的区域</strong>，<strong>类似于工作区写入版本库前的缓存区</strong>。</p><p>工作区、暂存区都是独立于各个分支的。</p><p><strong>版本库：存放所有已经提交到本地仓库的代码版本。</strong></p><p><strong>版本结构：树结构，树中每个节点代表一个代码版本。</strong></p><hr><h3 id="1-2-Git常用命令"><a href="#1-2-Git常用命令" class="headerlink" title="1.2 Git常用命令"></a>1.2 Git常用命令</h3><p><strong>个人开发最最最最常用的4个git命令！！！</strong>只使用<code>master</code>分支即可</p><p><code>git pull</code>        <code>git add .</code>          <code>git commit -m &quot;xxx&quot;</code>        <code>git push</code></p><hr><p><strong>协作开发会用到的命令！！</strong></p><h4 id="Git全局配置"><a href="#Git全局配置" class="headerlink" title="Git全局配置"></a>Git全局配置</h4><p>在使用Git服务之前，你需要进行全局配置</p><p><code>git config --global user.name xxx</code>：设置全局用户名</p><p><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址</p><p>设置的信息记录会存储在<code>~/.gitconfig</code>文件中</p><p><strong>开始使用的流程，</strong></p><p>注意！！！<code>github</code>的默认分支名为<code>main</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -M main # 修改本地的分支名(master --&gt; main)</span><br><span class="line">git push -u origin main # 将本地分支上传至云端</span><br></pre></td></tr></table></figure><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230708003343580.png" alt="image-20230708003343580" style="zoom: 60%;" /><hr><h4 id="Git常用操作"><a href="#Git常用操作" class="headerlink" title="Git常用操作"></a>Git常用操作</h4><p>你需要新建一个项目目录 eg. <code>project/</code>，</p><p><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的<code>.git</code>文件夹中</p><p>目录里的文件被修改后，<strong>需要将文件从工作区添加到暂存区并进行持久化</strong></p><p><code>git add XXX</code>：单独将XXX文件添加到暂存区,可添加多个文件或目录，用空格隔开</p><p>这两个命令，通常一起使用</p><p><code>git add .</code>：<strong>将所有待加入暂存区的文件加入暂存区</strong></p><p><code>git commit -m &quot;这次提交的备注信息&quot;</code>：<strong>将暂存区的内容提交到当前分支,进行持久化</strong></p><p><code>git status</code>：<strong>查看当前仓库状态</strong></p><p><code>git diff XXX</code>：查看XXX文件的工作区相对于暂存区对应的文件的差异</p><p><code>git diff HEAD</code>:  显示工作区与当前分支最新commit提交之间的差异</p><p><code>git log</code>：<strong>查看当前分支的所有版本</strong>，按<code>q</code>退出查看状态</p><p><code>git log --oneline</code> 或 <code>git log --pretty=oneline</code>：让日志格式化显示在一行</p><p>HEAD会指向最后一次持久化操作的节点，<strong>即HEAD指向最新的版本</strong></p><p><code>git log --stat</code>：显示 commit 历史，以及每次 commit 发生变更的文件</p><hr><h4 id="删除-撤销命令"><a href="#删除-撤销命令" class="headerlink" title="删除/撤销命令"></a>删除/撤销命令</h4><p><code>git rm --cached XXX</code>：<strong>将文件从仓库索引目录中删掉</strong>，不希望管理这个文件</p><p>（将本地文件删除的话，<code>git rm XXX</code>,提交<code>commit</code>后，再<code>git push</code>）</p><p><code>git restore --staged XXX</code>：<strong>将XXX从暂存区里移除，文件内容不会被修改</strong></p><p><code>git restore XXX</code>：<strong>可将暂存区的文件回滚</strong></p><p><code>git checkout — XXX</code> 或 <code>git restore XXX</code>：将XXX文件<strong>尚未加入暂存区的修改全部撤销，类似ctrl+z</strong></p><hr><h4 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h4><p><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）</p><p><code>git reset --hard HEAD^ </code> 或 <code>git reset --hard HEAD~</code>：将代码库回滚到上一个版本</p><ul><li><p><code>git reset --hard HEAD^^</code>：往上回滚两次”^^”，以此类推</p></li><li><p><code>git reset --hard HEAD~100</code>：往上回滚100个版本</p></li><li><p><code>git reset --hard 版本号</code>：回滚到某一特定版本(版本号是用<code>git log</code> 看到的commit前7位字符)</p></li></ul><hr><h4 id="创建-合并分支"><a href="#创建-合并分支" class="headerlink" title="创建/合并分支"></a>创建/合并分支</h4><p><code>git checkout -b branch_name</code>：<strong>创建并切换到<code>branch_name</code>这个分支</strong></p><p><code>git branch branch_name</code>：<strong>创建新分支<code>branch_name</code></strong></p><p><code>git checkout branch_name</code>：<strong>切换到<code>branch_name</code>这个分支</strong></p><p><code>git branch</code>：查看所有分支和当前所处分支</p><p><code>git branch -r </code>： -r，remote 查看所有远程分支</p><p><code>git branch -a</code>： -a，all 查看所有分支，包括本地分支和远程分支</p><p><code>git merge branch_name</code>：<strong>将分支<code>branch_name</code>合并到当前分支上</strong></p><p><strong>(若分支合并后有冲突，需要自己手动解决)</strong></p><p><code>git branch -d branch_name</code>：<strong>删除本地仓库的<code>branch_name</code>分支</strong></p><p><code>git pull</code>：<strong>将远程仓库的当前分支与本地仓库的当前分支合并，从云端拉回本地</strong></p><ul><li><code>git pull origin branch_name</code>：将远程仓库的<code>branch_name</code>分支与本地仓库的当前分支合并</li></ul><p>ps: 多人协作开发同一个分支时，<br>第一个人push提交后，第二个人也push提交了会有冲突，需要第二人先pull新版本后，合并本地修改冲突后，再push自己的代码。</p><hr><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p>你需要再远程仓库创建一个仓库，并配置SSH将主机的公钥填写至远程仓库中。</p><p><code>git remote add origin SSH克隆的地址 </code>：将本地仓库关联到远程仓库</p><p>连接gitlab时，进行<code>git clone</code>时，出现<u>fatal: remote origin already exists.</u></p><p>需要先<code>git remote remove origin</code>，然后再关联远程仓库</p><p><code>git push -u </code>：(第一次需要-u，upstream上传流，以后不需要)，<code>git push</code><strong>将当前分支推送到远程仓库</strong></p><ul><li><code>git push origin branch_name</code>：<strong>将本地的某个分支推送到远程仓库</strong></li></ul><p><code>git clone git@git.acwing.com:xxx/XXX.git</code>：<strong>将远程仓库XXX下载到本地，比如用另一台电脑开发</strong></p><p><code>git push --set-upstream origin branch_name</code>：设置本地的<code>branch_name</code>分支对应远程仓库的<code>branch_name</code>分支</p><p><code>git push -d origin branch_name</code>：<strong>删除远程仓库的<code>branch_name</code>分支</strong></p><p>(<code>git branch -d branch_name</code>：<strong>删除本地仓库的<code>branch_name</code>分支</strong>)</p><p>​    </p><p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：</p><p>将远程的<code>branch_name1</code>分支与本地的<code>branch_name2</code>分支对应，<strong>两分支名最好相同</strong></p><p><code>git checkout -t origin/branch_name </code>将远程的<code>branch_name</code>分支拉取到本地</p><hr><h4 id="Stash栈操作"><a href="#Stash栈操作" class="headerlink" title="Stash栈操作"></a>Stash栈操作</h4><p>使用 <code>Stash</code> 将我们目前工作区和暂存区中未提交的修改添加进去。等处理完一些线上的问题再把刚才的工作的文件从 <code>Stash</code> 中弹出来继续开发，</p><p><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中</p><p><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</p><p><code>git stash drop</code>：删除栈顶存储的修改</p><p><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</p><p><code>git stash list</code>：查看栈中所有元素</p><hr><h3 id="1-3-其他"><a href="#1-3-其他" class="headerlink" title="1.3 其他"></a>1.3 其他</h3><p>小Tips:</p><p><strong>让vscode不显示git修改的文件</strong></p><p>问题所在：在项目最外层文件夹<code>git init</code>了，产生了一个<code>.git</code>文件。<br>解决方法：在终端进入最外层文件夹，输入命令：<code>rm -rf .git </code>，删除git相关配置文件</p><hr><h2 id="2-作业"><a href="#2-作业" class="headerlink" title="2.作业"></a>2.作业</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">homework 5 create  # 可以重新创建所有lesson_5的作业</span><br><span class="line">homework 5 test  # 可以评测lesson_5的所有作业</span><br></pre></td></tr></table></figure><p>注意： 本次作业的10个题目不是独立的，每个题目会依赖于前一个题目，因此评测时如果当前题目错误，则不再评测后续题目。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">创建好作业后，先进入文件夹/home/acs/homework/lesson_5/，然后：</span><br><span class="line"></span><br><span class="line">(0) 在当前目录下创建文件夹homework，并将homework目录配置成git仓库。后续作业均在homework目录下操作；</span><br><span class="line"></span><br><span class="line">(1) 创建文件readme.txt，内容包含一行：111；</span><br><span class="line">将修改提交一个commit；</span><br><span class="line"></span><br><span class="line">(2) 在readme.txt文件末尾新增一行：222；</span><br><span class="line">将修改提交一个commit；</span><br><span class="line"></span><br><span class="line">(3) 创建文件夹：problem1和problem2；</span><br><span class="line">创建文件problem1/main.cpp。文件内容为下述链接中的代码：https://www.acwing.com/problem/content/submission/code_detail/7834813/；</span><br><span class="line">创建文件problem2/main.cpp。文件内容为下述链接中的代码：https://www.acwing.com/problem/content/submission/code_detail/7834819/；</span><br><span class="line">将修改提交一个commit；</span><br><span class="line"></span><br><span class="line">(4) 删除文件夹problem2；</span><br><span class="line">创建文件夹problem3；</span><br><span class="line">创建文件problem3/main.cpp。文件内容为下述链接中的代码：https://www.acwing.com/problem/content/submission/code_detail/7834841/；</span><br><span class="line">将readme.txt中最后一行222删掉，然后添加一行333；</span><br><span class="line">将修改提交一个commit；</span><br><span class="line"></span><br><span class="line">(5) 在https://git.acwing.com/上注册账号并创建仓库，仓库名称为homework；</span><br><span class="line">将本地git仓库上传到AC Git云端仓库；</span><br><span class="line"></span><br><span class="line">(6) 创建并切换至新分支dev；</span><br><span class="line">在readme.txt文件中添加一行444；</span><br><span class="line">将修改提交一个commit；</span><br><span class="line">将dev分支推送至AC Git远程仓库；</span><br><span class="line"></span><br><span class="line">(7) 切换回master分支；</span><br><span class="line">在readme.txt文件中添加一行555；</span><br><span class="line">将修改提交一个commit；</span><br><span class="line"></span><br><span class="line">(8) 将dev分支合并到master分支；</span><br><span class="line">手动处理冲突，使readme文件最终内容包含4行：111、333、555、444；</span><br><span class="line">将修改提交一个commit；</span><br><span class="line"></span><br><span class="line">(9) 将master分支的版本库push到AC Git云端仓库；</span><br><span class="line">登录myserver服务器（4. ssh作业中配置的服务器）；</span><br><span class="line">创建并清空文件夹：~/homework/lesson_5/；</span><br><span class="line">将AC Git云端仓库clone到~/homework/lesson_5/中；</span><br></pre></td></tr></table></figure><hr><h4 id="作业打卡地址"><a href="#作业打卡地址" class="headerlink" title="作业打卡地址"></a>作业打卡地址</h4><p>待完成~~</p><hr><h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3.参考资料"></a>3.参考资料</h2><p><a href="https://www.acwing.com/activity/content/57/">Linux基础课及讲义 - AcWing</a></p><p><a href="https://tonngw.com/2022/04/03/AcWing/%E7%AC%AC%205%20%E8%AE%B2%20Git/#10-Stash-%E6%93%8D%E4%BD%9C">Linux基础课 - 第 5 讲 Git - by Toggle</a></p><p><a href="https://www.acwing.com/blog/content/33309/">Linux笔记 5 - Git - by 溯光</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux基础-第五讲-Git&quot;&gt;&lt;a href=&quot;#Linux基础-第五讲-Git&quot; class=&quot;headerlink&quot; title=&quot;Linux基础 第五讲 Git&quot;&gt;&lt;/a&gt;Linux基础 第五讲 Git&lt;/h2&gt;&lt;h2 id=&quot;1-Git教程&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Linux基础知识" scheme="https://ariesfun.gitee.io/categories/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Linux" scheme="https://ariesfun.gitee.io/tags/Linux/"/>
    
    <category term="Git" scheme="https://ariesfun.gitee.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>机器学习与数据挖掘 刷题练习(复习版)</title>
    <link href="https://ariesfun.gitee.io/posts/b9aa.html"/>
    <id>https://ariesfun.gitee.io/posts/b9aa.html</id>
    <published>2023-06-03T18:17:05.594Z</published>
    <updated>2023-06-04T03:20:07.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器学习与数据挖掘-刷题练习-复习版"><a href="#机器学习与数据挖掘-刷题练习-复习版" class="headerlink" title="机器学习与数据挖掘 刷题练习(复习版)"></a>机器学习与数据挖掘 刷题练习(复习版)</h2><p>闲言碎语：</p><p>本文是自己在准备数据挖掘结课考试时，自己整理的学习笔记，放在这存个档。</p><p>这门课我只是较为浅显的知道了一些理论概念，不过这门课的知识实践需要花费较多的时间和精力，是我本专业必</p><p>学的一门核心课，以后我可能还能用上哈~~</p><h2 id="一、单选题及判断"><a href="#一、单选题及判断" class="headerlink" title="一、单选题及判断"></a>一、单选题及判断</h2><hr><h3 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a><strong>1.数据</strong></h3><p>1.不属于<u>数据的属性类型</u>的是，<strong>相异</strong></p><p>数据的属性类型包括<u>标称、序数、区间和比率等四种</u></p><p>2.原始数据<u>存在的几个问题</u>不包括，<strong>不重复</strong></p><p><strong>数据挖掘(Data Mining)就是从大量的、不完全的、有噪声的、模糊的</strong>、随机的实际应用数据中,提取隐含在其中的、人们事先不知道的、但又是潜在有用的信息和知识的过程</p><p><strong>对于数据挖掘中的原始数据，存在的问题有</strong>？ABCD</p><p><strong>A. 不一致    B. 重复    C. 不完整    D. 含噪声</strong></p><p>3.数据挖掘中使用的数据的原则不包括，<strong>保留唯一性</strong></p><p>4.<strong>数据预处理的效果</strong>直接决定了机器学习的结果质量</p><p>5.噪声数据的产生原因主要有？ABC</p><ul><li><strong>A. 数据采集设备有问题</strong></li><li><strong>B. 在数据录入过程中发生了人为或计算机错误</strong></li><li><strong>C. 数据传输过程中发生错误</strong></li></ul><p>6.数据挖掘的任务包含（ ABCDE）</p><ul><li><strong>A. 关联分析</strong></li><li><strong>B. 时序模式分析</strong></li><li><strong>C. 聚类</strong></li><li><strong>D. 分类</strong></li><li><strong>E. 偏差检测</strong> </li></ul><p>7.在数据集成时，来自多个数据源的现实世界实体的表达形式是不一样的，不一定是匹配的，<u>要考虑实体识别问题和属性冗余问题，从而把源数据在最低层上加以转换、提炼和集成。</u> <strong>A. 对</strong></p><p>8.给定 n 个数据点，如果其中一半用于训练，另一半用于测试，则训练误差和测试误差之间的差别会<strong>随着 n的增加而减小</strong>。 <strong>A. 对</strong></p><p>9.知识发现（KDD）包含<u>数据准备、数据挖掘、结果评价</u>三个阶段。 <strong>对的</strong></p><p>10.<u>通过数据规约</u>，可以达到（  ABC ） </p><ul><li><strong>A. 降低无效、错误数据对建模的影响，提高建模的准确性</strong></li><li><strong>B. 少量且具代表性的数据将大幅缩减数据挖掘所需的时间</strong></li><li><strong>C. 降低储存数据的成本</strong></li></ul><p>11.<strong>数据预处理方法</strong>主要有？ABCD</p><ul><li><strong>A. 数据清洗</strong></li><li><strong>B. 数据集成</strong></li><li><strong>C. 数据变换</strong></li><li><strong>D. 数据归约</strong></li></ul><p>11.1数据挖掘的<u>数据准备阶段</u>的主要工作包含（ ABCDE）。</p><ul><li><strong>A. 消除噪声</strong></li><li><strong>B. 推导计算缺值数据</strong></li><li><strong>C. 消除重复记录</strong></li><li><strong>D. 数据转换</strong></li><li><strong>E. 消减数据维数或降维</strong></li></ul><p>13.<strong>特征选择可以？****ABC</strong></p><ul><li><strong>A. 选择区分能力强的数据</strong></li><li><strong>B. 降低模型分析的时间复杂度</strong></li><li><strong>C. 减少无效特征</strong></li></ul><p>14.<strong>信息增益度量</strong>偏向具有许多输出的测试，也就是说它<strong>倾向于选择具有大量值的属性</strong>。 <strong>A. 对</strong></p><hr><h3 id="2-数据仓库"><a href="#2-数据仓库" class="headerlink" title="2.数据仓库"></a><strong>2.数据仓库</strong></h3><p>1.以下各项均是针对数据仓库的不同说法,你<strong>认为正确的有</strong>，ABCD</p><ul><li><u>B. 数据仓库是一切商业智能系统的基础</u></li><li><u>C. 数据仓库是面向业务的,支持联机事务处理(OLTP)</u></li><li><u>D. 数据仓库支持决策而非事务处理</u></li><li><u>E. 数据仓库的主要目标就是帮助分析,做长期性的战略制定</u></li></ul><p>2.关于OLAP和OLTP的说法,<strong>下列不正确的是</strong>(   A   ) </p><ul><li><strong>A.  OLAP事务量大,但事务内容比较简单且重复率高.</strong></li><li>B. OLAP的最终数据来源与OLTP不一样.</li><li>C. OLTP面对的是决策人员和高层管理人员.</li><li>D. OLTP以应用为核心,是应用驱动的.</li></ul><p>3.<strong>OLAP技术的核心是，多维分析</strong></p><p>4<u>.数据仓库是随着时间变化的,下面的描述不正确的是</u>(  C   ) </p><ul><li><p>A. 数据仓库随时间的变化不断增加新的数据内容;</p></li><li><p>B. 捕捉到的新数据会覆盖原来的快照;</p></li><li><p><strong>C. 数据仓库随事件变化不断删去旧的数据内容;</strong></p></li><li><p>D. 数据仓库中包含大量的综合数据,这些综合数据会随着时间的变化不断地进行重新综合</p></li></ul><hr><h3 id="3-机器学习方法"><a href="#3-机器学习方法" class="headerlink" title="3.机器学习方法"></a><strong>3.机器学习方法</strong></h3><p>1.<strong>移动运营商对客户的流失进行预测</strong>,可以使用下面哪种机器学习方法比较合适 ,   <strong>多层前馈网络</strong></p><p>2.下列哪些模型可以用来判断特征的重要性？（ <strong>ABDE</strong>   ） </p><ul><li><strong>A. 随机森林（Random Forest）</strong></li><li><strong>B. 线性回归（Linear Regression）</strong></li><li>C. 支持向量机（SVM）</li><li><strong>D. 方差分析（ANOVA）</strong></li><li><strong>E. 逻辑回归（LogisticRegression）</strong></li></ul><p>​                                            </p><p>3.<strong>机器学习</strong>是<u>人工智能里面一个非常重要的<strong>技术</strong></u>，<strong>深度学习</strong>是<u>机器学习里面的一种方法</u>。 <strong>A. 对</strong></p><p>4.下列哪些<strong>机器学习算法不需要做归一化处理</strong>(  CE    )</p><ul><li><strong>C. DecisionTree 决策树</strong></li><li><strong>E. Naive Bayes classifier 贝叶斯</strong></li></ul><p>5.<u>泛化能力是机器学习中衡量学习机性能好坏的一个重要指标</u>，主要是指学习机对预测样本<strong>进行正确预测的能力</strong>。<strong>A. 对</strong></p><hr><h3 id="4-装袋"><a href="#4-装袋" class="headerlink" title="4.装袋"></a><strong>4.装袋</strong></h3><p>1.<strong>Bagging</strong>的主要特点有，   ABD</p><p> <strong>A. 各基础分类器并行生成   B. 各基础分类器权重相同  D. 基于Bootstrap采样生成训练集</strong></p><p>2.对<strong>Boosting模型</strong>的描述正确的是，</p><p><strong>A.  采用串行训练模式    C.  通过改变训练集进行有针对性的学习</strong></p><p>3.<u>装袋法中每个样本被选中概率相同</u>,所以噪声数据的影响下降,<u>容易受过拟合的影响</u>( ) <strong>错误</strong></p><hr><h3 id="5-决策树"><a href="#5-决策树" class="headerlink" title="5.决策树"></a><strong>5.决策树</strong></h3><p>1.决策树中属性选择的方法有？BCD</p><p><strong>B. 信息增益 C. 信息增益率 D. GINI系数</strong></p><p>2.下面的决策树中，不能解决回归问题的是？ABC</p><p><strong>A. ID3 B. C4.5 C. C5.0</strong></p><p>3.0决策树模型<strong>不适合</strong>训练集数据量较大的情况。<strong>错的</strong></p><p>3.1<u>决策树不擅长处理非数值型数据</u>。<strong>错的</strong></p><p>3.2<u>逻辑回归分析需要对离散值做预处理</u>，决策树则不需要。( ）<strong>A. 对</strong></p><p>3.3决策树算法<strong>只能处理二分类</strong>，不能处理多分类。 <strong>错的</strong></p><p>4.DecisionTreeClassifier实现了决策树的构建，下列说法正确的有（ <strong>ABCD</strong> ） </p><ul><li><strong>A. 参数criterion的取值有gini，entropy两种。</strong></li><li><strong>B. 参数max_depth限定了决策树的最大深度，对于防止过拟合非常有用。</strong></li><li><strong>C. 参数min_samples_leaf 限定了叶子结点包含的最小样本数。</strong></li><li><strong>D. gini越小，表示纯度越高。</strong></li></ul><p>5.<u>有关决策树的分类方法</u>正确的是( B )。</p><p><strong>B.决策树可以用于发现多种样本的特征</strong></p><p>6.逻辑回归分析需要<strong>对离散值做预处理</strong>，决策树则不需要。( ）    <strong>A. 对</strong></p><hr><h3 id="6-随机森林"><a href="#6-随机森林" class="headerlink" title="6.随机森林"></a><strong>6.随机森林</strong></h3><p>1.下面哪些<u>超参数的增加可能会造成随机森林数据过拟合</u>？<strong>A. 树的数量  B. 树的深度</strong></p><p>2.下列关于**<u>随机森林的描述正确</u>**的是(ABCD)。</p><ul><li><strong>A.  与袋装法采用相同样本抽取方式</strong></li><li><strong>B.  每次从所有属性中随机抽取t个属性来训练分类器</strong></li><li><strong>C.  每次从所有样本中选取一定比例的样本来训练分类器</strong></li><li><strong>D.  可以使用不同的决策树的组合来构建分类模型</strong></li></ul><hr><h3 id="7-分类"><a href="#7-分类" class="headerlink" title="7.分类"></a><strong>7.分类</strong></h3><p>1.<strong>分类算法有C4.5</strong></p><p><strong>常用的分类算法包括</strong>（  ABCD），</p><p><strong>A. 决策树 B. 支持向量机 C. 贝叶斯网络 D. 神经网络</strong></p><p><u>解决分类问题的方法</u>包括？ <strong>ABCD</strong></p><p><strong>A. 决策树    B. 贝叶斯    C. 人工神经网络    D. 支持向量机</strong></p><p>2.以下属于<u>分类器评价或比较尺度</u>的有:     </p><p>​    <strong>A.预测准确度</strong><br>​    <strong>C.模型描述的简洁度</strong><br>​    <strong>D.计算复杂度</strong></p><p>3.哪些<u>不是最近邻分类器的特点</u>，</p><p><strong>C.  最近邻分类器基于全局信息进行预测</strong></p><p>4.通过<strong>聚集多个分类器的预测</strong>来提高分类准确率的技术称为， <strong>组合(ensemble)</strong></p><p>5.**<u>评估分类器预测能力的度量包括</u>**（      ） </p><ul><li><strong>A. 准确率</strong></li><li><strong>B. 灵敏度(又称为召回率)</strong></li><li><strong>C. 特效性</strong></li><li><strong>D. 精度</strong></li><li><strong>E. F1和Fβ</strong></li></ul><p>6.在评价<strong>不平衡类问题分类的度量方法</strong>有如下几种,( )</p><p><strong>A. F1度量</strong><br><strong>B. 召回率(recall)</strong><br><strong>C. 精度(precision)</strong><br><strong>D. 真正率(ture positive rate,TPR)</strong></p><p>7.一般来说，回归不用在分类问题上，但是也有特殊情况，<u>比如logistic 回归可以用来解决0/1分类问题。（  ）</u> <strong>A. 对</strong></p><p>8.<strong>分类是有监督的学习，聚类是无监督的学习</strong></p><p>9.<strong>受试者操作特征曲线</strong>(Receiver Operating Characteristic Curve，<strong>ROC</strong>)是一种反映分类模型敏感性和特异性连续变量的综合，<u>ROC的横坐标，纵坐标分别表示（        ）</u></p><p><strong>A. 假正例率（FPR），真正例率（TPR）</strong></p><p><strong>E. 假阳率（特异度），真阳率（灵敏度）</strong></p><p>10.<strong>组合方法</strong>可以通过学习和组合一系列个体（基）<strong>分类器模型</strong>来提高总体准确率，主要的组合方法有（   ABC  ）。 </p><p><strong>A. 装袋    B. 提升    C. 随机森林</strong></p><p>11.在谈到分类时，<u>数据元组</u>也称为？ABCD</p><ul><li><p><strong>A. 样本</strong></p></li><li><p><strong>B. 实例</strong></p></li><li><p><strong>C. 数据点</strong></p></li><li><p><strong>D. 对象</strong></p></li></ul><p>12.<u>数据分类是一个两阶段过程</u>，包括（ ）和分类阶段。<strong>学习阶段</strong></p><p>13.<u>分类器的构造与评估需要把标记的数据集划分成训练集和检验集</u>，典型方法包含（   ABCD  ）。 </p><ul><li><strong>A. 保持</strong></li><li><strong>B. 随机抽样</strong></li><li><strong>C. 交叉验证</strong></li><li><strong>D. 自助法</strong></li></ul><p>14.对回归问题和分类问题的评价 <strong>最常用的指标都是准确率和召回率</strong>。<strong>错误</strong></p><p>15.<strong>输出变量为有限个离散变量的预测问题</strong>是回归问题；输出变量<strong>为连续变量的预测问题是</strong>分类问题。<strong>B.错误</strong></p><p>15.1分类和回归都可用于预测，<strong>分类的输出是离散的类别值</strong>，而回归的输出是是连续值。 <strong>A. 对</strong></p><p>16.<strong>朴素贝叶斯算法</strong>是基于贝叶斯定理与特征条件独立假设的<strong>分类方法</strong>。<strong>A.对的</strong></p><p>17.<u>模型选择方法</u>主要有(     <strong>AB</strong>       )。</p><ul><li><strong>A. 正则化（Regularization）</strong></li><li><strong>B. 交叉验证（Cross Validation）</strong></li></ul><p>18.<strong>分类</strong>是预测数据对象的<u>离散类别</u>，<strong>预测</strong>是用于数据对象的<u>连续取值</u>。<strong>A. 对</strong></p><p>19.在分类型机器学习过程中,下面有关分类算法的选择<strong>说法错误的</strong>是( AD)。</p><ul><li><strong>A. 算法参数是默认调好的,分析过程不需要修改</strong></li><li>B. 分类算法的优劣需要通过实验比较才能确定</li><li>C. 分类算法对数据有一定的要求,一种算法不能解决所有的分类问题</li><li><strong>D. 分类算法的结果只要训练样本准确度高就可以使用了</strong></li></ul><hr><h3 id="8-聚类"><a href="#8-聚类" class="headerlink" title="8.聚类"></a><strong>8.聚类</strong></h3><p>1.当不知道数据所带标签时，可以使用哪种技术<strong>促使带同类标签的数据与带其他标签的数据相分离</strong>？<strong>（聚类）</strong></p><p>2.如何衡量聚类质量，<strong>需要考虑数据点间的连通性</strong></p><p>3.哪种聚类方法可以提供聚类树形图，<strong>层次聚类</strong></p><p>4.通过以下哪些指标我们可以<u>在层次聚类中寻找两个集群之间的差异</u>？ABC</p><p><strong>A. 单链 B. 完全链接 C. 平均链接</strong></p><p>5.聚类分析中，<strong>簇间距离可以定义为</strong>（ ABCD）</p><ul><li><u>A. 最短距离法（最大相似度）</u></li><li><u>B. 最长距离法（最小相似度）</u></li><li><u>C. 类平均法</u></li><li><u>D. 中心法（两类的两个中心点的距离为簇间距离）</u></li></ul><p><u>6.聚类系数的外部指标是指将聚类结果</u>和某个“参考模型”进行比较。<strong>A. 对</strong></p><p>7.<em><strong>DBSCAN</strong></em>(Density-Based Spatial Clustering of Applications with Noise)</p><p><strong>DBSCAN是一个比较有代表性的基于密度的聚类算法。</strong></p><p>DBSCAN在最坏情况下的<u>时间复杂度是，**$O(m^2)$**</u></p><p><u>DBSCAN是相对抗噪声的，并且能够处理任意形状和大小的簇</u>。<strong>对的</strong></p><p>7.1 使用Python的sklearn.cluster库中的<strong>DBSCAN算法进行聚类的时候</strong>，<u>参数eps和min_samples的描述正确的是（ ）。</u></p><ul><li><p><strong>B. eps越小，聚出来的类越多</strong></p></li><li><p><strong>C. min_samples越小，一个簇中包含的样本点越少</strong></p></li></ul><p>8.<strong>基于密度的聚类算法代表算法</strong>有（  ABC  ） </p><p><strong>A. DBSCAN算法    B. OPTICS算法    C. DENCLUE算法</strong></p><p>9.Python中<strong>层次聚类的函数</strong>是AgglomerativeClustering，<u>重要的参数包含</u>（  ABC ）。 </p><p><strong>A. n_clusters    B. affinity    C. linkage</strong></p><p>9.1层次聚类的函数AgglomerativeClustering中，<strong>linkage是类间距离的定义</strong>，其取值包含（ ABC） </p><ul><li><strong>A. ward</strong></li><li><strong>B. average</strong></li><li><strong>C. complete</strong></li></ul><p>10.哪些数据特性都是对聚类分析具有很强影响的。(   ABCD   )</p><ul><li><strong>A. 高维性</strong></li><li><strong>B. 规模</strong></li><li><strong>C. 稀疏性</strong></li><li><strong>D. 噪声和离群点</strong></li></ul><p>11.<strong>聚类分析</strong>是一种有监督的学习方法。<strong>B.错的</strong></p><p>12.<strong>影响聚类结果的主要因素有哪些</strong>（ ABCD ） </p><ul><li><strong>A. 分类准则</strong></li><li><strong>B. 相似性测度（度量）</strong></li><li><strong>C. 特征量选择</strong></li><li><strong>D. 量纲</strong></li></ul><p>13.<strong>层次聚类可分为“自顶向下”和“自底向上”</strong>两种策略；<strong>A.对的</strong></p><p>14.下列哪项<strong>不属于聚类分析的算法</strong>(D)</p><ul><li>A. K-Means</li><li>B. K-中心点</li><li>C. 系统聚类</li><li><strong>D. Apriori算法</strong></li></ul><p>15.某电商分析人员希望通过聚类方法定位代商家刷信用级别的违规者，以下哪些操作不应该进行？  BD</p><ul><li><strong>B. 对变量进行百分位秩转换</strong> </li><li><strong>D. 对变量进行分箱处理</strong> </li></ul><hr><h3 id="9-回归模型"><a href="#9-回归模型" class="headerlink" title="9.回归模型"></a><strong>9.回归模型</strong></h3><p>1.有关回归模型的系数,以下<strong>说法错误的是</strong>哪个(  B )。</p><p>A. 一元线性回归模型的系数可以使用最小二乘法求得<br><strong>B. 多元回归模型的系数可以使用梯度下降法求得</strong><br>C. 一元线性回归模型的系数大小和正负说明自变量对因变量的相对影响大小<br>D. 回归分析的目的是计算回归方程的系数,使得样本的输入和输出变量之间的关系能够合理拟合</p><p>2.回归分析中按照自变量和因变量的关系类型可以分为？（ <strong>AB</strong> ） </p><ul><li><strong>A. 线性回归分析</strong></li><li><strong>B. 非线性回归分析</strong></li></ul><p>3.线性模型的优点包括？（  <strong>ABCD</strong> ） </p><ul><li><strong>A. 形式简单、易于建模</strong></li><li><strong>B. 可解释性</strong></li><li><strong>C. 引入层级结构或高维映射</strong></li><li><strong>D. 线性模型中系数直观表达了各属性在预测中的重要性</strong></li></ul><p>4.(单选题)<strong>线性判别分析</strong>是一种（ A）的方法。<strong>A.降维</strong></p><p>5.对于非线性回归问题,以下说法<strong>错误的</strong>是哪个(A )。</p><ul><li><strong>A. 可以分别求单个自变量与因变量的回归方程,然后简单求这些方程的加权和</strong></li><li>B. 非线性回归方程的系数需要把其转化为线性回归方程才方便求解</li><li>C. 非线性回归模型的检验也可以使用R2</li><li>D. Logistic回归是一种典型的广义线性回归模型</li></ul><hr><h3 id="10-支持向量机SVM"><a href="#10-支持向量机SVM" class="headerlink" title="10.支持向量机SVM"></a><strong>10.支持向量机SVM</strong></h3><p>1.<u>线性SVM和一般线性分类器的区别</u>主要是，<strong>是否确保间隔最大化</strong></p><p>2.在SVM领域中，margin的含义是，<strong>间隔</strong></p><p>3.为什么通常要选择margin最大的分类器， <strong>望获得较低的测试误差</strong></p><p><u>4.SVM本身是应用于二分类的</u>，若处理多分类必须进行改进。</p><p>若采用**”one vs all”<strong>解决5分类问题，</strong>需要设计（5）个分类器**。 </p><p>若采用**”one vs one”<strong>解决5分类问题</strong>，需要设计（10）个分类器。**</p><p>4.1<strong>选择Logistic回归</strong>中的<strong>One-Vs-All</strong>方法中的哪个选项是真实的。（n&gt;2）</p><ul><li><strong>A. 需要在n类分类问题中适合n个模型</strong></li></ul><p>5.假设超平面为w<em>x+b=0，其margin的大小为（ ）。*<em>2/|w|</em></em></p><p>6.<u>支持向量</u>（support vectors）指的是（ ）,<strong>决定分类面可以平移的范围的数据点</strong></p><p>7.<u>支持向量机SVM</u>是一种（    ）算法  <strong>小样本下的统计机器学习</strong></p><p>8.在SVM当中，主要的运算形式是（ ）。<strong>向量内积</strong></p><p>9.（  ）是定义在特征空间上的、间隔最大、<u>支持核技巧的分类器</u>。 <strong>SVM支持向量机</strong></p><p>10.对于SVM，<u>在映射后的高维空间直接进行计算的主要问题是</u>，<strong>计算复杂度高</strong></p><p>11.以下关于<u>SVM支持向量机</u>的说法正确的是 （  )。</p><ul><li><strong>C. SVM方法简单，鲁棒性较好</strong></li><li><strong>D. SVM分类面取决于支持向量</strong></li></ul><p>12.<u>支持向量机是一个分类器</u>，超平面上的数据是支持向量，超平面以外的数据可以辅助分类。<strong>错的</strong></p><hr><h3 id="11-K-Means-K均值算法"><a href="#11-K-Means-K均值算法" class="headerlink" title="11.K-Means(K均值算法)"></a><strong>11.K-Means(K均值算法)</strong></h3><p>1.为了在K均值算法中找到簇的最优值，可以使用 <strong>Elbow法</strong>，关注的就是方差百分比</p><p>2.K均值聚类时，<u>初始化不良会导致收敛速度差</u> <strong>A. 对</strong></p><p>3.<u>可以试着运行不同的质心初始化算法</u>，可以获得和全局最小值有关的K均值算法的良好结果。<strong>A. 对</strong></p><p>4.在对数据集执行K均值聚类分析以后，你得到了下面的树形图。从树形图中不能得出那些结论呢？（    ） </p><p><img src="https://p.ananas.chaoxing.com/star3/origin/688fdc316ba97d6a0ca155d7da81a06e.png" alt="img"> </p><ul><li>A. 在聚类分析中有28个数据点</li><li>B. 被分析的数据点里最佳聚类数是4</li><li>C. 使用的接近函数是平均链路聚类</li><li><strong>D. 对于上面树形图的解释不能用于K均值聚类分析</strong></li></ul><p>5.K-means算法的缺点有（  ABCD  ）</p><ul><li><strong>A. 只有当簇均值有定义的情况下，k均值方法才能使用。</strong></li><li><strong>B. 用户必须首先给定簇数目。</strong></li><li><strong>C. 不适合发现非凸形状的簇，或者大小差别很大的簇。</strong></li><li><strong>D. 对噪声和离群点数据敏感。</strong></li></ul><p>6.K-Means聚类算法可大致分为以下几个步骤，步骤中说法错误的是（ C）</p><ul><li>A. 任意选取两个点作为两个簇的初始中心；</li><li>B. 对剩余的每个对象，根据其与各个簇中心的距离，将它赋给最近的簇对；</li><li><strong>C. 继续使用上步获得的簇中心；</strong></li><li>D. 重新计算数据集中每个点到两个簇中心的距离，根据其值进行重新分配。</li></ul><p>7.<u>应用K均值算法之前，特征缩放是一个很重要的步骤</u>。这是为什么呢（  A   ） </p><ul><li><strong>A. 在距离计算中，它为所有特征赋予相同的权重。</strong></li></ul><hr><h2 id="二、填空计算题"><a href="#二、填空计算题" class="headerlink" title="二、填空计算题"></a>二、填空计算题</h2><h3 id="1-相似性计算"><a href="#1-相似性计算" class="headerlink" title="1.相似性计算"></a>1.相似性计算</h3><h4 id="1-二值离散型属性的相似性计算方法（计算样本间的距离）"><a href="#1-二值离散型属性的相似性计算方法（计算样本间的距离）" class="headerlink" title="(1) 二值离散型属性的相似性计算方法（计算样本间的距离）"></a>(1) 二值离散型属性的相似性计算方法（计算样本间的距离）</h4><ol><li><p>10维特征的二值离散型属性样本A,B分别为A=[1 0 0 0 0 0 0 0 0 0],B=[1 0 0 0 0 0 1 0 0 1],A,B 的相似性SMC = （     ）。JC=（       ）</p><p><strong>0.2，2/3</strong></p></li><li><p>10维特征的二值离散型属性样本A,B分别为A=[1 0 0 1 0 0 0 0 0 0],B=[1 0 0 0 0 0 1 0 0 1],A,B 的相似性SMC = （     ）。JC=（       ）</p><p><strong>0.3，0.75</strong></p></li></ol><p>总结，自己画矩阵图计算即可</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230530205142358.png" alt="image-20230530205142358" style="zoom:50%;" /><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230530204529248.png" alt="image-20230530204529248" style="zoom:40%;" /><p><strong>SMC</strong>，简单匹配系数，用于对<strong>对称的</strong>二值离散型属性的样本间距离的计算</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230530204828716.png" alt="image-20230530204828716" style="zoom: 45%;" /><p><strong>Jaccard</strong>系数，<strong>不对称的</strong>二值离散型属性的样本间的距离计算</p><hr><h4 id="2-多值离散型属性的相似性计算"><a href="#2-多值离散型属性的相似性计算" class="headerlink" title="(2) 多值离散型属性的相似性计算"></a>(2) 多值离散型属性的相似性计算</h4><p>已知样本如下。<strong>简单匹配法计算x1,x4的相似性</strong>。d(x1,x4)= (             )</p><p><img src="https://p.ananas.chaoxing.com/star3/origin/25250ad2a5a46d2d9b7957333f0cf52c.png" alt="img"></p><p>正确答案：<br>    (1) 1/3   看x1,x4这行，三个字段相同的值占(2/3) , 相似性为1-2/3==1/3</p><hr><h3 id="2-熵的计算"><a href="#2-熵的计算" class="headerlink" title="2.熵的计算"></a>2.熵的计算</h3><p>1.以下是目标变量在训练集上的 8 个实际值 [0,0,0,1,1,1,1,1]，<strong>目标变量的熵是？</strong>（   ） </p><p>A. -(5/8 log(5/8) + 3/8 log(3/8))</p><hr><h3 id="3-混淆矩阵的计算"><a href="#3-混淆矩阵的计算" class="headerlink" title="3.混淆矩阵的计算"></a>3.混淆矩阵的计算</h3><p><img src="https://p.ananas.chaoxing.com/star3/origin/bf1d46e5200ef467641431a7666f8aea.png" alt="img"></p><p>1.某分类器的混淆矩阵如上表，该分类器的<strong>误分率</strong>为 <strong>（FP+FN）主对角线</strong>,<strong>9%</strong></p><p>2.该分类器的<strong>查准率（Precision）</strong>为 ，<strong>P=TP/(TP+FP)<strong>，</strong>竖着看  30%</strong></p><p>3.该分类器的<strong>查全率</strong>（Recall）为，<strong>TP/(TP+FN) 查全率</strong>（召回率），<strong>横着看 60%</strong></p><hr><h3 id="4-K均值聚类方法"><a href="#4-K均值聚类方法" class="headerlink" title="4.K均值聚类方法"></a>4.K均值聚类方法</h3><p>1.假设你想用K均值聚类方法将7个观测值聚类到3个簇中，在第一次迭代簇之后，C1、C2、C3具有以下观测值： C1: {(2,2), (4,4), (6,6)} C2: {(0,4), (4,0)} C3: {(5,5), (9,9)} 在第二次迭代中，</p><p>01<strong>观测点（9，9）到集群质心C1的 Manhattan 距离是？A</strong></p><p><strong>C1:((2+4+6)/3, (2+4+6)/3)（4,4）和（9,9）的 Manhattan 距离是：（9-4）+（9-4）= 10。</strong></p><p>02如果继续进行第二次迭代，哪一个将成为集群的质心？A</p><ul><li><strong>A. C1: (4,4), C2: (2,2), C3: (7,7)</strong></li></ul><p>找到集群中数据点的质心 C1 = ((2+4+6)/3,(2+4+6)/3) = (4, 4)</p><p>找到集群中数据点的质心 C2 = ((0+4)/2, (4+0)/2) =(2, 2)</p><p>找到集群中数据点的质心 C3 = ((5+9)/2, (5+9)/2) =(7, 7)</p><p><strong>因此, C1: (4,4), C2: (2,2), C3: (7,7)</strong></p><hr><h3 id="5-分类器的正确率"><a href="#5-分类器的正确率" class="headerlink" title="5.分类器的正确率"></a>5.分类器的正确率</h3><p>1.设测试样本中，A类样本90个，B类样本10个。分类器C1将所有的测试样本都分成了A类。分类器C2将A类的90个样本分对了70个，将B类的样本分对了5个。C1的分类正确率为（　　），C2的分类正确率（    ）。（填写百分数形式，如：１０％）</p><p><strong>(1) ９０％    (2) ７５％</strong></p><p>C1的分类正确率为（　），正确的样本数/总样本数 —&gt;  90/100 == 90%</p><p>C2的分类正确率（    ）,  —&gt; (70+5)/100 == 75%</p><hr><h3 id="6-查准率、查全率计算"><a href="#6-查准率、查全率计算" class="headerlink" title="6.查准率、查全率计算"></a>6.查准率、查全率计算</h3><p>某局域网中有 A 类信息１４００条，B 类信息３００条，C 类信息３００条。科 技人员甲设计了搜索引擎，以搜索 A 类信息为目的，结果返回了 A 类信息７００条，B 类信 息２００条，C 类信息１００条。问该引擎的查准率为（ ），查全率为（ ）。 （填写百分数形式，如：１０％）</p><p><strong>70%，50%</strong></p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528175516024.png" alt="image-20230528175516024" style="zoom:50%;" /><p>该搜索引擎的**查准率 (竖着看)**为：70%（计算公式：查准率 = 检索到的相关信息数 / 检索到的全部信息数 × 100% = 700 / (700 + 200 + 100) × 100% = 70%）</p><p>该搜索引擎的**查全率 (横着看)**为：50%（计算公式：查全率 = 检索到的相关信息数 / 相关信息的总数 × 100% = 700 / 1400 × 100% = 50%）</p><hr><h2 id="三、重点大题"><a href="#三、重点大题" class="headerlink" title="三、重点大题"></a>三、重点大题</h2><h3 id="1-混淆矩阵"><a href="#1-混淆矩阵" class="headerlink" title="1.混淆矩阵"></a>1.混淆矩阵</h3><p><strong>题目</strong>：有20个样本，<strong>其中真实正例有10个，用p表示，负例有10个，用n表示</strong>。</p><p>Inst# 代表样本编号，Class代表样本真实的类别，Score表示利用模型得出每个测试样本<u>属于真实样</u></p><p><u>本的概率</u>。依次将Score概率从大到小排序，得到下表：</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528174013113.png" alt="image-20230528174013113"></p><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p><u>1.画出Score阈值为0.5时的混淆矩阵，计算此时的F1度量值。</u></p><p><strong>分析：</strong></p><p>（1）Score阈值为0.5时的混淆矩阵</p><p><strong>在左侧：分类器预测为正的情况， 相反右侧是分类器预测为负的情况</strong>，具体值在图中数即可</p><p>要知道混淆矩阵如何写，各个值对应的含义</p><p>TP: 分类器预测为正，真实为正</p><p>FP: 分类器预测为正，真实为负</p><p>FN:分类器预测为负，真实为正</p><p>TN:分类器预测为负，真实为负</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528174335722.png" alt="image-20230528174335722" style="zoom: 80%;" /><hr><p>（2）<strong>F1度量值</strong>，F1是准确率和召回率的调和平均。</p><p>具体推导，</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528175516024.png" alt="image-20230528175516024" style="zoom:50%;" /><p>计算F1记住公式即可，</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528180320715.png" alt="image-20230528180320715" style="zoom: 25%;" /><p>  计算， </p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528180217478.png" alt="image-20230528180217478" style="zoom:60%;" /><p><strong>拓展：</strong></p><p>1的另一种出题方式，<u>不给出具体概率的情况。</u></p><p>现有20个样本，包括10个正例（横着看，真实正例：TP+FN），10个负例。<strong>当阈值为0.5时，分类器预测正例为10只，其中将4个反例预测为正例。</strong></p><p>试求出该分类结果的混淆矩阵和F1值。</p><p>分析：</p><p><u>其中将4个反例预测为正例</u>：（由一个值推出其他三个值）</p><p>预测器为正，真实为负，及FP=4 —-&gt; 其他值</p><p>共有20个样本：TP+FP+TN+FN=20;</p><p>10个正例：TP+FN=10； 10个反例：FP+TN=10；</p><p>预测正例为10：TP+FP=10；预测反例为10：FN+TN=10；</p><p>4个反例预测为正例：FP=4</p><hr><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p><u>2.画出ROC 曲线。</u></p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528181537402.png" alt="image-20230528181537402" style="zoom:80%;" /><p>补充：</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528181828459.png" alt="image-20230528181828459" style="zoom: 67%;" /><p><strong>FP:预测为正，真实为负的数量，  TP:预测为正，真实为正的数量</strong></p><p>ROC 曲线的横坐标为FPR，纵坐标为TPR。</p><p>FPR是错误预测为正确的概率**(假正率)<strong>，TPR是正确预测为正确的概率</strong>(真正率)**。 每个点坐标（FPR, TPR）</p><hr><p>0.9&lt;阈值&lt;=1时，没有样本被预测为正例，所有样本被预测为反例。所以FP=0，TP=0，得ROC坐标**(0,0)**。</p><p>0.8&lt;阈值&lt;=9时，样本1预测为正例，其他样本被预测为反例。其中，样本1为真实正例，所以FP=0，TP=1，得ROC坐标(0,0),**(0,0.1)**。</p><p>0.7&lt;阈值&lt;=8时，样本1-2预测为正例。其中，样本1,2为真实正例，所以FP=0，TP=2，得ROC坐标(0,0),(0,0.1),(0,0.2)。</p><p>0.6&lt;阈值&lt;=7时，样本1-3预测为正例。其中，样本1,2为真实正例，样本3为真实反例，所以FP=1，TP=2，得ROC坐标(0,0),(0,0.1),(0,0.2),**(0.1,0.2)**。</p><p>0.55&lt;阈值&lt;=0.6时，样本1-4预测为正例。其中，样本1,2,4为真实正例，样本3为真实反例，所以FP=1，TP=3，得ROC坐标(0,0),(0,0.1),(0,0.2),(0.1,0.2),**(0.1,0.3)**。</p><p>……</p><p>具体计算图如下：</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528182846063.png" alt="image-20230528182846063"></p><p>结果：</p><p>ROC 曲线的<strong>横坐标为FPR，纵坐标为TPR</strong>。FPR是错误预测为正确的概率，TPR是正确预测为正确的概率。</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528183035478.png" alt="image-20230528183035478"></p><hr><h3 id="2-决策树"><a href="#2-决策树" class="headerlink" title="2.决策树"></a>2.决策树</h3><p>（使用信息增益的方法）</p><p><strong>题目：</strong></p><p>使用信息增益方法，计算下表中的决策树</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528183238910.png" alt="image-20230528183238910"></p><p>根据类别（是否）这一列来计算，</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528183445889.png" alt="image-20230528183445889"></p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528183533928.png" alt="image-20230528183533928"></p><p><strong>考试推荐写法</strong></p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528183635323.png" alt="image-20230528183635323"></p><p>其他特征信息增益，</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528183811110.png" alt="image-20230528183811110" style="zoom: 80%;" /><p>利用上述结果，由于特征A3（<strong>房子特征</strong>）的信息增益最大，<strong>所以选择特征A3作为根节点的特征</strong>。它将训练数据集D划分为<strong>两个子集D1（A3取值为“是”）</strong>和<strong>D2（A3取值为“否”）</strong>。</p><p><u>“房子特征=是”的样本都对应“类别=是”，达到终止条件</u>，只用计算D2这个分支即可</p><p>然后对D2从特征A1（年龄），特征A2（工作），特征A4（信贷情况）中选择新的特征，计算各个特征信息增益。</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528184644145.png" alt="image-20230528184644145"></p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528184913760.png" alt="image-20230528184913760"></p><p>利用上述结果，<strong>由于特征A2（工作特征）的信息增益最大</strong>，所以选择特征A2作为否分支的根节点。它将训练数据集D2划分为<strong>两个子集D21（A2取值为“是”）和D22（A2取值为“否”）</strong>。<u>且每个分支都只有一种结果，所以决策树划分完毕。</u></p><p> 可以画出决策树，</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528185023821.png" alt="image-20230528185023821"></p><hr><h3 id="3-核函数"><a href="#3-核函数" class="headerlink" title="3.核函数"></a>3.核函数</h3><p><strong>题目：</strong></p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528185158910.png" alt="image-20230528185158910"></p><p>带公式计算即可，</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528185223704.png"></p><hr><h3 id="4-SVM"><a href="#4-SVM" class="headerlink" title="4.SVM"></a>4.SVM</h3><p>支持向量机（SVM）的主要思想是<u>建立一个超平面作为决策曲面，使得正例和反例之间的隔离边缘被最大化。更精确说，支持向量机是结构风险最小化方法的近似实现。</u></p><p>题目：</p><p>带公式计算,</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230528185526468.png" alt="image-20230528185526468"></p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>练习题整理自学习通的练习题，及桂电的&lt;&lt;机器学习&gt;&gt;课程答疑资料。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;机器学习与数据挖掘-刷题练习-复习版&quot;&gt;&lt;a href=&quot;#机器学习与数据挖掘-刷题练习-复习版&quot; class=&quot;headerlink&quot; title=&quot;机器学习与数据挖掘 刷题练习(复习版)&quot;&gt;&lt;/a&gt;机器学习与数据挖掘 刷题练习(复习版)&lt;/h2&gt;&lt;p&gt;闲言碎语</summary>
      
    
    
    
    <category term="数据挖掘与机器学习" scheme="https://ariesfun.gitee.io/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习记录" scheme="https://ariesfun.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="机器学习与数据挖掘" scheme="https://ariesfun.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>23生产实习 大数据开发实训笔记合集 更新中...</title>
    <link href="https://ariesfun.gitee.io/posts/5544.html"/>
    <id>https://ariesfun.gitee.io/posts/5544.html</id>
    <published>2023-06-03T17:11:50.065Z</published>
    <updated>2023-08-27T04:29:33.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="23生产实习-大数据开发实训笔记合集-更新中…"><a href="#23生产实习-大数据开发实训笔记合集-更新中…" class="headerlink" title="23生产实习 大数据开发实训笔记合集 更新中…"></a>23生产实习 大数据开发实训笔记合集 更新中…</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>感谢学校为本专业开展了线下的实训机会，千锋教育的倪讲师也是保姆级别的哈哈，且行且珍惜。</p><p>老师会从环境搭建，到上手完成一个简单的基于亚马逊平台的推荐系统。</p><p>用到的开发框架涉及，Hadoop、Zookeeper、Flume、Kafka、Scala、HBase、Spark、Hive等。</p><p><a href="http://10.200.21.35:8100/s/WJhg">用到的软件资源</a>，注意本实训用到的软件资源文件只对校友开放，如有需要可以联系作者。</p><p><strong>特别鸣谢：</strong>提供上课笔记的<strong>小李同学(LHW)，小王同学(WQK)</strong> 。Respect！！</p><p><strong>笔记正在更新中，如有内容遗漏或错误欢迎随时指正，可在评论区互动交流~</strong></p><hr><h3 id="笔记合集"><a href="#笔记合集" class="headerlink" title="笔记合集"></a>笔记合集</h3><p>点击链接，即可跳转到对应文章</p><p><a href="https://ariesfun.gitee.io/posts/a63b.html">Day01(0529) Hadoop运行环境搭建及配置</a></p><p><a href="https://ariesfun.gitee.io/posts/3d5e.html">Day02(0530) Hadoop核心技术</a></p><p><a href="https://ariesfun.gitee.io/posts/dd24.html">Day03(0531) Zookeeper的安装方式</a></p><p><a href="https://ariesfun.gitee.io/posts/34c8.html">Day04(0601) HDFS的API及字符统计案例 (CharCount)</a></p><p>未完待续。。。</p><p>笔记基本整理完毕，后续考虑会完善放出来…</p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>笔记整理于千锋教育课堂讲义和代码，部分同学笔记及自己的小总结。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;23生产实习-大数据开发实训笔记合集-更新中…&quot;&gt;&lt;a href=&quot;#23生产实习-大数据开发实训笔记合集-更新中…&quot; class=&quot;headerlink&quot; title=&quot;23生产实习 大数据开发实训笔记合集 更新中…&quot;&gt;&lt;/a&gt;23生产实习 大数据开发实训笔记合</summary>
      
    
    
    
    <category term="大数据开发" scheme="https://ariesfun.gitee.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="学习记录" scheme="https://ariesfun.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="大数据框架" scheme="https://ariesfun.gitee.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Linux" scheme="https://ariesfun.gitee.io/tags/Linux/"/>
    
    <category term="Java" scheme="https://ariesfun.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>23生产实习 Day04(06/01) HDFS的API及字符统计案例 (CharCount)</title>
    <link href="https://ariesfun.gitee.io/posts/34c8.html"/>
    <id>https://ariesfun.gitee.io/posts/34c8.html</id>
    <published>2023-06-03T17:11:46.692Z</published>
    <updated>2023-06-03T17:34:39.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day04-06-01-HDFS的API及字符统计案例-CharCount"><a href="#Day04-06-01-HDFS的API及字符统计案例-CharCount" class="headerlink" title="Day04(06/01) HDFS的API及字符统计案例 (CharCount)"></a>Day04(06/01) HDFS的API及字符统计案例 (CharCount)</h2><p><strong><a href="https://ariesfun.gitee.io/posts/5544.html">查看笔记合集</a></strong></p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h4 id="1-先开启Zookeeper服务"><a href="#1-先开启Zookeeper服务" class="headerlink" title="1.先开启Zookeeper服务"></a>1.先开启Zookeeper服务</h4><p>需要先开启3台虚拟机上的Zookeeper服务和Hadoop服务,你也可使用自动化脚本来执行此操作。</p><p>使用远程连接工具，连接到三台虚拟主机，<strong>先开启Zookeeper服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下命令需要在三台主机上同时执行</span></span><br><span class="line"></span><br><span class="line">cd /home/software/zookeeper-3.4.7/bin/ # 进入bin目录，运行里面的脚本文件</span><br><span class="line">sh zkServer.sh start # 开启zookeeper</span><br><span class="line">sh zkServer.sh status # 查看运行状态</span><br></pre></td></tr></table></figure><p><strong>若出现的Mode里，共有两个<code>follower</code>，一个<code>leader</code>，则说明服务是正常启动的。</strong></p><hr><h4 id="2-在第一个节点上，启动Hadoop服务"><a href="#2-在第一个节点上，启动Hadoop服务" class="headerlink" title="2.在第一个节点上，启动Hadoop服务"></a>2.在第一个节点上，启动Hadoop服务</h4><p><code>start-all.sh </code></p><p><strong>启动成功后，在三台主机上输入<code>jps</code>命令查看运行进行（BigData01，02，03对应的正确进程数应是8，7，6）。</strong></p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306022146489.png" alt="image-20230602214656983" style="zoom: 50%;" /><p>若进程数不够需要单独在该结点上进行相应配置，参照下图来启动相应的结点。</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306022145996.png" alt="image-20230602214548554"></p><hr><h4 id="3-编写Zookeeper启动脚本"><a href="#3-编写Zookeeper启动脚本" class="headerlink" title="3.编写Zookeeper启动脚本"></a>3.编写Zookeeper启动脚本</h4><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306040117010.png" alt="image-20230603212105722" style="zoom:50%;" /><p>在Linux本地创建 <code>zkServer</code> 文件夹，并编写脚本内容,</p><p>(便于同时启动三个节点上的Zookeeper服务，或者查看状态、关闭)</p><p><code>vim zk_start.sh</code>，完成后保存并退出</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032125134.png" alt="image-20230603212549972"></p><hr><p>复制出来，编写一个查看Zookeeper运行状态的脚本文件，</p><p><code>vim zk_start.sh</code> ，完成后保存并退出</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032128780.png" alt="img-202306032128780"></p><hr><p>进行脚本测试，下次启动Zookeeper就可以在只在一个节点执行脚本文件了，比较方便。</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032131492.png" alt="img-202306032131492" style="zoom: 80%;" /><h4 id="4-该案例会用到IDE工具-IDEA"><a href="#4-该案例会用到IDE工具-IDEA" class="headerlink" title="4.该案例会用到IDE工具:IDEA"></a>4.该案例会用到IDE工具:<code>IDEA</code></h4><p>确保你的IDEA可以正常的创建JAVA项目，并且可以运行成功（已经配置好jdk1.8环境）</p><h3 id="一、HDFS的API编写"><a href="#一、HDFS的API编写" class="headerlink" title="一、HDFS的API编写"></a>一、HDFS的API编写</h3><p>打开IDEA，之前需要启动Zookeeper服务和Hadoop服务。</p><p>用IDEA新建一个<strong>Maven</strong>项目,</p><p><strong>用于在本地Windows环境上与HDFS文件系统进行交互。</strong></p><hr><h4 id="0-配置Maven环境依赖"><a href="#0-配置Maven环境依赖" class="headerlink" title="(0)配置Maven环境依赖"></a>(0)配置Maven环境依赖</h4><p>新建一个<code>HDFS-Demo</code>，保证是<strong>Maven项目</strong></p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032135410.png" alt="img-202306032135410" style="zoom: 67%;" /><p>右键选择<code>quickstart</code>骨架，进行下一步创建。</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032138523.png" alt="img-202306032138523" style="zoom:80%;" /><hr><p>打开IDEA的设置界面，配置Maven的本地路径，(将<code>maven3.6.zip</code>压缩包解压到指定的文件路径下)</p><p>更改Maven的本地安装包路径，</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032142076.png" alt="img-202306032142076" style="zoom:80%;" /><p>编辑，<code>pom.xml</code>文件，添加以下依赖包文件，</p><p>然后点击刷新按钮，等待下载这些依赖文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-hdfs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032148563.png" alt="image-20230603214833970"></p><p>依赖下载完成后，我们就可以正式进入代码编写的环节了。</p><p>新建一个<code>HDFSDemo.java</code>文件，分别编写以下测试集代码，</p><h4 id="1-上传功能"><a href="#1-上传功能" class="headerlink" title="(1)上传功能"></a>(1)上传功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上传</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// Configuration代表的是环境配置</span></span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码中的配置要优先于配置文件中的内容</span></span><br><span class="line">    conf.set(<span class="string">&quot;dfs.replication&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接HDFS</span></span><br><span class="line">    <span class="type">FileSystem</span> <span class="variable">fs</span> <span class="operator">=</span>FileSystem.get(URI.create(<span class="string">&quot;hdfs://这里填写自己结点状态的为Active的IP:9000&quot;</span>),conf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出流是写，指定HDFS上的存储路径</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> fs.create(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/demo.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定要上传的文件</span></span><br><span class="line">    FileInputStream in=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\demo.txt&quot;</span>); <span class="comment">// 确保本地有这个文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件然后利用输出流往HDFS上写数据</span></span><br><span class="line">    IOUtils.copyBytes(in,out,conf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关流用于释放资源</span></span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2-下载功能"><a href="#2-下载功能" class="headerlink" title="(2)下载功能"></a>(2)下载功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下载</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// Configuration代表的是环境配置</span></span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码中的配置要优先于配置文件中的内容</span></span><br><span class="line">    conf.set(<span class="string">&quot;dfs.replication&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接HDFS</span></span><br><span class="line">    <span class="type">FileSystem</span> <span class="variable">fs</span> <span class="operator">=</span> FileSystem.get(URI.create(<span class="string">&quot;hdfs://XX.XX.XX.XX:9000&quot;</span>), conf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定输入流去读取HDFS上的数据</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> fs.open(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/demo.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件出书流</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/a.txt&quot;</span>);</span><br><span class="line">    IOUtils.copyBytes(in,out,conf);</span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-删除功能"><a href="#3-删除功能" class="headerlink" title="(3)删除功能"></a>(3)删除功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// Configuration代表的是环境配置</span></span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码中的配置要优先于配置文件中的内容</span></span><br><span class="line">    conf.set(<span class="string">&quot;dfs.replication&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接HDFS</span></span><br><span class="line">    <span class="type">FileSystem</span> <span class="variable">fs</span> <span class="operator">=</span> FileSystem.get(URI.create(<span class="string">&quot;hdfs:XX.XX.XX.XX:9000&quot;</span>), conf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定输入流去读取HDFS上的数据</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> fs.open(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/demo.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">    fs.delete(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/demo.txt&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单独运行某个测试类，退出码为<code>exit code 0</code>说明运行成功，</p><p>然后打开浏览器来查看相应操作是否执行成功</p><hr><h3 id="二、MapReduce技术细节"><a href="#二、MapReduce技术细节" class="headerlink" title="二、MapReduce技术细节"></a>二、MapReduce技术细节</h3><p>1.MapReduce是Hadoop提供的一套用于进行<strong>分布式计算的框架</strong> </p><p>2.MapReduce是将整个计算过程拆分为两个阶段</p><p><strong>Map(映射)阶段 和 Reduce(规约)阶段</strong></p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306040002563.png" alt="image-20230604000205861"></p><p>3.因为Hadoop对windows系统的兼容性极差,需要进行环境配置</p><hr><h3 id="三、编写字符统计案例"><a href="#三、编写字符统计案例" class="headerlink" title="三、编写字符统计案例"></a>三、编写字符统计案例</h3><p>新建一个MapReduceDemo的<strong>Maven项目</strong>(使用quickstart骨架)，并将前一个项目的<code>pom.xml</code>的依赖配置</p><p>复制过来，刷新Maven配置。</p><h4 id="1-代码编写"><a href="#1-代码编写" class="headerlink" title="1.代码编写"></a>1.代码编写</h4><p>在<code>charcount</code>包下，编写以下三个类</p><p><strong>(1).编写MapReduce程序的驱动类，<code>CharcountDriver.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写MapReduce程序的驱动类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharcountDriver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 环境参数</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向Yarn申请JOB任务</span></span><br><span class="line">        <span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> Job.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置入口类</span></span><br><span class="line">        job.setJarByClass(CharcountDriver.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置Mapper类</span></span><br><span class="line">        job.setMapperClass(CharcountMapper.class);</span><br><span class="line">        <span class="comment">// 设置Rudecer类</span></span><br><span class="line">        job.setReducerClass(CharcountReducer.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定Mapper的输出类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定Reducer的输出类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置输入路径</span></span><br><span class="line">        FileInputFormat.addInputPath(job,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;hdfs://这里填写自己结点状态的为Active的IP:9000/words.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置输出路径</span></span><br><span class="line">        <span class="comment">// 注意需要保证，下面的输出目录必须是不存在的，这步会创建一个指定的输出路径</span></span><br><span class="line">        FileOutputFormat.setOutputPath(job,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;hdfs://xx.xx.xx.xx:9000/result/wordcount&quot;</span>));</span><br><span class="line">        <span class="comment">// 提交Job任务</span></span><br><span class="line">        job.waitForCompletion(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>(2).编写Mapper类，<code>CharcountMapper.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在MapReduce程序中要求所有的数据都能够被序列化：</span></span><br><span class="line"><span class="comment">// KEYIN, --- 输入的键的类型，如果不指定则默认是行的字节偏移量</span></span><br><span class="line"><span class="comment">// VALUEIN, --- 输入的值的类型，如果不指定则默认就是读取回来的一行数据</span></span><br><span class="line"><span class="comment">// KEYOUT, --- 输出的键的类型，当前案例中输出的字符</span></span><br><span class="line"><span class="comment">// VALUEOUT, --- 输出的值的类型，当前案例中输出的次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharcountMapper</span> <span class="keyword">extends</span> <span class="title class_">Mapper</span> &lt;LongWritable, Text,Text, IntWritable&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key:键，实际上就是一行的偏移量</span></span><br><span class="line">    <span class="comment">// value:值，实际上就是读取的一行的数据</span></span><br><span class="line">    <span class="comment">// context: 利用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 统计字符</span></span><br><span class="line">        <span class="comment">// 首先将这一行中的数据读取出来进行拆分</span></span><br><span class="line">        <span class="type">char</span>[] cs=value.toString().toCharArray();</span><br><span class="line">        <span class="comment">// hello:&#123;h,e,l,l,o&#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : cs)&#123;</span><br><span class="line">            context.write(<span class="keyword">new</span> <span class="title class_">Text</span>(c+<span class="string">&quot;&quot;</span>),<span class="keyword">new</span> <span class="title class_">IntWritable</span>(<span class="number">1</span>));   <span class="comment">// Map端的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>(3).编写Reducer类，<code>CharcountReducer.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KEYIN, VALUEIN,--- 输入的键值类型，Reducer的数据来自于Map</span></span><br><span class="line"><span class="comment">// 那么也就意味着Map的输出就是Reduce阶段的输入</span></span><br><span class="line"><span class="comment">// KEYOUT, ALUEOUT --- 输出的键值类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// key，输入的键</span></span><br><span class="line"><span class="comment">// values: 输入的值，这个值已经经过分组，</span></span><br><span class="line"><span class="comment">// context:利用这个参数将数据传递给HDFS上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharcountReducer</span> <span class="keyword">extends</span> <span class="title class_">Reducer</span> &lt;Text, IntWritable, Text, IntWritable&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符统计</span></span><br><span class="line">        <span class="comment">//        // key:&#x27;a&#x27;</span></span><br><span class="line">        <span class="comment">// values:&#123;1,1,1,1,1,1,1....&#125;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">            sum += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(key, <span class="keyword">new</span> <span class="title class_">IntWritable</span>(sum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2-Windows上的Hadoop环境配置"><a href="#2-Windows上的Hadoop环境配置" class="headerlink" title="2.Windows上的Hadoop环境配置"></a>2.Windows上的Hadoop环境配置</h4><p>进行系统环境变量配置：</p><p>需要在Windows平台上，解压Hadoop安装包文件</p><p>在系统变量中需要添加以下信息，</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032345308.png" alt="img-202306032345308" style="zoom:50%;" /><p>在Path里添加一个bin目录，</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032345272.png" alt="img-202306032345272" style="zoom:50%;" /><p>下载hadoopbin压缩包，放到hadoop-2.7.6的bin目录下，并解压到此文件夹下。</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032345452.png" alt="img-202306032345452"></p><p>双击exe文件：打开是一闪而过的，说明环境配置是正常的。</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032346691.png" alt="img-202306032346691" style="zoom:67%;" /><hr><h4 id="3-查看字符统计结果"><a href="#3-查看字符统计结果" class="headerlink" title="3.查看字符统计结果"></a>3.查看字符统计结果</h4><p>运行<code>CharcountDriver.java</code>程序，运行成功返回的退出码应为<code>exit code 0</code>。</p><p>若出现报错查看报错信息，下面的意思是说，该节点是<code>stanby</code>节点，需要将代码里的IP改为活跃节点的IP。</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306031123494.png" alt="image-20230603112347720"></p><hr><p>接着打开浏览器，查看字符统计结果。</p><p>进入节点状态的为<code>Active</code>的文件系统的网页，查看<code>/result/charcount</code>目录下是否有以下两个文件。</p><p>可以看到下面的两个文件，说明我们的CharCount程序运行成功，并返回了结果文件<code> part-r-00000</code>。</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306022111234.jpg" alt="img-202306022111234"></p><p>在对应的结点的终端里，使用HDFS命令将统计的结果文件下载到Linux环境本地，来查看字符统计结果，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[root@qianfeng02 ~]# hadoop fs -get /result/charcount/part-r-00000</span><br><span class="line">[root@qianfeng02 ~]# cat part-r-00000</span><br><span class="line">        1430</span><br><span class="line">!       3</span><br><span class="line">&quot;       6</span><br><span class="line">&#x27;       7</span><br><span class="line">,       59</span><br><span class="line">-       2</span><br><span class="line">.       66</span><br><span class="line">:       1</span><br><span class="line">;       1</span><br><span class="line">?       1</span><br><span class="line">A       20</span><br><span class="line">B       3</span><br><span class="line">C       3</span><br><span class="line">D       1</span><br><span class="line">E       1</span><br><span class="line">F       1</span><br><span class="line">G       5</span><br><span class="line">I       23</span><br><span class="line">L       5</span><br><span class="line">M       4</span><br><span class="line">N       21</span><br><span class="line">O       3</span><br><span class="line">P       2</span><br><span class="line">S       4</span><br><span class="line">T       11</span><br><span class="line">W       15</span><br><span class="line">Y       2</span><br><span class="line">a       480</span><br><span class="line">b       99</span><br><span class="line">c       164</span><br><span class="line">d       226</span><br><span class="line">e       760</span><br><span class="line">f       180</span><br><span class="line">g       137</span><br><span class="line">h       348</span><br><span class="line">i       476</span><br><span class="line">j       19</span><br><span class="line">k       46</span><br><span class="line">l       282</span><br><span class="line">m       148</span><br><span class="line">n       388</span><br><span class="line">o       520</span><br><span class="line">p       77</span><br><span class="line">q       6</span><br><span class="line">r       343</span><br><span class="line">s       370</span><br><span class="line">t       588</span><br><span class="line">u       163</span><br><span class="line">v       71</span><br><span class="line">w       132</span><br><span class="line">x       5</span><br><span class="line">y       109</span><br><span class="line">z       6</span><br><span class="line">[root@qianfeng02 ~]#</span><br></pre></td></tr></table></figure><p>到这一步说明你的程序和环境都没毛病，哈哈继续加油！</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day04-06-01-HDFS的API及字符统计案例-CharCount&quot;&gt;&lt;a href=&quot;#Day04-06-01-HDFS的API及字符统计案例-CharCount&quot; class=&quot;headerlink&quot; title=&quot;Day04(06/01) HDFS的</summary>
      
    
    
    
    <category term="大数据开发" scheme="https://ariesfun.gitee.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="学习记录" scheme="https://ariesfun.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="大数据框架" scheme="https://ariesfun.gitee.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Linux" scheme="https://ariesfun.gitee.io/tags/Linux/"/>
    
    <category term="Java" scheme="https://ariesfun.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>23生产实习 Day03(05/31) Zookeeper的安装方式</title>
    <link href="https://ariesfun.gitee.io/posts/dd24.html"/>
    <id>https://ariesfun.gitee.io/posts/dd24.html</id>
    <published>2023-06-03T17:11:42.895Z</published>
    <updated>2023-06-03T17:31:25.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day03-05-31-Zookeeper的安装方式"><a href="#Day03-05-31-Zookeeper的安装方式" class="headerlink" title="Day03(05/31) Zookeeper的安装方式"></a>Day03(05/31) Zookeeper的安装方式</h2><p><strong><a href="https://ariesfun.gitee.io/posts/5544.html">查看笔记合集</a></strong></p><h3 id="一、单机模式"><a href="#一、单机模式" class="headerlink" title="一、单机模式"></a>一、单机模式</h3><p>以下操作在第一个节点上进行。</p><h4 id="1-关闭防火墙"><a href="#1-关闭防火墙" class="headerlink" title="1.关闭防火墙"></a>1.关闭防火墙</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop firewalld # 临时关闭</span><br><span class="line">sudo systemctl disable firewalld # 永久关闭</span><br></pre></td></tr></table></figure><hr><h4 id="2-解压Zookeeper的安装包并进入conf目录"><a href="#2-解压Zookeeper的安装包并进入conf目录" class="headerlink" title="2.解压Zookeeper的安装包并进入conf目录"></a>2.解压Zookeeper的安装包并进入conf目录</h4><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032018191.png" alt="img-202306032018191" style="zoom:80%;" /><p>需要将Zookeeper安装包上传至第一个节点Linux本地，并进行解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf zookeeoer-3.4.7.tar.gz -C /home/software/</span><br><span class="line">cd /home/software/zookeeper-3.4.7/conf/</span><br></pre></td></tr></table></figure><hr><h4 id="3-将模板文件复制并重命名"><a href="#3-将模板文件复制并重命名" class="headerlink" title="3.将模板文件复制并重命名"></a>3.将模板文件复制并重命名</h4><p><code>cp zoo_sample.cfg zoo.cfg</code></p><hr><h4 id="4-编辑文件将dataDir属性进行配置"><a href="#4-编辑文件将dataDir属性进行配置" class="headerlink" title="4.编辑文件将dataDir属性进行配置"></a>4.编辑文件将dataDir属性进行配置</h4><p><code>vim zoo.cfg</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/home/software/zookeeper-3.4.7/tmp</span><br></pre></td></tr></table></figure><hr><h4 id="5-进入bin目录并启动Zookeeper"><a href="#5-进入bin目录并启动Zookeeper" class="headerlink" title="5.进入bin目录并启动Zookeeper"></a>5.进入bin目录并启动Zookeeper</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/software/zookeeper-3.4.7/bin</span><br><span class="line">sh zkServer.sh start</span><br></pre></td></tr></table></figure><hr><h4 id="6-成功启动后，查看运行状态"><a href="#6-成功启动后，查看运行状态" class="headerlink" title="6.成功启动后，查看运行状态"></a>6.成功启动后，查看运行状态</h4><p><code>sh zkServer.sh status</code></p><p>单机模式的状态:<strong>standalone</strong></p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032022362.png" alt="img-202306032022362" style="zoom:80%;" /><p><strong>到这说明，Zookeeper单机模式安装成功。</strong></p><p><strong>！！！切记下一步需要关闭单机模式</strong></p><p><code>sh zkServer.sh stop</code></p><hr><h4 id="7-远程拷贝Zookeeper文件给其他节点"><a href="#7-远程拷贝Zookeeper文件给其他节点" class="headerlink" title="7.远程拷贝Zookeeper文件给其他节点"></a>7.远程拷贝Zookeeper文件给其他节点</h4><p>进入<code>/home/software/</code>目录，</p><p>将当前节点Zookeeper文件夹拷贝给其他节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ../../ </span><br><span class="line">scp -r zookeeper-3.4.7/ root@qianfeng02:/home/software/ </span><br><span class="line">scp -r zookeeper-3.4.7/ root@qianfeng02:/home/software/</span><br></pre></td></tr></table></figure><p>方便为下面的完全分布式安装做准备。</p><hr><h3 id="二、完全分布式"><a href="#二、完全分布式" class="headerlink" title="二、完全分布式"></a>二、完全分布式</h3><p><strong>三节点需要联动</strong>进行下面的操作，使用MobaXterm工具。</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032032644.png" alt="img-202306032032644.png" style="zoom:80%;" /><h4 id="1-关闭防火墙-1"><a href="#1-关闭防火墙-1" class="headerlink" title="1.关闭防火墙"></a>1.关闭防火墙</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop firewalld # 临时关闭</span><br><span class="line">sudo systemctl disable firewalld # 永久关闭</span><br></pre></td></tr></table></figure><hr><h4 id="2-解压Zookeeper的安装包进入conf目录"><a href="#2-解压Zookeeper的安装包进入conf目录" class="headerlink" title="2.解压Zookeeper的安装包进入conf目录"></a>2.解压Zookeeper的安装包进入conf目录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/software/zookeeper-3.4.7/conf/</span><br></pre></td></tr></table></figure><hr><h4 id="3-将模板文件复制一份并且重命名"><a href="#3-将模板文件复制一份并且重命名" class="headerlink" title="3.将模板文件复制一份并且重命名"></a>3.将模板文件复制一份并且重命名</h4><p><code>cp zoo_sample.cfg zoo.cfg</code></p><hr><h4 id="4-编辑文件将dataDir属性进行配置-1"><a href="#4-编辑文件将dataDir属性进行配置-1" class="headerlink" title="4.编辑文件将dataDir属性进行配置"></a>4.编辑文件将dataDir属性进行配置</h4><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032035607.png" alt="img-202306032035607" style="zoom: 50%;" /><p><code>vim zoo.cfg</code></p><p>添加以下配置信息后，保存并退出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/home/software/zookeeper-3.4.7/tmp</span><br><span class="line">server.1=xx.xx.xx.xx:2888:3888</span><br><span class="line">server.2=xx.xx.xx.xx:2888:3888</span><br><span class="line">server.3=xx.xx.xx.xx:2888:3888</span><br></pre></td></tr></table></figure><hr><h4 id="5-进入tmp目录编辑myid文件"><a href="#5-进入tmp目录编辑myid文件" class="headerlink" title="5.进入tmp目录编辑myid文件"></a>5.进入tmp目录编辑myid文件</h4><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032039453.png" alt="image-20230603203951597"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/software/zookeeper-3.4.7/tmp/</span><br><span class="line">rm -rf vesion-2/ # 删除version-2文件，保证tmp文件夹为空</span><br></pre></td></tr></table></figure><p><code>vim myid</code> 然后编辑myid文件</p><p>在文件中添加当前节点的编号，三个节点需要同时操作</p><p>编号对应的就是server后面的数字,三个节点分别改为1，2，3（与各自节点IP要对应）</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032043460.png" alt="img-202306032043460" style="zoom: 50%;" /><hr><h4 id="6-三个节点都需要进入bin目录，启动Zookeeper"><a href="#6-三个节点都需要进入bin目录，启动Zookeeper" class="headerlink" title="6.三个节点都需要进入bin目录，启动Zookeeper"></a>6.三个节点都需要进入bin目录，启动Zookeeper</h4><p><code>sh zkServer.sh start</code></p><hr><h4 id="7-三个节点都需要查询状态"><a href="#7-三个节点都需要查询状态" class="headerlink" title="7.三个节点都需要查询状态"></a>7.三个节点都需要查询状态</h4><p><code>sh zkServer.sh status</code></p><p><strong>若出现2个follower和1个leader说明完全分布式启动成功</strong>。</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306031302630.png" alt="image-20230603130214328"></p><hr><h4 id="8-Zookeeper集群启动及格式化"><a href="#8-Zookeeper集群启动及格式化" class="headerlink" title="8.Zookeeper集群启动及格式化"></a>8.Zookeeper集群启动及格式化</h4><p><code>cd /home/software/zookeeper-3.4.7/bin</code></p><p><strong>(1).在第一个节点上，格式化Zookeeper</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs zkfc -formatZK</span><br></pre></td></tr></table></figure><p>执行后出现成功创建，说明格式化成功。</p><p><strong>如果没有，噩梦开始。</strong></p><p>你需要检查你的Hadoop和Zookeeper配置信息是否有误。</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306031310187.png" alt="image-20230603131003772"></p><hr><p><strong>(2).接着在三个节点上启动JournalNode</strong></p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032047071.png" alt="image-20230603204715878"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop-daemen.sh start journalnode</span><br></pre></td></tr></table></figure><hr><p><strong>(3).第一个节点上，格式化NameNode</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop namenode -format</span><br></pre></td></tr></table></figure><p>若出现以下提示，说明NameNode格式化成功。</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032052361.png" alt="image-20230603205221035"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23/06/01 11:22:00 INFO common.Storage: Storage directory /home/software/hadoop-2.7.6/tmp/hdfs/name has been successfully formatted.</span><br></pre></td></tr></table></figure><p>如果不能格式化成功，可以参考<a href="https://www.cnblogs.com/c-w20140301/p/10469315.html">解决namenode格式化时报错</a>。</p><hr><p><strong>(4).在第一个节点上启动NameNode</strong></p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032055407.png" alt="img-202306032055407"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop-daemen.sh start namenode</span><br></pre></td></tr></table></figure><hr><p><strong>(5).第二个节点上进行格式化</strong></p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306032055926.png" alt="img-202306032055926"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hadoop namenode -bootstrapStandby</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看是否出现下面的提示信息</span></span><br><span class="line">23/06/01 11:34:37 INFO common.Storage: Storage directory /home/software/hadoop-2.7.6/tmp/hdfs/name has been successfully formatted.</span><br></pre></td></tr></table></figure><hr><p><strong>(6).在三个节点上同时执行以下命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop-deamen.sh start namenode # 启动NameNode</span><br><span class="line">hadoop-deamen.sh start datanode # 启动DataNode</span><br></pre></td></tr></table></figure><hr><p><strong>(7).在第一、三节点上分别执行以下命令</strong></p><p>在第三个节点，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-yearn.sh</span><br></pre></td></tr></table></figure><p>在第一个节点，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn-dameon.sh start resourcemanager</span><br></pre></td></tr></table></figure><hr><p><strong>(8).检查三个节点的进程数量</strong></p><p>在三个节点都输入<code>jps</code></p><p><strong>查看进程数量，正确应该是8，7，6</strong></p><p>到此，完全分布式的Zookeeper安装完毕~~</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day03-05-31-Zookeeper的安装方式&quot;&gt;&lt;a href=&quot;#Day03-05-31-Zookeeper的安装方式&quot; class=&quot;headerlink&quot; title=&quot;Day03(05/31) Zookeeper的安装方式&quot;&gt;&lt;/a&gt;Day03(0</summary>
      
    
    
    
    <category term="大数据开发" scheme="https://ariesfun.gitee.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="学习记录" scheme="https://ariesfun.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="大数据框架" scheme="https://ariesfun.gitee.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Linux" scheme="https://ariesfun.gitee.io/tags/Linux/"/>
    
    <category term="Java" scheme="https://ariesfun.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>23生产实习 Day02(05/30) Hadoop核心技术</title>
    <link href="https://ariesfun.gitee.io/posts/3d5e.html"/>
    <id>https://ariesfun.gitee.io/posts/3d5e.html</id>
    <published>2023-06-03T17:11:39.424Z</published>
    <updated>2023-06-03T17:27:17.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day02-05-30-Hadoop核心技术"><a href="#Day02-05-30-Hadoop核心技术" class="headerlink" title="Day02(05/30) Hadoop核心技术"></a>Day02(05/30) Hadoop核心技术</h2><p><strong><a href="https://ariesfun.gitee.io/posts/5544.html">查看笔记合集</a></strong></p><h2 id="一、Hadoop伪分布式集群配置及功能测试"><a href="#一、Hadoop伪分布式集群配置及功能测试" class="headerlink" title="一、Hadoop伪分布式集群配置及功能测试"></a>一、Hadoop伪分布式集群配置及功能测试</h2><h3 id="0-Hadoop运行环境配置"><a href="#0-Hadoop运行环境配置" class="headerlink" title="0.Hadoop运行环境配置"></a>0.Hadoop运行环境配置</h3><p>先进入hadoop文件夹进行配置 <code>cd /home/software/hadoop-2.7.6/etc/hadoop/</code></p><p><strong>(1).<code>vim mapred-site.xml</code></strong><br>ps: 前一步要复制一份<code>.xml</code>文件 <code>cp mapred-site.xml.template mapred-site.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定Mapreduce程序在Yarn上运行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p><strong>(2).<code>vim yarn-site.xml</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 指定Yarn的主节点 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>qianfeng01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- NodeManager数据获取方式 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p><strong>(3).<code>vim slaves</code></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qianfeng01 # 添加从节点信息</span><br></pre></td></tr></table></figure><hr><p><strong>(4).<code>vim /etc/profile</code> 配置Hadoop环境变量</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/home/software/jdk1.8</span><br><span class="line">export HADOOP_HOME=/home/software/hadoop-2.7.6</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br><span class="line">export JAVA_HOME PATH</span><br></pre></td></tr></table></figure><p><strong>(5).<code>source /etc/profile</code> # 刷新环境变量</strong></p><p><code>hadoop version</code> # 查看Hadoop版本号</p><p>可以正确看到Hadoop版本说明，环境变量配置正确。</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306040010090.png" alt="img-202306040010090"></p><hr><p><strong>(5).<code>hadoop namenode -format </code> 格式化namenode</strong></p><p>运行内容中出现以下这行，说明格式化成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23/05/30 09:15:33 INFO common.Storage: Storage directory /tmp/hadoop-root/dfs/name has been successfully formatted.</span><br></pre></td></tr></table></figure><hr><p><strong>(6).<code>start-all.sh</code>  启动Hadoop服务</strong></p><hr><p><strong>(7).输入<code>jps</code> 查看运行的进程（应有如下6个）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@qianfeng01 hadoop]# jps</span><br><span class="line">6433 NameNode</span><br><span class="line">7043 NodeManager</span><br><span class="line">6933 ResourceManager</span><br><span class="line">6550 DataNode</span><br><span class="line">6780 SecondaryNameNode</span><br><span class="line">7375 Jps</span><br></pre></td></tr></table></figure><hr><p><strong>(8).打开浏览器，输入<code>自己的ip:50070</code> 查看HadoopWeb文件系统页面</strong></p><p> 网页可以正常打开，说明Hadoop伪分布式环境搭建完成~~</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202305301032378.png" alt="image-20230530095757160"></p><hr><h3 id="1-HDFS常用命令"><a href="#1-HDFS常用命令" class="headerlink" title="1.HDFS常用命令"></a>1.HDFS常用命令</h3><table><thead><tr><th align="left">常用命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">hadoop fs <strong>-put</strong> xxx.txt  /</td><td align="left">上传xxx文件到hdfs的根目录下</td></tr><tr><td align="left">hadoop fs <strong>-get</strong> /xxx.txt /xxx.txt</td><td align="left">下载xxx文件到Linux本地并重命名</td></tr><tr><td align="left">hadoop fs <strong>-rm</strong> /xxx.txt</td><td align="left">删除hdfs根目录下的文件</td></tr><tr><td align="left">hadoop fs <strong>-rmdir</strong> /xxx</td><td align="left">删除<strong>空文件夹</strong></td></tr><tr><td align="left">hadoop fs <strong>-rmr</strong> /xxx</td><td align="left"><strong>递归删除</strong>文件夹</td></tr><tr><td align="left">hadoop fs <strong>-ls</strong> /</td><td align="left">查看hdfs根目录下的所有文件</td></tr><tr><td align="left">hadoop fs <strong>-cp</strong> /xxx.txt /xxx.txt</td><td align="left">将hdfs根目录下的xxx文件复制并重命名为xxx</td></tr><tr><td align="left">hadoop fs <strong>-mv</strong> /xxx.txt /xxx.txt</td><td align="left">将hdfs根目录下的xxx文件重命名为xxx</td></tr><tr><td align="left">hadoop fs -mv /xxx.txt /xxx/</td><td align="left">将hdfs根目录下的xxx文件移动到指定文件夹xxx下</td></tr><tr><td align="left">hadoop fs <strong>-mkdir</strong> /xxx</td><td align="left">在hdfs根目录下创建文件夹xxx</td></tr></tbody></table><hr><p>eg.在Linux本地环境创建<code>hello.txt</code>，与HDFS进行文件交互</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/data/ </span><br><span class="line">vim hello.txt # 创建hello.txt并编辑</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -put hello.txt  / # 上传文件到hdfs的根目录下</span><br><span class="line">mv hello.txt world.txt # 重命名文件夹</span><br><span class="line"></span><br><span class="line">hadoop fs -put /home/data/world.txt /a.txt # 上传本地文件到hdfs,并重命名</span><br><span class="line">hadoop fs -mkdir /log # 创建文件夹</span><br><span class="line">hadoop fs -get /a.txt /home/data/ # 从hdfs下载文件到本地</span><br><span class="line">hadoop fs -mv /hello.txt /world.txt # 重命名</span><br><span class="line">hadoop fs -cp /world.txt /hello.txt # 复制文件并重命名</span><br><span class="line">hadoop fs -ls / # 查看hdfs的所有文件</span><br><span class="line">hadoop fs -mv /a.txt /log/ # 移动文件到指定目录下</span><br><span class="line">hadoop fs -rmdir /log # 删除的文件夹必须为空(会报错)</span><br><span class="line">hadoop fs -rm /log/a.txt # 删除文件</span><br><span class="line">hadoop fs -rmdir /log # 删除空文件夹</span><br><span class="line">hadoop fs -mkdir /demo</span><br><span class="line">hadoop fs -mv /hello.txt /demo # 移动(剪切)文件</span><br><span class="line">hadoop fs -mv /world.txt /demo</span><br><span class="line">hadoop fs -rmr /demo # 递归删除文件夹</span><br></pre></td></tr></table></figure><hr><h3 id="2-HDFS的概述"><a href="#2-HDFS的概述" class="headerlink" title="2.HDFS的概述"></a>2.HDFS的概述</h3><p>(1) HDFS：<strong>Hadoop Distribute File System</strong> (Hadoop分布式文件系统)</p><p>(2) HDFS是为了方便使用，仿照Linux系统设计的存储系统</p><p>(3) HDFS是典型的主存结构：</p><p><strong>NameNode(主节点) 和 DataNode(从节点)</strong></p><p><strong>DataNode: 存储实际的数据块</strong></p><p>(4) HDFS在存储文件时，会将文件进行物理(Block)切块</p><p>(5) HDFS在存储的时候切块之后<strong>每个Block默认是128MB</strong></p><p>(6) HDFS会自动对数据进行备份，这个备份称之为副本，<strong>在完全分布式的场景中的副本数量默认为3</strong></p><p>ps:</p><p>现代大数据的8大特点（8V）</p><p>1.数据量大(Volume)     2.速度(Velocity)     3.种类(Variety)     4.准确性(Veracity)</p><p>5.可变性(Variability)     6.波动性(Volatility)     7.可视化(visualization)     8.价值(Value)</p><hr><h3 id="3-Block（块存储）"><a href="#3-Block（块存储）" class="headerlink" title="3.Block（块存储）"></a>3.Block（块存储）</h3><p>(1).Block是HDFS中数据存储的基本单位，即一个文件在HDFS存储时由一个或多个Block组成</p><p>(2).Block的大小默认(<u>Hadoop1.0版本默认是64MB，Hadoop2.0是128MB</u>), 可通过<code>dfs.blocksize</code>属性来设置</p><p>(3).若一个文件本身不到128MB，则这个文件是多大则对应的Block就是多大</p><p>(4).HDFS会对Block进行编号，即BlockID</p><p>(5) 切块的意义</p><p>a.能够存储超大文件        b.能够进行快速的备份</p><hr><h3 id="4-NameNode"><a href="#4-NameNode" class="headerlink" title="4.NameNode"></a>4.NameNode</h3><p>(1).<strong>NameNode是HDFS的核心节点(主节点)</strong></p><p>(2).NameNode的职责，<strong>管理DataNode和记录元数据</strong></p><p>(3).元数据包含:</p><p>a. 文件的存储路径     b. 文件的大小     c. Block的大小     d. BlockID v. 副本数量</p><p>(4). 元数据时存储在内存及磁盘当中的目的</p><p><strong>在内存中的目的是查找快，在磁盘中的目的是崩溃恢复</strong></p><p>(5).默认情况下DataNode每隔3s发送心跳，给NameNode</p><hr><h3 id="5-DataNode"><a href="#5-DataNode" class="headerlink" title="5.DataNode"></a>5.DataNode</h3><p>作用：存储Block</p><p>DataNode将Block存储在磁盘上,在磁盘上的存储路径是由<code>hadoop.tmp.dir</code>属性来决定的</p><p>DataNode会定时向NameNode发送心跳，<strong>即RPC远程过程调用</strong></p><hr><h3 id="6-SecondaryNameNode"><a href="#6-SecondaryNameNode" class="headerlink" title="6.SecondaryNameNode"></a>6.SecondaryNameNode</h3><p>到目前为止HDFS集群只能是<strong>NameNode+SecondaryNameNode结构</strong>或者是<strong>双NameNode结构</strong>,</p><p><strong>而在实际生存场景中，采用的都是双NameNode结构</strong>而舍弃掉SecondaryNameNode</p><hr><h3 id="7-垃圾回收机制"><a href="#7-垃圾回收机制" class="headerlink" title="7.垃圾回收机制"></a>7.垃圾回收机制</h3><p>HDFS回收站策略默认是不打开的，意味着删除文件这个操作会立即生效并且不能撤销</p><p>若要开启回收站功能，需在<code>core-site.xml</code>文件中配置 </p><p><code>vim core-site.xml</code>   </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>                                                             </span><br><span class="line">    <span class="comment">&lt;!--                                                               </span></span><br><span class="line"><span class="comment">    配置回收站垃圾清理的时间间隔，单位是min                               </span></span><br><span class="line"><span class="comment">    如果一天内没被还原那么原则上就会被清理掉                            </span></span><br><span class="line"><span class="comment">    1440m ==  24h                                                     </span></span><br><span class="line"><span class="comment">    --&gt;</span>                                                                 </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.trash.interval<span class="tag">&lt;/<span class="name">name</span>&gt;</span>                                    </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1440<span class="tag">&lt;/<span class="name">value</span>&gt;</span>                                                 </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br></pre></td></tr></table></figure><hr><p>从回收站还原的命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mv hdfs://qianfeng01:9000/user/root/.Trash/Current/a.txt /b.txt</span><br></pre></td></tr></table></figure><p>功能测试</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306040012133.png" alt="img-202306040012133" style="zoom:80%;" /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@qianfeng01 hadoop]#</span><br><span class="line">[root@qianfeng01 hadoop]# hadoop fs -rm /a.txt</span><br><span class="line">23/05/30 13:56:50 INFO fs.TrashPolicyDefault: Namenode trash configuration: Deletion interval = 1440 minutes, Emptier interval = 0 minutes.</span><br><span class="line">23/05/30 13:56:50 INFO fs.TrashPolicyDefault: Moved: &#x27;hdfs://qianfeng01:9000/a.txt&#x27; to trash at: hdfs://qianfeng01:9000/user/root/.Trash/Current/a.txt</span><br><span class="line">Moved: &#x27;hdfs://qianfeng01:9000/a.txt&#x27; to trash at: hdfs://qianfeng01:9000/user/root/.Trash/Current</span><br><span class="line">[root@qianfeng01 hadoop]#</span><br><span class="line">[root@qianfeng01 hadoop]#</span><br><span class="line">[root@qianfeng01 hadoop]#</span><br><span class="line">[root@qianfeng01 hadoop]# hadoop fs -mv hdfs://qianfeng01:9000/user/root/.Trash/Current/a.txt /b.txt # 从垃圾站回收并移动并重命名到根目录下</span><br><span class="line">[root@qianfeng01 hadoop]#</span><br></pre></td></tr></table></figure><p>测试完成，关闭Hadoop使用命令<code>stop-all.sh</code></p><hr><h2 id="二、搭建完全分布式运行模式"><a href="#二、搭建完全分布式运行模式" class="headerlink" title="二、搭建完全分布式运行模式"></a>二、搭建完全分布式运行模式</h2><hr><h3 id="1-虚拟机克隆"><a href="#1-虚拟机克隆" class="headerlink" title="1.虚拟机克隆"></a>1.虚拟机克隆</h3><p>从BigData01克隆到BigData02,BigData03</p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202305301422550.png" alt="image-20230530142200018" style="zoom: 50%;" /><p>克隆完成后，依次启动三个虚拟机，查看各虚拟机ip是否是依次往后顺延的</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202305301422009.png" alt="image-20230530142249994"></p><p>没有依次顺延，需要将重复的ip地址更改（BigData02、BigData03的ip地址改为顺延后的）</p><p>依次输入<code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code>来更改网卡配置的ip信息</p><p><code>systemctl restart network</code>  更改好后，重启一下网络</p><hr><h3 id="2-Hadoop完全分布式环境配置（类似Day01伪分布式的配置操作）"><a href="#2-Hadoop完全分布式环境配置（类似Day01伪分布式的配置操作）" class="headerlink" title="2.Hadoop完全分布式环境配置（类似Day01伪分布式的配置操作）"></a>2.Hadoop完全分布式环境配置（类似Day01伪分布式的配置操作）</h3><p><a href="">Day01伪分布式的配置操作</a></p><h4 id="1-在三个节点上关闭防火墙"><a href="#1-在三个节点上关闭防火墙" class="headerlink" title="(1).在三个节点上关闭防火墙"></a>(1).在三个节点上关闭防火墙</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop firewalld # 临时关闭</span><br><span class="line">sudo systemctl disable firewalld # 永久关闭</span><br></pre></td></tr></table></figure><hr><h4 id="2-在三个节点上配置主机名称"><a href="#2-在三个节点上配置主机名称" class="headerlink" title="(2).在三个节点上配置主机名称"></a>(2).在三个节点上配置主机名称</h4><p><code>vim /etc/hostname</code></p><p>将主机名依次指定为qianfeng01,qianfeng02,qianfeng03</p><hr><h4 id="3-配置三个节点的hosts文件"><a href="#3-配置三个节点的hosts文件" class="headerlink" title="(3).配置三个节点的hosts文件"></a>(3).配置三个节点的hosts文件</h4><p>将主机名称和IP地址进行映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line"></span><br><span class="line">xx.xx.xx.xx qianfeng01</span><br><span class="line">xx.xx.xx.xx qianfeng02</span><br><span class="line">xx.xx.xx.xx qianfeng03</span><br></pre></td></tr></table></figure><p>注意，三个节点映射完成后那么三个节点的hostname文件内容将是一样的</p><hr><h4 id="4-对三个节点配置SSH免密互通"><a href="#4-对三个节点配置SSH免密互通" class="headerlink" title="(4).对三个节点配置SSH免密互通"></a>(4).对三个节点配置SSH免密互通</h4><p>三个节点上都需要将生成的公钥拷贝给远程服务器，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen # 生成自己的公钥和秘钥 （依次敲回车即可）</span><br><span class="line">ssh-copy-id root@qianfeng01 # 将生成的公钥拷贝给远程服务器</span><br><span class="line">ssh-copy-id root@qianfeng02</span><br><span class="line">ssh-copy-id root@qianfeng03</span><br></pre></td></tr></table></figure><p>测试ssh功能，</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306040015797.png" alt="img-202306040015797"></p><hr><h4 id="5-三个节点重新启动虚拟机让所有的配置生效"><a href="#5-三个节点重新启动虚拟机让所有的配置生效" class="headerlink" title="(5).三个节点重新启动虚拟机让所有的配置生效"></a>(5).三个节点重新启动虚拟机让所有的配置生效</h4><p>三个节点都输入命令，<code>reboot</code></p><hr><h4 id="6-进入Hadoop安装目录的子目录"><a href="#6-进入Hadoop安装目录的子目录" class="headerlink" title="(6).进入Hadoop安装目录的子目录"></a>(6).进入Hadoop安装目录的子目录</h4><p><code>cd /home/software/hadoop-2.7.6/etc/hadoop/</code></p><p><strong>a. 编辑<code>hadoop-env.sh</code>文件</strong></p><p><code>vim hadoop-env.sh</code>        一般命令模式下(ESC)<code>:set nu</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1) 修改第25行JAVA_HOME的路径:</span><br><span class="line">export JAVA_HOME=/home/software/jdk1.8</span><br><span class="line"></span><br><span class="line">2) 修改第33行HADOOP_CONF_DIR的路径:</span><br><span class="line">export HADOOP_CONF_DIR=/home/software/hadoop-2.7.6/etc/hadoop</span><br><span class="line"></span><br><span class="line">3) 保存退出之后需要让该文件重新生效:</span><br><span class="line">source hadoop-env.sh</span><br></pre></td></tr></table></figure><hr><p><strong>b. 编辑<code>core-site.xml</code>文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--指定在Zookeeper上注册结点的名称 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://ns<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">porperty</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--指定Hadoop数据存储目录--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/software/hadoop-2.7.6/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--指定Zookeeper的连接地址--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>ha.zookeeper.orum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>qianfeng01:2181,qianfeng02:2181,qianfeng03:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p><strong>c.编辑<code>hdfs-site.xml</code>文件</strong></p><p>hadoop01/hadoop02 改为自己的主机名称，同时注意版本号要与自己安装的一致：<code>hadoop-2.7.6</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 绑定在Zookeeper上注册的节点名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.nameservices<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>ns<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ns集群下有两个namenode，分别为nn1, nn2 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.namenodes.ns<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>nn1,nn2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nn1的RPC通信--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>qianfeng01:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nn1的http通信--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address.ns.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>qianfeng01:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- nn2的RPC通信地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>qianfeng02:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- nn2的http通信地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address.ns.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>qianfeng02:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定namenode的元数据在JournalNode上存放的位置，这样，namenode2可以从journalnode集群里的指定位置上获取信息，达到热备效果--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.shared.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>qjournal://qianfeng01:8485;qianfeng02:8485;qianfeng03:8485/ns<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定JournalNode在本地磁盘存放数据的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.journalnode.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/software/hadoop-2.7.6/tmp/journal<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开启NameNode故障时自动切换 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.automatic-failover.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置失败自动切换实现方式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.proxy.provider.ns<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置隔离机制 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.methods<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>sshfence<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用隔离机制时需要ssh免登陆 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.ssh.private-key-files<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/.ssh/id_rsa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置namenode存放元数据的目录，可以不配置，如果不配置则默认放到hadoop.tmp.dir下--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/software/hadoop-2.7.6/tmp/hdfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置datanode存放元数据的目录，可以不配置，如果不配置则默认放到hadoop.tmp.dir下--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/software/hadoop-2.7.6/tmp/hdfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置副本数量--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置用户的操作权限，false表示关闭权限验证，任何用户都可以操作--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p><strong>d.编辑<code>yarn-site.xml</code>文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置yarn的高可用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.ha.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定两个resourcemaneger的名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.ha.rm-ids<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>rm1,rm2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置rm1的主机--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname.rm1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>qianfeng01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置rm2的主机--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname.rm2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>qianfeng03<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启yarn恢复机制--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.recovery.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--执行rm恢复机制实现类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.store.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置zookeeper的地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.zk-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>qianfeng01:2181,qianfeng02:2181,qianfeng03:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--执行yarn集群的别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.cluster-id<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>ns-yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定nodemanager启动时加载server的方式为shuffle server --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定resourcemanager地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>qianfeng03<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p><strong>e.编辑<code>map-site.xml</code>文件</strong></p><p>先将模板问价复制一份并重命名，<code>cp mapred-site.xml.template mapred-site.xml</code></p><p>再配置<code>map-site.xml</code>文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定Mapreduce程序在Yarn上运行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p><strong>f.编辑<code>slaves</code>文件</strong>（当前的<code>/home/software/hadoop-2.7.6/etc/hadoop/</code>目录下）</p><p><code>vim slaves</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qianfeng01</span><br><span class="line">qianfeng02</span><br><span class="line">qianfeng03</span><br></pre></td></tr></table></figure><hr><h4 id="7-将第一个节点上的Hadoop配置好的整个文件夹拷贝给另外两个节点"><a href="#7-将第一个节点上的Hadoop配置好的整个文件夹拷贝给另外两个节点" class="headerlink" title="(7)将第一个节点上的Hadoop配置好的整个文件夹拷贝给另外两个节点"></a>(7)将第一个节点上的Hadoop配置好的整个文件夹拷贝给另外两个节点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r hadoop-2.7.6 root@qianfeng02:/home/software/</span><br><span class="line">scp -r hadoop-2.7.6 root@qianfeng03:/home/software/</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day02-05-30-Hadoop核心技术&quot;&gt;&lt;a href=&quot;#Day02-05-30-Hadoop核心技术&quot; class=&quot;headerlink&quot; title=&quot;Day02(05/30) Hadoop核心技术&quot;&gt;&lt;/a&gt;Day02(05/30) Hadoop</summary>
      
    
    
    
    <category term="大数据开发" scheme="https://ariesfun.gitee.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="学习记录" scheme="https://ariesfun.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="大数据框架" scheme="https://ariesfun.gitee.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Linux" scheme="https://ariesfun.gitee.io/tags/Linux/"/>
    
    <category term="Java" scheme="https://ariesfun.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>23生产实习 Day01(05/29) Hadoop运行环境搭建及配置</title>
    <link href="https://ariesfun.gitee.io/posts/a63b.html"/>
    <id>https://ariesfun.gitee.io/posts/a63b.html</id>
    <published>2023-06-03T17:11:35.942Z</published>
    <updated>2023-06-03T17:27:08.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day01-05-29-Hadoop运行环境搭建及配置"><a href="#Day01-05-29-Hadoop运行环境搭建及配置" class="headerlink" title="Day01(05/29) Hadoop运行环境搭建及配置"></a>Day01(05/29) Hadoop运行环境搭建及配置</h2><hr><p><strong><a href="https://ariesfun.gitee.io/posts/5544.html">查看笔记合集</a></strong></p><h3 id="0-软件环境准备"><a href="#0-软件环境准备" class="headerlink" title="0.软件环境准备"></a><strong>0.软件环境准备</strong></h3><p>虚拟化平台，VMware Workstation 16 Pro</p><p>虚拟机镜像，CentOS7, ISO:<code>CentOS-7-x86_64-DVD-2207-02.iso</code></p><p>远程连接工具, MobaXterm</p><p>一台笔电，操作系统为Win10Pro</p><p>相关资源文件，放在<a href="http://10.200.21.35:8100/s/WJhg">共享网盘资源</a>里了（博客首页左侧的公告）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop-2.7.6.tar.gz # hadoop安装包</span><br><span class="line">jdk-8u131-linux-x64.tar.gz # jdk1.8-linux安装包</span><br></pre></td></tr></table></figure><hr><h3 id="1-关闭防火墙"><a href="#1-关闭防火墙" class="headerlink" title="1.关闭防火墙"></a><strong>1.关闭防火墙</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop firewalld # 临时关闭</span><br><span class="line">sudo systemctl disable firewalld # 永久关闭</span><br></pre></td></tr></table></figure><hr><h3 id="2-配置主机名称"><a href="#2-配置主机名称" class="headerlink" title="2.配置主机名称"></a><strong>2.配置主机名称</strong></h3><p>a. 注意:在Hadoop集群中的主机名称不能存在<code>_</code>和<code>-</code>,如果存在则会导致Hadoop在集群中无法找到该节点<br>b. 编辑文件:<code>vim /etc/hostname</code><br>c. 将主机名称进行指定然后保存退出</p><hr><h3 id="3-配置hosts文件-将主机名称和ip地址进行映射"><a href="#3-配置hosts文件-将主机名称和ip地址进行映射" class="headerlink" title="3.配置hosts文件,将主机名称和ip地址进行映射"></a><strong>3.配置hosts文件,将主机名称和ip地址进行映射</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts # 编辑hosts文件</span><br><span class="line">xx.xx.xx.xx qianfeng01 # 将主机名称与ip地址进行映射</span><br></pre></td></tr></table></figure><hr><h3 id="4-重新启动虚拟机让所有的配置进行生效"><a href="#4-重新启动虚拟机让所有的配置进行生效" class="headerlink" title="4.重新启动虚拟机让所有的配置进行生效"></a><strong>4.重新启动虚拟机让所有的配置进行生效</strong></h3><p>在当前节点输入：<code>reboot</code></p><hr><h3 id="5-配置SSH免密互通"><a href="#5-配置SSH免密互通" class="headerlink" title="5.配置SSH免密互通"></a><strong>5.配置SSH免密互通</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen # 生成自己的公钥和秘钥 </span><br><span class="line">ssh-copy-id root@qianfeng01 # 将生成的公钥拷贝给远程服务器</span><br></pre></td></tr></table></figure><hr><h3 id="6-进入Hadoop安装目录的子目录"><a href="#6-进入Hadoop安装目录的子目录" class="headerlink" title="6.进入Hadoop安装目录的子目录"></a><strong>6.进入Hadoop安装目录的子目录</strong></h3><p><code>cd /home/software/hadoop-2.7.6/etc/hadoop/</code></p><p><strong>a. 编辑<code>hadoop-env.sh</code>文件</strong></p><p>vim打开显示行号功能，进入一般命令模式(ESC),输入<code>:set nu</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1) 修改第25行JAVA_HOME的路径:</span><br><span class="line">export JAVA_HOME=/home/software/jdk1.8</span><br><span class="line"></span><br><span class="line">2) 修改第33行HADOOP_CONF_DIR的路径:</span><br><span class="line">export HADOOP_CONF_DIR=/home/software/hadoop-2.7.6/etc/hadoop</span><br><span class="line"></span><br><span class="line">3) 保存退出之后需要让该文件重新生效:</span><br><span class="line">source hadoop-env.sh</span><br></pre></td></tr></table></figure><hr><p><strong>b. 编辑<code>core-site.xml</code>文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 指定HDFS中的主节点 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://qianfeng01:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 运行Hadoop数据存储目录 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/software/hadoop-2.7.6/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p><strong>c.编辑<code>hdfs-site.xml</code>文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置HDFS的副本数量,在伪分布式的场景中副本数量只能为1 --&gt;</span> # 伪分布式只有1个结点</span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p><strong>d.编辑<code>mapred-site.xml</code>文件</strong><br>将<code>mapred-site.xml.template</code>模板文件复制一份并且重命名为<code>mapred-site.xml</code></p><p><code>cp mapred-site.xml.template mapred-site.xml</code></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Day01-05-29-Hadoop运行环境搭建及配置&quot;&gt;&lt;a href=&quot;#Day01-05-29-Hadoop运行环境搭建及配置&quot; class=&quot;headerlink&quot; title=&quot;Day01(05/29) Hadoop运行环境搭建及配置&quot;&gt;&lt;/a&gt;Day0</summary>
      
    
    
    
    <category term="大数据开发" scheme="https://ariesfun.gitee.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="学习记录" scheme="https://ariesfun.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="大数据框架" scheme="https://ariesfun.gitee.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Linux" scheme="https://ariesfun.gitee.io/tags/Linux/"/>
    
    <category term="Java" scheme="https://ariesfun.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>AcWing周赛 题解及知识点汇总 更新中...</title>
    <link href="https://ariesfun.gitee.io/posts/6086.html"/>
    <id>https://ariesfun.gitee.io/posts/6086.html</id>
    <published>2023-05-07T06:07:39.419Z</published>
    <updated>2023-05-21T17:21:03.192Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="AcWing-周赛-第104场题解"><a href="#AcWing-周赛-第104场题解" class="headerlink" title="AcWing-周赛 第104场题解"></a>AcWing-周赛 第104场题解</h2><h4 id="T1-4981-第几项"><a href="#T1-4981-第几项" class="headerlink" title="T1: 4981. 第几项"></a>T1: <a href="https://www.acwing.com/problem/content/4984/">4981. 第几项</a></h4><p><strong>考察知识点</strong>：<u>语法题</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6475895/">AcWing 4981. 第几项</a></p><hr><h4 id="T2-4982-进制"><a href="#T2-4982-进制" class="headerlink" title="T2: 4982. 进制"></a>T2: <a href="https://www.acwing.com/problem/content/4985/">4982. 进制</a></h4><p><strong>考察知识点</strong>：<u>进位制，位运算，枚举</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6482361/">AcWing 4982. 进制</a></p><hr><h4 id="T2-4983-最大的数"><a href="#T2-4983-最大的数" class="headerlink" title="T2: 4983. 最大的数"></a>T2: <a href="https://www.acwing.com/problem/content/4986/">4983. 最大的数</a></h4><p><strong>考察知识点</strong>：<u>枚举，思维题</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6482409/">AcWing 4983. 最大的数</a></p><hr><h2 id="AcWing-周赛-第103场题解"><a href="#AcWing-周赛-第103场题解" class="headerlink" title="AcWing-周赛 第103场题解"></a>AcWing-周赛 第103场题解</h2><h4 id="T1-4978-解方程"><a href="#T1-4978-解方程" class="headerlink" title="T1: 4978. 解方程"></a>T1: <a href="https://www.acwing.com/problem/content/4981/">4978. 解方程</a></h4><p><strong>考察知识点</strong>：<u>解方程，枚举</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6441920/">AcWing 4978. 解方程</a></p><hr><h4 id="T2-4979-合适的环"><a href="#T2-4979-合适的环" class="headerlink" title="T2: 4979. 合适的环"></a>T2: <a href="https://www.acwing.com/problem/content/4982/">4979. 合适的环</a></h4><p><strong>考察知识点</strong>：<u>无向图存储，枚举</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6445870/">AcWing 4979. 合适的环</a></p><hr><h4 id="T3-4980-猜数字"><a href="#T3-4980-猜数字" class="headerlink" title="T3: 4980. 猜数字"></a>T3: <a href="https://www.acwing.com/problem/content/4983/">4980. 猜数字</a></h4><p><strong>考察知识点</strong>：<u>思维题，(试除法)分解质因数，枚举，STL</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6446382/">AcWing 4980. 猜数字</a></p><hr><h2 id="AcWing-周赛-第102场题解"><a href="#AcWing-周赛-第102场题解" class="headerlink" title="AcWing-周赛 第102场题解"></a>AcWing-周赛 第102场题解</h2><h4 id="T1-4975-或运算"><a href="#T1-4975-或运算" class="headerlink" title="T1: 4975. 或运算"></a>T1: <a href="https://www.acwing.com/problem/content/4978/">4975. 或运算</a></h4><p><strong>考察知识点</strong>：<u>位运算</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6408375/">AcWing 4975. 或运算</a></p><hr><h4 id="T2-4976-倍增"><a href="#T2-4976-倍增" class="headerlink" title="T2: 4976. 倍增 "></a>T2: <a href="https://www.acwing.com/problem/content/4979/">4976. 倍增 </a></h4><p><strong>考察知识点</strong>：<u>分解质因数，思维题，理清题意</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6408515/">AcWing 4976. 倍增</a></p><hr><h4 id="T3-4977-三元组"><a href="#T3-4977-三元组" class="headerlink" title="T3: 4977. 三元组"></a>T3: <a href="https://www.acwing.com/problem/content/4980/">4977. 三元组</a></h4><p><strong>考察知识点</strong>：<u>枚举，乘法原理，哈希表，类前后缀分解</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6410962/">AcWing 4977. 三元组</a></p><hr><h2 id="AcWing-周赛-第101场题解"><a href="#AcWing-周赛-第101场题解" class="headerlink" title="AcWing-周赛 第101场题解"></a>AcWing-周赛 第101场题解</h2><h4 id="T1-4972-解方程"><a href="#T1-4972-解方程" class="headerlink" title="T1: 4972. 解方程 "></a>T1: <a href="https://www.acwing.com/problem/content/4975/">4972. 解方程 </a></h4><p><strong>考察知识点</strong>：<u>解方程，语法题</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6369265/">AcWing 4972. 解方程</a></p><hr><h2 id="AcWing-周赛-第100场题解"><a href="#AcWing-周赛-第100场题解" class="headerlink" title="AcWing-周赛 第100场题解"></a>AcWing-周赛 第100场题解</h2><h4 id="T1-4953-比赛"><a href="#T1-4953-比赛" class="headerlink" title="T1: 4953. 比赛"></a>T1: <a href="https://www.acwing.com/problem/content/4956/">4953. 比赛</a></h4><p><strong>考察知识点</strong>：<u>语法题</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6323965/">AcWing 4953. 比赛</a></p><hr><h4 id="T2-4954-挑选"><a href="#T2-4954-挑选" class="headerlink" title="T2: 4954. 挑选"></a>T2: <a href="https://www.acwing.com/problem/content/4957/">4954. 挑选</a></h4><p><strong>考察知识点</strong>：<u>二进制枚举法</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6331136/">AcWing 4954. 挑选</a></p><hr><h2 id="AcWing-周赛-第99场题解"><a href="#AcWing-周赛-第99场题解" class="headerlink" title="AcWing-周赛 第99场题解"></a>AcWing-周赛 第99场题解</h2><h4 id="T1-4950-四则运算"><a href="#T1-4950-四则运算" class="headerlink" title="T1: 4950. 四则运算"></a>T1: <a href="https://www.acwing.com/problem/content/4953/">4950. 四则运算</a></h4><p><strong>考察知识点</strong>：<u>语法题</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6279695/">AcWing 4950. 四则运算</a></p><hr><h4 id="T2-4951-整理账本"><a href="#T2-4951-整理账本" class="headerlink" title="T2: 4951. 整理账本"></a>T2: <a href="https://www.acwing.com/problem/content/4954/">4951. 整理账本</a></h4><p><strong>考察知识点</strong>：<u>STL的使用，unordered_map、map、vector、pair、sort，</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6282996/">AcWing 4951. 整理账本</a></p><hr><h2 id="AcWing-周赛-第98场题解"><a href="#AcWing-周赛-第98场题解" class="headerlink" title="AcWing-周赛 第98场题解"></a>AcWing-周赛 第98场题解</h2><h4 id="T1-4947-大整数"><a href="#T1-4947-大整数" class="headerlink" title="T1: 4947. 大整数"></a>T1: <a href="https://www.acwing.com/problem/content/4950/">4947. 大整数</a></h4><p><strong>考察知识点</strong>：<u>语法题</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6228724/">AcWing 4947. 大整数</a></p><hr><h4 id="T2-4948-大乘积"><a href="#T2-4948-大乘积" class="headerlink" title="T2: 4948. 大乘积"></a>T2: <a href="https://www.acwing.com/problem/content/4951/">4948. 大乘积</a></h4><p><strong>考察知识点</strong>：<u>语法题，字符串处理</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6238467/">AcWing 4948. 大乘积</a></p><hr><h2 id="AcWing-周赛-第97场题解"><a href="#AcWing-周赛-第97场题解" class="headerlink" title="AcWing-周赛 第97场题解"></a>AcWing-周赛 第97场题解</h2><h4 id="T1-4944-热身计算"><a href="#T1-4944-热身计算" class="headerlink" title="T1: 4944. 热身计算"></a>T1: <a href="https://www.acwing.com/problem/content/4947/">4944. 热身计算</a></h4><p><strong>考察知识点</strong>：<u>语法题</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6125128/">AcWing 4944. 热身计算</a></p><hr><h4 id="T2-4945-比大小"><a href="#T2-4945-比大小" class="headerlink" title="T2: 4945. 比大小"></a>T2: <a href="https://www.acwing.com/problem/content/4948/">4945. 比大小</a></h4><p><strong>考察知识点</strong>：<u>直接模拟，快速幂计算，秦九韶算法</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6125715/">AcWing 4945. 比大小</a></p><hr><h4 id="T3-4946-叶子节点"><a href="#T3-4946-叶子节点" class="headerlink" title="T3: 4946. 叶子节点"></a>T3: <a href="https://www.acwing.com/problem/content/4949/">4946. 叶子节点</a></h4><p><strong>考察知识点</strong>：<u>树的深度优先遍历</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6156437/">AcWing 4946. 叶子节点</a></p><hr><h2 id="第二届ACC-AcWing-Cup-全国联赛"><a href="#第二届ACC-AcWing-Cup-全国联赛" class="headerlink" title="第二届ACC(AcWing Cup)全国联赛"></a>第二届ACC(AcWing Cup)全国联赛</h2><h4 id="T1-4941-凑数"><a href="#T1-4941-凑数" class="headerlink" title="T1: 4941. 凑数"></a>T1: <a href="https://www.acwing.com/problem/content/4944/">4941. 凑数</a></h4><p><strong>考察知识点</strong>：<u>位运算，二进制</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6175836/">AcWing 4941. 凑数</a></p><hr><h4 id="T2-4942-砝码称重"><a href="#T2-4942-砝码称重" class="headerlink" title="T2: 4942. 砝码称重"></a>T2: <a href="https://www.acwing.com/problem/content/4945/">4942. 砝码称重</a></h4><p><strong>考察知识点</strong>：<u>同余性质，n进制</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6177606/">AcWing 4942. 砝码称重</a></p><hr><h2 id="AcWing-周赛-第96场题解"><a href="#AcWing-周赛-第96场题解" class="headerlink" title="AcWing-周赛 第96场题解"></a>AcWing-周赛 第96场题解</h2><h4 id="T1-4876-完美数"><a href="#T1-4876-完美数" class="headerlink" title="T1: 4876. 完美数"></a>T1: <a href="https://www.acwing.com/problem/content/4879/">4876. 完美数</a></h4><p><strong>考察知识点</strong>：<u>完美数，整除性质</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6037798/">AcWing 4876. 完美数</a></p><hr><h4 id="T2-4877-最大价值"><a href="#T2-4877-最大价值" class="headerlink" title="T2: 4877. 最大价值"></a>T2: <a href="https://www.acwing.com/problem/content/4880/">4877. 最大价值</a></h4><p><strong>考察知识点</strong>：<u>DP裸题，完全背包+多重背包组合</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/6062906/">AcWing 4877. 最大价值</a></p><hr><h2 id="AcWing-周赛-第95场题解"><a href="#AcWing-周赛-第95场题解" class="headerlink" title="AcWing-周赛 第95场题解"></a>AcWing-周赛 第95场题解</h2><h4 id="T1-4873-简单计算"><a href="#T1-4873-简单计算" class="headerlink" title="T1:4873. 简单计算"></a>T1:<a href="https://www.acwing.com/problem/content/4876/">4873. 简单计算</a></h4><p><strong>考察知识点</strong>：<u>语法题</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/5957060/">AcWing 4873. 简单计算</a></p><hr><h4 id="T2-4874-约数"><a href="#T2-4874-约数" class="headerlink" title="T2: 4874. 约数"></a>T2: <a href="https://www.acwing.com/problem/content/4877/">4874. 约数</a></h4><p><strong>考察知识点</strong>：<u>筛质数，线性筛法</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/5959789/">AcWing 4874. 约数</a></p><hr><h2 id="AcWing-周赛-第94场题解"><a href="#AcWing-周赛-第94场题解" class="headerlink" title="AcWing-周赛 第94场题解"></a>AcWing-周赛 第94场题解</h2><h4 id="T1-4870-装物品"><a href="#T1-4870-装物品" class="headerlink" title="T1: 4870. 装物品"></a>T1: <a href="https://www.acwing.com/problem/content/4873/">4870. 装物品</a></h4><p><strong>考察知识点</strong>：<u>判断余数，向上取整</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/5852668/">AcWing 4870. 装物品</a></p><hr><h2 id="AcWing-周赛-第93场题解"><a href="#AcWing-周赛-第93场题解" class="headerlink" title="AcWing-周赛 第93场题解"></a>AcWing-周赛 第93场题解</h2><h4 id="T1-4867-整除数"><a href="#T1-4867-整除数" class="headerlink" title="T1: 4867. 整除数"></a>T1: <a href="https://www.acwing.com/problem/content/4870/">4867. 整除数</a></h4><p><strong>考察知识点</strong>：<u>除法性质，整除</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/5738492/">AcWing 4867. 整除数</a></p><hr><h2 id="AcWing-周赛-第92场题解"><a href="#AcWing-周赛-第92场题解" class="headerlink" title="AcWing-周赛 第92场题解"></a>AcWing-周赛 第92场题解</h2><h4 id="T1-4864-多边形"><a href="#T1-4864-多边形" class="headerlink" title="T1: 4864. 多边形"></a>T1: <a href="https://www.acwing.com/problem/content/4867/">4864. 多边形</a></h4><p><strong>考察知识点</strong>：<u>语法题</u></p><p><strong>题解及分析</strong>：<a href="https://www.acwing.com/activity/content/code/content/5628101/">AcWing 4864. 多边形</a></p><hr><h2 id="AcWing-周赛-第xx场题解"><a href="#AcWing-周赛-第xx场题解" class="headerlink" title="AcWing-周赛 第xx场题解"></a>AcWing-周赛 第xx场题解</h2><h4 id="T1"><a href="#T1" class="headerlink" title="T1:"></a>T1:</h4><p><strong>考察知识点</strong>：</p><p><strong>题解及分析</strong>：</p><p>ps:还有之前的一些周赛，待整理… (抽空更)</p><hr><h2 id="活动地址"><a href="#活动地址" class="headerlink" title="活动地址"></a>活动地址</h2><p><a href="https://www.acwing.com/activity/1/competition/">竞赛 - AcWing周赛</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;AcWing-周赛-第104场题解&quot;&gt;&lt;a href=&quot;#AcWing-周赛-第104场题解&quot; class=&quot;headerlink&quot; title=&quot;AcWing-周赛 第104场题解&quot;&gt;&lt;/a&gt;AcWing-周赛 第104场题解&lt;/h2&gt;&lt;h4 id=&quot;</summary>
      
    
    
    
    <category term="AcWing周赛" scheme="https://ariesfun.gitee.io/categories/AcWing%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="C/C++" scheme="https://ariesfun.gitee.io/tags/C-C/"/>
    
    <category term="刷题记录" scheme="https://ariesfun.gitee.io/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="AcWing" scheme="https://ariesfun.gitee.io/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础 第四讲 SSH和SCP</title>
    <link href="https://ariesfun.gitee.io/posts/58be.html"/>
    <id>https://ariesfun.gitee.io/posts/58be.html</id>
    <published>2023-04-30T19:40:46.040Z</published>
    <updated>2023-05-01T08:20:52.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux基础-第四讲-SSH和SCP"><a href="#Linux基础-第四讲-SSH和SCP" class="headerlink" title="Linux基础 第四讲 SSH和SCP"></a>Linux基础 第四讲 SSH和SCP</h1><h2 id="1-教程"><a href="#1-教程" class="headerlink" title="1. 教程"></a>1. 教程</h2><h3 id="（1）ssh登录"><a href="#（1）ssh登录" class="headerlink" title="（1）ssh登录"></a>（1）ssh登录</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><strong>远程登录服务器：ssh user@hostname</strong></p><ul><li>user: 用户名</li><li>hostname: IP地址或域名</li></ul><p><strong>第一次登录</strong>时会提示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;123.57.47.211 (123.57.47.211)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:iy237yysfCe013/l+kpDGfEG9xxHxm0dnxnAbJTPpG8.</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])?</span><br></pre></td></tr></table></figure><p>输入yes，然后回车即可。</p><p>这样会将该服务器的信息记录在<code>~/.ssh/known_hosts</code>文件中。</p><p>然后输入密码即可登录到远程服务器中。</p><hr><p>默认登录端口号为22。如果想<strong>登录某一特定端口</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@hostname -p 22</span><br></pre></td></tr></table></figure><hr><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>创建文件 <code>~/.ssh/config</code>。</p><p>然后在文件中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Host myserver1</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br><span class="line"></span><br><span class="line">Host myserver2</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br></pre></td></tr></table></figure><p>之后再使用服务器时，可以直接使用别名myserver1、myserver2。</p><p><strong>ssh + myserver1</strong> <strong>使用别名登录</strong></p><hr><h4 id="密钥登录"><a href="#密钥登录" class="headerlink" title="密钥登录"></a>密钥登录</h4><p>创建密钥：<code>ssh-keygen</code><br>然后一直回车即可。</p><p>执行结束后，<code>~/.ssh/</code>目录下会多两个文件：</p><ul><li><p><strong>id_rsa：私钥</strong></p></li><li><p><strong>id_rsa.pub：公钥(可以公开)</strong></p></li></ul><p><strong>之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。</strong></p><p>例如，想免密登录myserver服务器。则将公钥中的内容，复制到myserver中的**~/.ssh/authorized_keys**文件里即可。</p><p>也可以使用如下命令<strong>一键添加公钥</strong>：</p><p><code>ssh-copy-id myserver</code></p><hr><h4 id="执行命令-自动化运维会用到"><a href="#执行命令-自动化运维会用到" class="headerlink" title="执行命令(自动化运维会用到)"></a>执行命令(自动化运维会用到)</h4><p>命令格式：<code>ssh user@hostname command</code></p><p><strong>命令会在服务端运行</strong></p><p>例如    <code>ssh user@hostname ls -a</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单引号中的<span class="variable">$i</span>可以求值</span></span><br><span class="line"></span><br><span class="line">ssh myserver &#x27;for ((i = 0; i &lt; 10; i ++ )) do echo $i; done&#x27;  # 将服务器端的结果返回到当前终端里输出</span><br><span class="line">或者</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">双引号中的<span class="variable">$i</span>不可以求值</span></span><br><span class="line"></span><br><span class="line">ssh myserver &quot;for ((i = 0; i &lt; 10; i ++ )) do echo $i; done&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="（2）scp传文件"><a href="#（2）scp传文件" class="headerlink" title="（2）scp传文件"></a>（2）scp传文件</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>命令格式：    <code>scp source destination</code><br>将source路径下的文件复制到destination中</p><p><strong>一次复制多个文件：</strong></p><p><code>scp source1 source2 destination</code></p><p><strong>复制文件夹：</strong></p><p><code>scp -r ~/tmp myserver:/home/acs/</code>  <strong># -r要放在路径前面</strong><br>将本地家目录中的tmp文件夹复制到myserver服务器中的<code>/home/acs/</code>目录下。(家目录)</p><p><code>scp -r ~/tmp myserver:homework/</code><br>将本地家目录中的tmp文件夹复制到myserver服务器中的<code>~/homework/</code>目录下。</p><p><code>scp -r myserver:homework .</code><br>将myserver服务器中的~/homework/文件夹复制到本地的当前路径下。</p><p>ps:</p><p>对于传文件，文件传过去，对于<strong>文件名不冲突的文件，是以追加的方式</strong>。(类似cp命令)</p><p>而所传的文件在另一边已经有了<strong>同名时，是以覆盖的形式</strong>, 文件夹不覆盖。</p><p>指定服务器的端口号：</p><p><code>scp -P 22 source1 source2 destination</code><br>注意： <strong>scp的-r -P等参数尽量加在source和destination之前</strong>。</p><p><strong>使用scp配置其他服务器的vim和tmux</strong> (y总的传家配置hh)<br><strong>scp ~/.vimrc ~/.tmux.conf myserver:</strong></p><hr><h2 id="2-获取ssh教程配套的远程服务器账号的信息"><a href="#2-获取ssh教程配套的远程服务器账号的信息" class="headerlink" title="2.获取ssh教程配套的远程服务器账号的信息"></a>2.获取ssh教程配套的远程服务器账号的信息</h2><p><code>homework 4 getinfo</code></p><hr><h2 id="3-创建作业-amp-测试作业的正确性"><a href="#3-创建作业-amp-测试作业的正确性" class="headerlink" title="3. 创建作业 &amp; 测试作业的正确性"></a>3. 创建作业 &amp; 测试作业的正确性</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">homework 4 create 可以重新创建所有lesson_4的作业</span><br><span class="line">homework 4 create id 可以单独创建lesson_4的第id个作业. e.g.</span><br><span class="line">    homework 4 create 0 可以只重新创建lesson_4的第0个作业</span><br><span class="line">homework 4 test 可以评测lesson_4的所有作业</span><br></pre></td></tr></table></figure><hr><h2 id="4-作业"><a href="#4-作业" class="headerlink" title="4. 作业"></a>4. 作业</h2><p>创建好作业后，先进入文件夹/home/acs/homework/lesson_4/，然后：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(0) 进入homework_0文件夹，要求：</span><br><span class="line">    [1] 该文件夹内容为空</span><br><span class="line">    [2] 配置服务器账号的密钥登陆方式。服务器信息可以通过如下命令获得：</span><br><span class="line">        homework 4 getinfo</span><br><span class="line">        将服务器账号的名称（Host）配置成：myserver</span><br><span class="line">        </span><br><span class="line">(1) 进入homework_1文件夹，下列描述中的“本地”均表示当前文件夹。要求：</span><br><span class="line">    [1] 在myserver服务器上创建并清空文件夹：~/homework/lesson_4/homework_1/</span><br><span class="line">    [2] 将本地的main.cpp文件上传到myserver中的~/homework/lesson_4/homework_1/目录中。</span><br><span class="line">    [3] 在本地创建文件夹dir。</span><br><span class="line">    [4] 将myserver中的/etc/lsb-release文件复制到dir中。</span><br><span class="line">    </span><br><span class="line">(2) 进入homework_2文件夹，下列描述中的“本地”均表示当前文件夹，要求：</span><br><span class="line">    [1] 在myserver服务器上创建并清空文件夹：~/homework/lesson_4/homework_2/</span><br><span class="line">    [2] 将本地的dir文件夹上传到myserver中的~/homework/lesson_4/homework_2/目录中。</span><br><span class="line">    </span><br><span class="line">(3) 进入homework_3文件夹，下列描述中的“本地”均表示当前文件夹，要求：</span><br><span class="line">    [1] 在本地创建文件夹dir。</span><br><span class="line">    [2] 将myserver中的/var/lib/locales/supported.d文件夹下载到本地dir文件夹中。</span><br><span class="line">    </span><br><span class="line">(4) 进入homework_4文件夹，编写脚本remote_mkdir.sh和remote_rmdir.sh，要求：</span><br><span class="line">    [1] 在myserver服务器上创建并清空文件夹：~/homework/lesson_4/homework_4/</span><br><span class="line">    [2] 本地目录下仅包含remote_mkdir.sh和remote_rmdir.sh</span><br><span class="line">    [3] remote_mkdir.sh和remote_rmdir.sh具有可执行权限</span><br><span class="line">    [4] remote_mkdir.sh接收一个传入参数。格式为 ./remote_mkdir.sh directory_name</span><br><span class="line">        该操作可以在myserver服务器上的~/homework/lesson_4/homework_4/目录下，创建一个名为directory_name的文件夹</span><br><span class="line">    [5] remote_rmdir.sh接收一个传入传输。格式为 ./remote_rmdir.sh directory_name</span><br><span class="line">        该操作可以将myserver服务器上的~/homework/lesson_4/homework_4/目录下的名为directory_name的文件夹删掉。</span><br><span class="line">    [6] 注意：传入的文件参数可能包含空格。两个脚本均不需要判断传入参数的合法性。</span><br></pre></td></tr></table></figure><hr><p><strong>章节作业打卡笔记：</strong><br><a href="https://www.acwing.com/activity/content/code/content/6375445/">homework_0</a>    <a href="https://www.acwing.com/activity/content/code/content/6375538/">homework_1</a>    <a href="https://www.acwing.com/activity/content/code/content/6375639/">homework_2</a><br><a href="https://www.acwing.com/activity/content/code/content/6375675/">homework_3</a>    <a href="https://www.acwing.com/activity/content/code/content/6375762/">homework_4</a></p><hr><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5.参考资料"></a>5.参考资料</h2><p>讲义整理自Linux基础课讲义，及评论区的问答整理</p><p><a href="https://www.acwing.com/activity/content/57/">Linux基础课程-AcWing</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux基础-第四讲-SSH和SCP&quot;&gt;&lt;a href=&quot;#Linux基础-第四讲-SSH和SCP&quot; class=&quot;headerlink&quot; title=&quot;Linux基础 第四讲 SSH和SCP&quot;&gt;&lt;/a&gt;Linux基础 第四讲 SSH和SCP&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="Linux基础知识" scheme="https://ariesfun.gitee.io/categories/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Linux" scheme="https://ariesfun.gitee.io/tags/Linux/"/>
    
    <category term="ssh" scheme="https://ariesfun.gitee.io/tags/ssh/"/>
    
    <category term="scp" scheme="https://ariesfun.gitee.io/tags/scp/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘与机器学习 线性回归设计 实训1</title>
    <link href="https://ariesfun.gitee.io/posts/4f1a.html"/>
    <id>https://ariesfun.gitee.io/posts/4f1a.html</id>
    <published>2023-04-30T07:52:52.221Z</published>
    <updated>2023-04-30T07:52:52.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据挖掘与机器学习-线性回归设计-实训1"><a href="#数据挖掘与机器学习-线性回归设计-实训1" class="headerlink" title="数据挖掘与机器学习 线性回归设计 实训1"></a>数据挖掘与机器学习 线性回归设计 实训1</h2><h3 id="（1）实训目的"><a href="#（1）实训目的" class="headerlink" title="（1）实训目的"></a>（1）实训目的</h3><p><strong>1.掌握回归的基本思想；</strong></p><p><strong>2.掌握梯度法的基本原理 。</strong></p><hr><h3 id="（2）主要内容"><a href="#（2）主要内容" class="headerlink" title="（2）主要内容"></a>（2）主要内容</h3><p>1.实现一元线性回归；</p><p>2.画出散点图、回归参数与迭代次数的变化曲线；</p><p>3.分析不同数据变化对回归结果的影响。</p><hr><h3 id="（3）具体处理步骤"><a href="#（3）具体处理步骤" class="headerlink" title="（3）具体处理步骤"></a>（3）具体处理步骤</h3><h4 id="1-导入数据集，绘制数据的散点图"><a href="#1-导入数据集，绘制数据的散点图" class="headerlink" title="1. 导入数据集，绘制数据的散点图"></a>1. 导入数据集，绘制数据的散点图</h4><p><a href="https://pan.baidu.com/s/1jO2p0CSBQedb7QE7PkbJ3A?pwd=2023">data1.txt 数据集下载</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">data=np.loadtxt(<span class="string">&quot;data1.txt&quot;</span>, delimiter=<span class="string">&quot;,&quot;</span>) <span class="comment"># 读取数据集，列索引分别是x和y</span></span><br><span class="line"></span><br><span class="line">x=data[:,<span class="number">0</span>:<span class="number">1</span>] <span class="comment"># 取x这列所有值,训练数据</span></span><br><span class="line">y=data[:,<span class="number">1</span>:]</span><br><span class="line">plt.scatter(x,y) <span class="comment"># 绘制散点图</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304291223504.png" alt="img-202304291223504"></p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.shape <span class="comment"># 原数据集形状，n行m列</span></span><br></pre></td></tr></table></figure><pre><code>(97, 2)</code></pre><hr><h4 id="2-对特征进行归一化处理"><a href="#2-对特征进行归一化处理" class="headerlink" title="2. 对特征进行归一化处理"></a>2. 对特征进行归一化处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">featureNormalize</span>(<span class="params">x</span>): <span class="comment"># （特征值x的取值差别较大）需消除特征值的量纲</span></span><br><span class="line">    avg = x.mean()</span><br><span class="line">    sstd = np.std(x, axis=<span class="number">0</span>, ddof=<span class="number">1</span>) <span class="comment"># 进行标准差标准化处理（ddof是分母为n-1,无偏估计）</span></span><br><span class="line">    x = (x-avg)/sstd</span><br><span class="line">    <span class="keyword">return</span> x, avg, sstd</span><br></pre></td></tr></table></figure><hr><h4 id="3-1-定义损失函数-h-theta是预测函数（假设函数），j-theta是损失函数"><a href="#3-1-定义损失函数-h-theta是预测函数（假设函数），j-theta是损失函数" class="headerlink" title="3.1 定义损失函数   h_theta是预测函数（假设函数），j_theta是损失函数"></a>3.1 定义损失函数   h_theta是预测函数（假设函数），j_theta是损失函数</h4><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304291221890.png" alt="img-202304291221890" style="zoom:67%;" /><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304291221178.png" alt="img-202304291221178" style="zoom: 80%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">computeCost</span>(<span class="params">x, y, theta</span>): <span class="comment"># 损失函数j_theta</span></span><br><span class="line">    m = x.shape[<span class="number">0</span>] <span class="comment"># 获取第一维度的长度（行数），即X特征项对应的个数</span></span><br><span class="line">    <span class="keyword">return</span> np.<span class="built_in">sum</span>((np.dot(x,theta) - y)**<span class="number">2</span>)/(<span class="number">2</span>*m)</span><br></pre></td></tr></table></figure><hr><h4 id="3-2-梯度下降算法"><a href="#3-2-梯度下降算法" class="headerlink" title="3.2 梯度下降算法"></a>3.2 梯度下降算法</h4><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304291222715.png" alt="img-202304291222715" style="zoom:67%;" /><h6 id="利用公式-theta-是预测函数每项的系数，times：梯度下降次数，alpha：梯度下降参数变化率"><a href="#利用公式-theta-是预测函数每项的系数，times：梯度下降次数，alpha：梯度下降参数变化率" class="headerlink" title="利用公式 theta : 是预测函数每项的系数，times：梯度下降次数，alpha：梯度下降参数变化率"></a>利用公式 theta : 是预测函数每项的系数，times：梯度下降次数，alpha：梯度下降参数变化率</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gradientDescent</span>(<span class="params">x, y, theta, times, alpha</span>):</span><br><span class="line">    theta_0 = np.ones(x.shape[<span class="number">0</span>]).T</span><br><span class="line">    x = np.insert(x, <span class="number">0</span>, theta_0, axis=<span class="number">1</span>) <span class="comment"># 对原始数据加入一个全为1的列，方便后续计算</span></span><br><span class="line">    m = x.shape[<span class="number">0</span>] <span class="comment"># 行数</span></span><br><span class="line">    n = x.shape[<span class="number">1</span>] <span class="comment"># 列数</span></span><br><span class="line">    costs = np.zeros(times) <span class="comment"># 初始化损失数组</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(times): <span class="comment"># 循环迭代，计算梯度下降的值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            theta[j] = theta[j] + (alpha/m) * np.<span class="built_in">sum</span>(y - np.dot(x,theta) * x[:,j].reshape(-<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">        costs[num] = computeCost(x, y, theta)</span><br><span class="line">    <span class="keyword">return</span> costs <span class="comment"># 返回每次迭代计算的损失</span></span><br></pre></td></tr></table></figure><hr><h4 id="4-计算求得的直线"><a href="#4-计算求得的直线" class="headerlink" title="4. 计算求得的直线"></a>4. 计算求得的直线</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x_orgin=x <span class="comment"># 分别取x，y这列的值</span></span><br><span class="line">y_orgin=y</span><br><span class="line"></span><br><span class="line">x1, avg, sstd = featureNormalize(x_orgin) <span class="comment"># 得到经特征归一化后的特征值x</span></span><br><span class="line"></span><br><span class="line">theta = np.zeros(x1.shape[<span class="number">1</span>]+<span class="number">1</span>).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment"># 变为1列的列向量（2个theta值）</span></span><br><span class="line">times = <span class="number">600</span></span><br><span class="line">alpha = <span class="number">0.01</span></span><br><span class="line">costs = gradientDescent(x1, y_orgin, theta, times, alpha)</span><br><span class="line"></span><br><span class="line">plt.scatter(x1, y_orgin) <span class="comment"># x1是（-1~4）</span></span><br><span class="line">h_theta = theta[<span class="number">0</span>]+theta[<span class="number">1</span>]*x1 <span class="comment"># 预测的直线</span></span><br><span class="line">plt.plot(x1, h_theta, color= <span class="string">&#x27;red&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304291224464.png" alt="img-202304291224464"></p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预测函数: y = %f + %f * x&#x27;</span> % (theta[<span class="number">0</span>], theta[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证，x=3时，y应该在23附近</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x=3, y = %f&#x27;</span> % (theta[<span class="number">0</span>] + <span class="number">3</span>*theta[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><pre><code>预测函数: y = 5.825092 + 5.884855 * xx=3, y = 23.479657</code></pre><hr><h4 id="5-画损失函数，损失随迭代次数变化的曲线"><a href="#5-画损失函数，损失随迭代次数变化的曲线" class="headerlink" title="5. 画损失函数，损失随迭代次数变化的曲线"></a>5. 画损失函数，损失随迭代次数变化的曲线</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_times = np.linspace(<span class="number">1</span>,times,times)</span><br><span class="line">plt.plot(x_times, costs[<span class="number">0</span>:times], color=<span class="string">&quot;orange&quot;</span>,linewidth=<span class="number">3</span>) <span class="comment"># 纵坐标是损失值</span></span><br></pre></td></tr></table></figure><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304291224616.png" alt="img-202304291224616"></p><hr><h4 id="6-结果分析"><a href="#6-结果分析" class="headerlink" title="6. 结果分析"></a>6. 结果分析</h4><p><strong>分析可知，当迭代次数到200次左右时，损失函数趋于收敛损失值达到最小值，迭代次数太多，可能使得出现过拟合现象</strong></p><p><strong>alpha 越小时，即步长越小，使得训练过程中的变化速度较慢，但可能更易于损失函数收敛</strong></p><hr><h3 id="（4）参考资料"><a href="#（4）参考资料" class="headerlink" title="（4）参考资料"></a>（4）参考资料</h3><p><a href="https://pan.baidu.com/s/1jO2p0CSBQedb7QE7PkbJ3A?pwd=2023">data1.txt 数据集下载</a></p><p><a href="https://www.bilibili.com/video/BV1yf4y1o7A5/?spm_id_from=333.788&vd_source=29b001fc6ca0d80398a993dc92c03a9b">机器学习讲解-B站</a></p><p><a href="https://www.bilibili.com/video/BV1GZ4y1e7fK/?share_source=copy_web&vd_source=64863a79f6edd334371cb7b41a0df347">使用梯度下降法求解线性回归问题</a></p><p><a href="https://www.acwing.com/blog/content/25336/">Python机器学习笔记 - AcWing</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据挖掘与机器学习-线性回归设计-实训1&quot;&gt;&lt;a href=&quot;#数据挖掘与机器学习-线性回归设计-实训1&quot; class=&quot;headerlink&quot; title=&quot;数据挖掘与机器学习 线性回归设计 实训1&quot;&gt;&lt;/a&gt;数据挖掘与机器学习 线性回归设计 实训1&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="数据挖掘与机器学习" scheme="https://ariesfun.gitee.io/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习记录" scheme="https://ariesfun.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Python" scheme="https://ariesfun.gitee.io/tags/Python/"/>
    
    <category term="Matplotlib" scheme="https://ariesfun.gitee.io/tags/Matplotlib/"/>
    
    <category term="Numpy" scheme="https://ariesfun.gitee.io/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>数据分析与可视化 上机实践4（Matplotlib 数据可视化）</title>
    <link href="https://ariesfun.gitee.io/posts/1908.html"/>
    <id>https://ariesfun.gitee.io/posts/1908.html</id>
    <published>2023-04-30T07:30:51.829Z</published>
    <updated>2023-04-30T07:34:06.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据分析与可视化-上机实践4（Matplotlib-数据可视化）"><a href="#数据分析与可视化-上机实践4（Matplotlib-数据可视化）" class="headerlink" title="数据分析与可视化 上机实践4（Matplotlib 数据可视化）"></a>数据分析与可视化 上机实践4（Matplotlib 数据可视化）</h2><h3 id="一、实践目的"><a href="#一、实践目的" class="headerlink" title="一、实践目的"></a>一、实践目的</h3><p><strong>1.了解matplotlib库的基本功能。</strong></p><p><strong>2.掌握matplotlib库的使用方法</strong>。 </p><hr><h3 id="二、数据集介绍"><a href="#二、数据集介绍" class="headerlink" title="二、数据集介绍"></a>二、数据集介绍</h3><p>食品偏好数据集统计了2019年不同国家人民对不同食物的偏好情况。数据共计288条，各数据字段含义如下表所示。</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304301405896.png" alt="img-202304301405896"></p><p><a href="https://pan.baidu.com/s/1XowxkVb9QLds3itkLlL8HA?pwd=2023">food.csv 数据集下载</a></p><hr><h3 id="三、实践内容要求"><a href="#三、实践内容要求" class="headerlink" title="三、实践内容要求"></a>三、实践内容要求</h3><p>1、绘制正弦曲线，并设置标题、坐标轴名称和坐标轴范围；</p><p>2、同一坐标系下绘制多种曲线并通过样式、宽度和颜色加以区分；</p><p>3、对食品偏好数据集进行可视化处理。</p><p>（1）读取数据集，并显示前5行；</p><p>（2）删除无用特征Timestamp和Participant_ID；</p><p>（3）查看数据集的基本情况和统计信息；</p><p>（4）绘制不同国家参与者人数柱状图；</p><p>（5）利用饼形图分别绘制男性和女性对甜点的偏好；</p><p>（6）利用箱体图绘制不同年龄的人对果汁偏爱对比图；</p><p>（7）利用散点图绘制不同年龄的人对甜点的偏爱对比图（提示：年龄作为x轴，maybe，yes和no分别用0,1和-1来表示作为y轴，同时用不同颜色的散点表示Traditional Food和Western Food）；</p><p>（8）根据所绘制的图形，分析人们对不同食物的偏好情况。</p><hr><h3 id="四、完成情况"><a href="#四、完成情况" class="headerlink" title="四、完成情况"></a>四、完成情况</h3><h4 id="（1）简单绘制曲线"><a href="#（1）简单绘制曲线" class="headerlink" title="（1）简单绘制曲线"></a>（1）简单绘制曲线</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、绘制正弦曲线，并设置标题、坐标轴名称和坐标轴范围；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>] </span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 可以正常显示中文</span></span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line">data=np.arange(<span class="number">0</span>, np.pi*<span class="number">4</span>, <span class="number">0.01</span>)</span><br><span class="line">plt.figure(figsize=(<span class="number">4</span>,<span class="number">3</span>),dpi=<span class="number">120</span>)  </span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;sin(x) 正弦曲线&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">plt.xlim(<span class="number">0</span>,np.pi*<span class="number">4</span>) <span class="comment"># x轴范围</span></span><br><span class="line">plt.ylim(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment"># y轴范围</span></span><br><span class="line">plt.xticks([<span class="number">0</span>, np.pi/<span class="number">2</span>, np.pi, np.pi*<span class="number">3</span>/<span class="number">2</span>, np.pi*<span class="number">2</span>, np.pi*<span class="number">5</span>/<span class="number">2</span>, np.pi*<span class="number">3</span>, np.pi*<span class="number">7</span>/<span class="number">2</span>, np.pi*<span class="number">4</span>]) <span class="comment"># 具体刻度</span></span><br><span class="line">plt.yticks([-<span class="number">1</span>,-<span class="number">0.5</span>,<span class="number">0</span>,<span class="number">0.5</span>,<span class="number">1</span>])</span><br><span class="line">plt.plot(data,np.sin(data)) <span class="comment"># 绘制正弦曲线</span></span><br><span class="line">plt.legend([<span class="string">&#x27;sin&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304291817274.png" alt="img-202304291817274"></p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2、同一坐标系下绘制多种曲线并通过样式、宽度和颜色加以区分；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>] </span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  </span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">4</span>,<span class="number">4</span>),dpi=<span class="number">100</span>) </span><br><span class="line">data=np.arange(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.01</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;多种曲线样式&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">plt.xlim(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">plt.xticks([<span class="number">0</span>,<span class="number">0.2</span>,<span class="number">0.4</span>,<span class="number">0.6</span>,<span class="number">0.8</span>,<span class="number">1</span>])</span><br><span class="line">plt.yticks([<span class="number">0</span>,<span class="number">0.2</span>,<span class="number">0.4</span>,<span class="number">0.6</span>,<span class="number">0.8</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.plot(data, <span class="number">2.5</span>*data, marker=<span class="string">&#x27;^&#x27;</span>)</span><br><span class="line">plt.plot(data, data**<span class="number">0.5</span>, linewidth=<span class="number">4</span>)</span><br><span class="line">plt.plot(data, data**<span class="number">3</span>, linewidth=<span class="number">3</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;y=2.5*x&#x27;</span>,<span class="string">&#x27;y=x^0.5&#x27;</span>, <span class="string">&#x27;y=x^3&#x27;</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304291817635.png" alt="img-202304291817635"></p><hr><h4 id="（2）对食品偏好数据集进行可视化处理"><a href="#（2）对食品偏好数据集进行可视化处理" class="headerlink" title="（2）对食品偏好数据集进行可视化处理"></a>（2）对食品偏好数据集进行可视化处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（1）读取数据集，并显示前5行；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">food=pd.read_csv(<span class="string">&#x27;food.csv&#x27;</span>)</span><br><span class="line">food.head()</span><br></pre></td></tr></table></figure><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304291822462.jpg" alt="img-202304291822462"></p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（2）删除无用特征Timestamp和Participant_ID；</span></span><br><span class="line"></span><br><span class="line">food.drop([<span class="string">&#x27;Timestamp&#x27;</span>,<span class="string">&#x27;Participant_ID&#x27;</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>) <span class="comment"># 删除这两列，并替换原数据</span></span><br><span class="line">food.head()</span><br></pre></td></tr></table></figure><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304291822300.jpg" alt="img-202304291822300" style="zoom: 50%;" /><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（3）查看数据集的基本情况和统计信息；</span></span><br><span class="line"></span><br><span class="line">food.info()</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">RangeIndex: 288 entries, 0 to 287</span><br><span class="line">Data columns (total 6 columns):</span><br><span class="line"> #   Column       Non-Null Count  Dtype </span><br><span class="line">---  ------       --------------  ----- </span><br><span class="line"> 0   Gender       284 non-null    object</span><br><span class="line"> 1   Nationality  288 non-null    object</span><br><span class="line"> 2   Age          288 non-null    int64 </span><br><span class="line"> 3   Food         288 non-null    object</span><br><span class="line"> 4   Juice        288 non-null    object</span><br><span class="line"> 5   Dessert      288 non-null    object</span><br><span class="line">dtypes: int64(1), object(5)</span><br><span class="line">memory usage: 13.6+ KB</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">food.describe()</span><br></pre></td></tr></table></figure><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304291822894.jpg" alt="003" style="zoom:50%;" /><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（4）绘制不同国家参与者人数柱状图；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">7</span>,<span class="number">6</span>),dpi=<span class="number">100</span>) </span><br><span class="line">data=food[<span class="string">&#x27;Nationality&#x27;</span>].value_counts() <span class="comment"># 统计不同国家参与者人数</span></span><br><span class="line">data.plot(kind=<span class="string">&#x27;bar&#x27;</span>,rot=<span class="number">30</span>) <span class="comment">#设置对应国家的列标签，并倾斜30度</span></span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;国家&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;人数&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;不同国家参与者人数柱状图&#x27;</span>)</span><br><span class="line">plt.bar(<span class="built_in">range</span>(<span class="built_in">len</span>( data)),data)</span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(data)),data):</span><br><span class="line">    plt.text(x,y,y,ha = <span class="string">&#x27;center&#x27;</span>,va = <span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304291817131.png" alt="img-202304291817131" style="zoom: 80%;" /><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（5）利用饼形图分别绘制男性和女性对甜点的偏好；</span></span><br><span class="line"></span><br><span class="line">food.groupby(<span class="string">&#x27;Dessert&#x27;</span>)[<span class="string">&#x27;Gender&#x27;</span>].value_counts() <span class="comment"># 统计不同性别对甜点偏好的情况</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Dessert  Gender</span><br><span class="line">Maybe    Female    72</span><br><span class="line">         Male      50</span><br><span class="line">No       Female    35</span><br><span class="line">         Male      17</span><br><span class="line">Yes      Female    58</span><br><span class="line">         Male      52</span><br><span class="line">Name: Gender, dtype: int64</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">food[<span class="string">&#x27;Gender&#x27;</span>].value_counts() <span class="comment"># 统计不同性别对应的人数，方便后面绘制饼图</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Female    165</span><br><span class="line">Male      119</span><br><span class="line">Name: Gender, dtype: int64</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">labels=[<span class="string">&#x27;Maybe&#x27;</span>,<span class="string">&#x27;No&#x27;</span>,<span class="string">&#x27;Yes&#x27;</span>]</span><br><span class="line">x=[<span class="number">72</span>/<span class="number">165</span>, <span class="number">35</span>/<span class="number">165</span>, <span class="number">58</span>/<span class="number">165</span>]</span><br><span class="line">explode=(<span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">0.01</span>)</span><br><span class="line">plt.pie(x, labels=labels, explode=explode, startangle=<span class="number">60</span>, autopct=<span class="string">&#x27;%1.1f %%&#x27;</span>) <span class="comment"># 分别绘制男性和女性对甜点偏好的饼图</span></span><br><span class="line">plt.title(<span class="string">&#x27;男性对甜点的偏好&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">labels=[<span class="string">&#x27;Maybe&#x27;</span>,<span class="string">&#x27;No&#x27;</span>,<span class="string">&#x27;Yes&#x27;</span>]</span><br><span class="line">x=[<span class="number">50</span>/<span class="number">119</span>, <span class="number">17</span>/<span class="number">119</span>, <span class="number">52</span>/<span class="number">119</span>]</span><br><span class="line">explode=(<span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">0.01</span>) <span class="comment"># autopct=&#x27;％1.1f%%&#x27;参数表示在饼形图上显示每个部分的百分比</span></span><br><span class="line">plt.pie(x, labels=labels, explode=explode, startangle=<span class="number">60</span>, autopct=<span class="string">&#x27;%1.1f %%&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;女性对甜点的偏好&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304291814755.png" alt="img-202304291814755" style="zoom:80%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（6）利用箱体图绘制不同年龄的人对果汁偏爱对比图</span></span><br><span class="line"></span><br><span class="line">food.groupby(<span class="string">&#x27;Juice&#x27;</span>)[<span class="string">&#x27;Age&#x27;</span>].value_counts() <span class="comment"># 先按对果汁的偏爱分组，再统计各自年龄对应的人数</span></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Juice              Age</span><br><span class="line">Carbonated drinks  21     5</span><br><span class="line">                   23     4</span><br><span class="line">                   25     3</span><br><span class="line">                   22     2</span><br><span class="line">                   24     2</span><br><span class="line">                         ..</span><br><span class="line">Fresh Juice        60     1</span><br><span class="line">                   63     1</span><br><span class="line">                   65     1</span><br><span class="line">                   67     1</span><br><span class="line">                   74     1</span><br><span class="line">Name: Age, Length: 66, dtype: int64</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">food[<span class="string">&#x27;Juice&#x27;</span>].value_counts()</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fresh Juice          256</span><br><span class="line">Carbonated drinks     32</span><br><span class="line">Name: Juice, dtype: int64</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>,<span class="number">6</span>),dpi=<span class="number">90</span>)</span><br><span class="line"><span class="comment"># 为方便展示示例效果，这里使用seaborn库来绘制箱体图</span></span><br><span class="line"><span class="comment"># 生成一个水平方向的箱体图，其中每个箱子代表一种不同年龄段人群喜好某种果汁的程度</span></span><br><span class="line">sns.boxplot(x=food[<span class="string">&#x27;Age&#x27;</span>], y=food[<span class="string">&#x27;Juice&#x27;</span>], data=food, orient=<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置横纵坐标标签</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Juice&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304291815783.png" alt="img-202304291815783" style="zoom: 80%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（7）利用散点图绘制不同年龄的人对甜点的偏爱对比图（提示：年龄作为x轴，maybe，yes和no分别用0,1和-1来表示作为y轴，同时用不同颜色的散点表示Traditional Food和Western Food）。</span></span><br><span class="line"><span class="comment"># pd.set_option(&#x27;display.max_rows&#x27;, 100) # 让数据显示更全</span></span><br><span class="line"></span><br><span class="line">df=food.groupby(<span class="string">&#x27;Dessert&#x27;</span>)[<span class="string">&#x27;Age&#x27;</span>].value_counts() <span class="comment"># 统计不同年龄对甜点偏好的情况</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">4</span>),dpi=<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line">plt.scatter(food[<span class="string">&#x27;Age&#x27;</span>], food[<span class="string">&#x27;Dessert&#x27;</span>], color=<span class="string">&#x27;green&#x27;</span>) <span class="comment"># 显示不同年龄，对应的甜品偏好情况</span></span><br></pre></td></tr></table></figure><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304291815498.png" alt="img-202304291815498" style="zoom: 80%;" /><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">4</span>),dpi=<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对原数据中对甜品的偏爱情况进行替换，y轴用这些来表示:Yes，Maybe和No分别用1，0和-1</span></span><br><span class="line">traditional_likes = food[food[<span class="string">&#x27;Food&#x27;</span>] == <span class="string">&#x27;Traditional food&#x27;</span>][<span class="string">&#x27;Dessert&#x27;</span>].replace(&#123;<span class="string">&#x27;Yes&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Maybe&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;No&#x27;</span>: -<span class="number">1</span>&#125;)</span><br><span class="line">western_likes = food[food[<span class="string">&#x27;Food&#x27;</span>] == <span class="string">&#x27;Western Food&#x27;</span>][<span class="string">&#x27;Dessert&#x27;</span>].replace(&#123;<span class="string">&#x27;Yes&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Maybe&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;No&#x27;</span>: -<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">age = food[<span class="string">&#x27;Age&#x27;</span>] <span class="comment"># x轴是在不同年龄下，人们对传统和西方食物的分布情况</span></span><br><span class="line">plt.scatter(age[food[<span class="string">&#x27;Food&#x27;</span>] == <span class="string">&#x27;Traditional food&#x27;</span>], traditional_likes, color=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;Traditional food&#x27;</span>)</span><br><span class="line">plt.scatter(age[food[<span class="string">&#x27;Food&#x27;</span>] == <span class="string">&#x27;Western Food&#x27;</span>], western_likes, color=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;Western Food&#x27;</span>) <span class="comment"># 西方美食对应 Western Food </span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Dessert&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()   </span><br></pre></td></tr></table></figure><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304291816686.png" alt="img-202304291816686" style="zoom:80%;" /><hr><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#（8）根据所绘制的图形，分析人们对不同食物的偏好情况。</span><br><span class="line"></span><br><span class="line"># 在该图中，红色表示传统美食的偏好程度，蓝色表示西方美食的偏好程度。可以得出结论，在所有年龄段中人们似乎更喜欢传统美食。</span><br><span class="line"># 其中在年龄20到40之间的人群对传统美食的偏爱程度较高，年龄在15到30之间的人群对西方美食偏爱程度较高。</span><br></pre></td></tr></table></figure><hr><h3 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h3><p><a href="https://pan.baidu.com/s/1XowxkVb9QLds3itkLlL8HA?pwd=2023">food.csv 数据集下载</a></p><p> (5), (6), (7)中的可视化处理参考了<strong>chatgpt</strong>提供的解题思路</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据分析与可视化-上机实践4（Matplotlib-数据可视化）&quot;&gt;&lt;a href=&quot;#数据分析与可视化-上机实践4（Matplotlib-数据可视化）&quot; class=&quot;headerlink&quot; title=&quot;数据分析与可视化 上机实践4（Matplotlib 数据</summary>
      
    
    
    
    <category term="数据分析与可视化" scheme="https://ariesfun.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
    <category term="学习记录" scheme="https://ariesfun.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Python" scheme="https://ariesfun.gitee.io/tags/Python/"/>
    
    <category term="Matplotlib" scheme="https://ariesfun.gitee.io/tags/Matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>数据分析与可视化 上机实践3（Pandas 数据预处理）</title>
    <link href="https://ariesfun.gitee.io/posts/e26c.html"/>
    <id>https://ariesfun.gitee.io/posts/e26c.html</id>
    <published>2023-04-30T07:29:39.353Z</published>
    <updated>2023-04-30T07:34:01.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据分析与可视化-上机实践3（Pandas-数据预处理）"><a href="#数据分析与可视化-上机实践3（Pandas-数据预处理）" class="headerlink" title="数据分析与可视化 上机实践3（Pandas 数据预处理）"></a>数据分析与可视化 上机实践3（Pandas 数据预处理）</h2><hr><h3 id="一、实践目的"><a href="#一、实践目的" class="headerlink" title="一、实践目的"></a>一、实践目的</h3><p>1.掌握数据预处理的思想和方法。<br><strong>2.进一步熟悉Pandas库的使用方法。</strong></p><hr><h3 id="二、数据集介绍"><a href="#二、数据集介绍" class="headerlink" title="二、数据集介绍"></a>二、数据集介绍</h3><p>Lending Club是一家美国P2P公司，投资者在平台中为融资方提供资金，并以此获得贷款利率收益。Lending Club为投资者与融资方提供平台。本实验使用Lending Club2015年公开数据集中截取的一小部分进行分析。数据分为三个部分：<br>（1）用户信息数据</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304301433917.png" alt="img-202304301433917"></p><p>（2）用户历史数据</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304301433211.png" alt="img-202304301433211"></p><p>（3）贷款交易数据</p><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304301433303.png" alt="img-202304301433303"></p><p><a href="https://pan.baidu.com/s/1uu73xf2SVsJsAjBQceRfKA?pwd=2023">Lending Club2015年公开数据集下载</a></p><hr><h3 id="三、实践内容要求"><a href="#三、实践内容要求" class="headerlink" title="三、实践内容要求"></a>三、实践内容要求</h3><p>（1）导入三个数据表到DataFrame中；</p><p>（2）查看各数据表的前5行；</p><p>（3）查看数据基本情况，并对基本情况进行分析；</p><p>（4）利用“用户编号”这个公共变量，将用户信息数据和用户历史数据合并在一起，对比inner、outer、left和right连接的区别；</p><p>（5）将用户历史数据按账户平均存款排序；</p><p>（6）基于贷款交易数据，进行左连接，将三个数据合并在一起；</p><p>（7）删去用于合并的列名user_id，使用info查看数据缺失情况，删除缺失数据；</p><p>（8）将年收入进行离散化，分为高中低三档；</p><p>（9）贷款状态为”Charged Off”,”In Grace Period”, “Late (31-120 days)”的贷款有违约风险，视为不良贷款，将其值标记为1，其他贷款标记为0；</p><p>（10）将term、grade、emp_length、annual_inc、home_ownership、verification_status这些分类变量进行哑变量处理。</p><hr><h3 id="四、完成情况"><a href="#四、完成情况" class="headerlink" title="四、完成情况"></a>四、完成情况</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（1）导入三个数据表到DataFrame中；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.unicode.east_asian_width&#x27;</span>, <span class="literal">True</span>)</span><br><span class="line">user = pd.read_csv(<span class="string">&#x27;user.csv&#x27;</span>,sep = <span class="string">&#x27;,&#x27;</span>) <span class="comment"># 读取文件</span></span><br><span class="line">history = pd.read_csv(<span class="string">&#x27;history.csv&#x27;</span>,sep = <span class="string">&#x27;,&#x27;</span>) </span><br><span class="line">loan = pd.read_csv(<span class="string">&#x27;loan.csv&#x27;</span>,sep = <span class="string">&#x27;,&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#（2）查看各数据表的前5行；</span></span><br><span class="line"></span><br><span class="line">user.head() <span class="comment"># 默认输出前5行数据</span></span><br></pre></td></tr></table></figure><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304301438980.jpg" alt="img-202304301438980" style="zoom: 60%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.head()</span><br></pre></td></tr></table></figure><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304301438592.jpg" alt="img-202304301438592" style="zoom:67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loan.head()</span><br></pre></td></tr></table></figure><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304301438890.jpg" alt="img-202304301438890" style="zoom:67%;" /><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（3）查看数据基本情况，并对基本情况进行分析；</span></span><br><span class="line"></span><br><span class="line">user.info()</span><br><span class="line">history.info()</span><br><span class="line">loan.info()</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">RangeIndex: 1707 entries, 0 to 1706</span><br><span class="line">Data columns (total 5 columns):</span><br><span class="line"> #   Column               Non-Null Count  Dtype  </span><br><span class="line">---  ------               --------------  -----  </span><br><span class="line"> 0   user_id              1707 non-null   int64  </span><br><span class="line"> 1   emp_length           1633 non-null   object </span><br><span class="line"> 2   home_ownership       1707 non-null   object </span><br><span class="line"> 3   annual_inc           1707 non-null   float64</span><br><span class="line"> 4   verification_status  1707 non-null   object </span><br><span class="line">dtypes: float64(1), int64(1), object(3)</span><br><span class="line">memory usage: 66.8+ KB</span><br><span class="line">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">RangeIndex: 1648 entries, 0 to 1647</span><br><span class="line">Data columns (total 3 columns):</span><br><span class="line"> #   Column                Non-Null Count  Dtype  </span><br><span class="line">---  ------                --------------  -----  </span><br><span class="line"> 0   user                  1648 non-null   int64  </span><br><span class="line"> 1   acc_open_past_24mths  1648 non-null   int64  </span><br><span class="line"> 2   avg_cur_bal           1646 non-null   float64</span><br><span class="line">dtypes: float64(1), int64(2)</span><br><span class="line">memory usage: 38.8 KB</span><br><span class="line">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">RangeIndex: 1269 entries, 0 to 1268</span><br><span class="line">Data columns (total 5 columns):</span><br><span class="line"> #   Column       Non-Null Count  Dtype </span><br><span class="line">---  ------       --------------  ----- </span><br><span class="line"> 0   user         1269 non-null   int64 </span><br><span class="line"> 1   term         1269 non-null   object</span><br><span class="line"> 2   int_rate     1269 non-null   object</span><br><span class="line"> 3   grade        1269 non-null   object</span><br><span class="line"> 4   loan_status  1269 non-null   object</span><br><span class="line">dtypes: int64(1), object(4)</span><br><span class="line">memory usage: 49.7+ KB</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（4）利用“用户编号”这个公共变量，将用户信息数据和用户历史数据合并在一起，对比inner、outer、left和right连接的区别；</span></span><br><span class="line"></span><br><span class="line">a1 = pd.merge(user, history, left_on=<span class="string">&#x27;user_id&#x27;</span>, right_on=<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a1)</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">      user_id emp_length home_ownership  annual_inc verification_status  user  \</span><br><span class="line">0           1  10+ years           RENT     78000.0     Source Verified     1   </span><br><span class="line">1           2    8 years       MORTGAGE     58000.0        Not Verified     2   </span><br><span class="line">2           3  10+ years       MORTGAGE    125000.0            Verified     3   </span><br><span class="line">3           4  10+ years           RENT     69000.0     Source Verified     4   </span><br><span class="line">4           5   &lt; 1 year           RENT     50000.0     Source Verified     5   </span><br><span class="line">...       ...        ...            ...         ...                 ...   ...   </span><br><span class="line">1643     1644  10+ years            OWN     72000.0            Verified  1644   </span><br><span class="line">1644     1645    7 years       MORTGAGE     62000.0     Source Verified  1645   </span><br><span class="line">1645     1646    4 years           RENT     50000.0     Source Verified  1646   </span><br><span class="line">1646     1647     1 year           RENT     45000.0        Not Verified  1647   </span><br><span class="line">1647     1648    2 years            OWN     35000.0        Not Verified  1648   </span><br><span class="line"></span><br><span class="line">      acc_open_past_24mths  avg_cur_bal  </span><br><span class="line">0                        5      29828.0  </span><br><span class="line">1                        7       9536.0  </span><br><span class="line">2                        2      32727.0  </span><br><span class="line">3                        8       3214.0  </span><br><span class="line">4                        6       5857.0  </span><br><span class="line">...                    ...          ...  </span><br><span class="line">1643                     3       1676.0  </span><br><span class="line">1644                     4      21360.0  </span><br><span class="line">1645                     1       3180.0  </span><br><span class="line">1646                     8       3652.0  </span><br><span class="line">1647                     3       1586.0  </span><br><span class="line"></span><br><span class="line">[1648 rows x 8 columns]</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（5）将用户历史数据按账户平均存款排序；</span></span><br><span class="line"></span><br><span class="line">a2 = history.sort_values(by = <span class="string">&#x27;avg_cur_bal&#x27;</span>)</span><br><span class="line">a2.head()</span><br></pre></td></tr></table></figure><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304301439203.jpg" alt="img-202304301439203" style="zoom:67%;" /><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（6）基于贷款交易数据，进行左连接，将三个数据合并在一起；</span></span><br><span class="line"></span><br><span class="line">a3 = pd.merge(a1, loan, how=<span class="string">&#x27;left&#x27;</span>) <span class="comment"># 将三表进行左连接</span></span><br><span class="line"><span class="built_in">print</span>(a3)</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">      user_id emp_length home_ownership  annual_inc verification_status  user  \</span><br><span class="line">0           1  10+ years           RENT     78000.0     Source Verified     1   </span><br><span class="line">1           2    8 years       MORTGAGE     58000.0        Not Verified     2   </span><br><span class="line">2           3  10+ years       MORTGAGE    125000.0            Verified     3   </span><br><span class="line">3           4  10+ years           RENT     69000.0     Source Verified     4   </span><br><span class="line">4           5   &lt; 1 year           RENT     50000.0     Source Verified     5   </span><br><span class="line">...       ...        ...            ...         ...                 ...   ...   </span><br><span class="line">1643     1644  10+ years            OWN     72000.0            Verified  1644   </span><br><span class="line">1644     1645    7 years       MORTGAGE     62000.0     Source Verified  1645   </span><br><span class="line">1645     1646    4 years           RENT     50000.0     Source Verified  1646   </span><br><span class="line">1646     1647     1 year           RENT     45000.0        Not Verified  1647   </span><br><span class="line">1647     1648    2 years            OWN     35000.0        Not Verified  1648   </span><br><span class="line"></span><br><span class="line">      acc_open_past_24mths  avg_cur_bal        term int_rate grade  \</span><br><span class="line">0                        5      29828.0   60 months   12.39%     C   </span><br><span class="line">1                        7       9536.0   36 months    6.99%     A   </span><br><span class="line">2                        2      32727.0   60 months   17.14%     D   </span><br><span class="line">3                        8       3214.0   36 months   13.66%     C   </span><br><span class="line">4                        6       5857.0   36 months   13.66%     C   </span><br><span class="line">...                    ...          ...         ...      ...   ...   </span><br><span class="line">1643                     3       1676.0         NaN      NaN   NaN   </span><br><span class="line">1644                     4      21360.0         NaN      NaN   NaN   </span><br><span class="line">1645                     1       3180.0         NaN      NaN   NaN   </span><br><span class="line">1646                     8       3652.0         NaN      NaN   NaN   </span><br><span class="line">1647                     3       1586.0         NaN      NaN   NaN   </span><br><span class="line"></span><br><span class="line">          loan_status  </span><br><span class="line">0          Fully Paid  </span><br><span class="line">1         Charged Off  </span><br><span class="line">2     In Grace Period  </span><br><span class="line">3          Fully Paid  </span><br><span class="line">4         Charged Off  </span><br><span class="line">...               ...  </span><br><span class="line">1643              NaN  </span><br><span class="line">1644              NaN  </span><br><span class="line">1645              NaN  </span><br><span class="line">1646              NaN  </span><br><span class="line">1647              NaN  </span><br><span class="line"></span><br><span class="line">[1648 rows x 12 columns]</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（7）删去用于合并的列名user_id，使用info查看数据缺失情况，删除缺失数据；</span></span><br><span class="line"></span><br><span class="line">a3.drop(<span class="string">&#x27;user_id&#x27;</span>,axis = <span class="number">1</span>,inplace = <span class="literal">True</span>) <span class="comment"># axis=1，删除user_id这一列</span></span><br><span class="line"><span class="built_in">print</span>(a3)</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">     emp_length home_ownership  annual_inc verification_status  user  \</span><br><span class="line">0     10+ years           RENT     78000.0     Source Verified     1   </span><br><span class="line">1       8 years       MORTGAGE     58000.0        Not Verified     2   </span><br><span class="line">2     10+ years       MORTGAGE    125000.0            Verified     3   </span><br><span class="line">3     10+ years           RENT     69000.0     Source Verified     4   </span><br><span class="line">4      &lt; 1 year           RENT     50000.0     Source Verified     5   </span><br><span class="line">...         ...            ...         ...                 ...   ...   </span><br><span class="line">1643  10+ years            OWN     72000.0            Verified  1644   </span><br><span class="line">1644    7 years       MORTGAGE     62000.0     Source Verified  1645   </span><br><span class="line">1645    4 years           RENT     50000.0     Source Verified  1646   </span><br><span class="line">1646     1 year           RENT     45000.0        Not Verified  1647   </span><br><span class="line">1647    2 years            OWN     35000.0        Not Verified  1648   </span><br><span class="line"></span><br><span class="line">      acc_open_past_24mths  avg_cur_bal        term int_rate grade  \</span><br><span class="line">0                        5      29828.0   60 months   12.39%     C   </span><br><span class="line">1                        7       9536.0   36 months    6.99%     A   </span><br><span class="line">2                        2      32727.0   60 months   17.14%     D   </span><br><span class="line">3                        8       3214.0   36 months   13.66%     C   </span><br><span class="line">4                        6       5857.0   36 months   13.66%     C   </span><br><span class="line">...                    ...          ...         ...      ...   ...   </span><br><span class="line">1643                     3       1676.0         NaN      NaN   NaN   </span><br><span class="line">1644                     4      21360.0         NaN      NaN   NaN   </span><br><span class="line">1645                     1       3180.0         NaN      NaN   NaN   </span><br><span class="line">1646                     8       3652.0         NaN      NaN   NaN   </span><br><span class="line">1647                     3       1586.0         NaN      NaN   NaN   </span><br><span class="line"></span><br><span class="line">          loan_status  </span><br><span class="line">0          Fully Paid  </span><br><span class="line">1         Charged Off  </span><br><span class="line">2     In Grace Period  </span><br><span class="line">3          Fully Paid  </span><br><span class="line">4         Charged Off  </span><br><span class="line">...               ...  </span><br><span class="line">1643              NaN  </span><br><span class="line">1644              NaN  </span><br><span class="line">1645              NaN  </span><br><span class="line">1646              NaN  </span><br><span class="line">1647              NaN  </span><br><span class="line"></span><br><span class="line">[1648 rows x 11 columns]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a3.isnull().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">emp_length               71</span><br><span class="line">home_ownership            0</span><br><span class="line">annual_inc                0</span><br><span class="line">verification_status       0</span><br><span class="line">user                      0</span><br><span class="line">acc_open_past_24mths      0</span><br><span class="line">avg_cur_bal               2</span><br><span class="line">term                    379</span><br><span class="line">int_rate                379</span><br><span class="line">grade                   379</span><br><span class="line">loan_status             379</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a3.dropna(axis = <span class="number">0</span>, inplace =<span class="literal">True</span>) <span class="comment"># 沿行删除所有数据</span></span><br><span class="line">a3.isnull().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">emp_length              0</span><br><span class="line">home_ownership          0</span><br><span class="line">annual_inc              0</span><br><span class="line">verification_status     0</span><br><span class="line">user                    0</span><br><span class="line">acc_open_past_24mths    0</span><br><span class="line">avg_cur_bal             0</span><br><span class="line">term                    0</span><br><span class="line">int_rate                0</span><br><span class="line">grade                   0</span><br><span class="line">loan_status             0</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># （8）将年收入进行离散化，分为高中低三档；</span></span><br><span class="line"></span><br><span class="line">a3[<span class="string">&#x27;年收入&#x27;</span>] = pd.cut(a3[<span class="string">&#x27;annual_inc&#x27;</span>], bins=[<span class="number">0</span>, <span class="number">50000</span>, <span class="number">100000</span>, a3[<span class="string">&#x27;annual_inc&#x27;</span>].<span class="built_in">max</span>()], labels=[<span class="string">&#x27;低&#x27;</span>,<span class="string">&#x27;中&#x27;</span>, <span class="string">&#x27;高&#x27;</span>])</span><br><span class="line">a3.head()</span><br></pre></td></tr></table></figure><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304301440474.jpg" alt="img-202304301440474"></p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（9）贷款状态为&quot;Charged Off&quot;,&quot;In Grace Period&quot;, &quot;Late (31-120 days)&quot;的贷款有违约风险，视为不良贷款，将其值标记为1，其他贷款标记为0；</span></span><br><span class="line"><span class="comment"># 使用字典方式进行替换</span></span><br><span class="line"></span><br><span class="line">a3.replace(to_replace=&#123;<span class="string">&#x27;loan_status&#x27;</span>:</span><br><span class="line">&#123;<span class="string">&#x27;Fully Paid&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;Current&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;Charged Off&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;In Grace Period&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;Late (31-120 days)&#x27;</span>:<span class="number">1</span>&#125;&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">a3.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种方法</span></span><br><span class="line"><span class="comment"># df[&#x27;loan_status&#x27;].replace(to_replace=[&#x27;Fully Paid&#x27;,&#x27;Current&#x27;,&#x27;Charged Off&#x27;,&#x27;In Grace Period&#x27;,&#x27;Late (31-120 days)&#x27;],</span></span><br><span class="line"><span class="comment"># value=[0,0,1,1,1],inplace=True)</span></span><br></pre></td></tr></table></figure><p><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202304301441270.jpg" alt="009"></p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（10）将term、grade、emp_length、annual_inc、home_ownership、verification_status这些分类变量进行哑变量处理。</span></span><br><span class="line"></span><br><span class="line">ss = [<span class="string">&#x27;term&#x27;</span>, <span class="string">&#x27;grade&#x27;</span>, <span class="string">&#x27;emp_length&#x27;</span>, <span class="string">&#x27;annual_inc&#x27;</span>, <span class="string">&#x27;home_ownership&#x27;</span>, <span class="string">&#x27;verification_status&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> ss:</span><br><span class="line">    dum_list = pd.get_dummies(a3[s], prefix = s)</span><br><span class="line">    <span class="built_in">print</span>(dum_list.head())</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">   term_ 36 months  term_ 60 months</span><br><span class="line">0                0                1</span><br><span class="line">1                1                0</span><br><span class="line">2                0                1</span><br><span class="line">3                1                0</span><br><span class="line">4                1                0</span><br><span class="line">   grade_A  grade_B  grade_C  grade_D  grade_E  grade_F  grade_G</span><br><span class="line">0        0        0        1        0        0        0        0</span><br><span class="line">1        1        0        0        0        0        0        0</span><br><span class="line">2        0        0        0        1        0        0        0</span><br><span class="line">3        0        0        1        0        0        0        0</span><br><span class="line">4        0        0        1        0        0        0        0</span><br><span class="line">   emp_length_1 year  emp_length_10+ years  emp_length_2 years  \</span><br><span class="line">0                  0                     1                   0   </span><br><span class="line">1                  0                     0                   0   </span><br><span class="line">2                  0                     1                   0   </span><br><span class="line">3                  0                     1                   0   </span><br><span class="line">4                  0                     0                   0   </span><br><span class="line"></span><br><span class="line">   emp_length_3 years  emp_length_4 years  emp_length_5 years  \</span><br><span class="line">0                   0                   0                   0   </span><br><span class="line">1                   0                   0                   0   </span><br><span class="line">2                   0                   0                   0   </span><br><span class="line">3                   0                   0                   0   </span><br><span class="line">4                   0                   0                   0   </span><br><span class="line"></span><br><span class="line">   emp_length_6 years  emp_length_7 years  emp_length_8 years  \</span><br><span class="line">0                   0                   0                   0   </span><br><span class="line">1                   0                   0                   1   </span><br><span class="line">2                   0                   0                   0   </span><br><span class="line">3                   0                   0                   0   </span><br><span class="line">4                   0                   0                   0   </span><br><span class="line"></span><br><span class="line">   emp_length_9 years  emp_length_&lt; 1 year  </span><br><span class="line">0                   0                    0  </span><br><span class="line">1                   0                    0  </span><br><span class="line">2                   0                    0  </span><br><span class="line">3                   0                    0  </span><br><span class="line">4                   0                    1  </span><br><span class="line">   annual_inc_16000.0  annual_inc_18000.0  annual_inc_18500.0  \</span><br><span class="line">0                   0                   0                   0   </span><br><span class="line">1                   0                   0                   0   </span><br><span class="line">2                   0                   0                   0   </span><br><span class="line">3                   0                   0                   0   </span><br><span class="line">4                   0                   0                   0   </span><br><span class="line"></span><br><span class="line">   annual_inc_19000.0  annual_inc_19600.0  annual_inc_20000.0  \</span><br><span class="line">0                   0                   0                   0   </span><br><span class="line">1                   0                   0                   0   </span><br><span class="line">2                   0                   0                   0   </span><br><span class="line">3                   0                   0                   0   </span><br><span class="line">4                   0                   0                   0   </span><br><span class="line"></span><br><span class="line">   annual_inc_21000.0  annual_inc_21600.0  annual_inc_22000.0  \</span><br><span class="line">0                   0                   0                   0   </span><br><span class="line">1                   0                   0                   0   </span><br><span class="line">2                   0                   0                   0   </span><br><span class="line">3                   0                   0                   0   </span><br><span class="line">4                   0                   0                   0   </span><br><span class="line"></span><br><span class="line">   annual_inc_22500.0  ...  annual_inc_280000.0  annual_inc_300000.0  \</span><br><span class="line">0                   0  ...                    0                    0   </span><br><span class="line">1                   0  ...                    0                    0   </span><br><span class="line">2                   0  ...                    0                    0   </span><br><span class="line">3                   0  ...                    0                    0   </span><br><span class="line">4                   0  ...                    0                    0   </span><br><span class="line"></span><br><span class="line">   annual_inc_300300.0  annual_inc_310000.0  annual_inc_335000.0  \</span><br><span class="line">0                    0                    0                    0   </span><br><span class="line">1                    0                    0                    0   </span><br><span class="line">2                    0                    0                    0   </span><br><span class="line">3                    0                    0                    0   </span><br><span class="line">4                    0                    0                    0   </span><br><span class="line"></span><br><span class="line">   annual_inc_350000.0  annual_inc_385000.0  annual_inc_450000.0  \</span><br><span class="line">0                    0                    0                    0   </span><br><span class="line">1                    0                    0                    0   </span><br><span class="line">2                    0                    0                    0   </span><br><span class="line">3                    0                    0                    0   </span><br><span class="line">4                    0                    0                    0   </span><br><span class="line"></span><br><span class="line">   annual_inc_550000.0  annual_inc_580000.0  </span><br><span class="line">0                    0                    0  </span><br><span class="line">1                    0                    0  </span><br><span class="line">2                    0                    0  </span><br><span class="line">3                    0                    0  </span><br><span class="line">4                    0                    0  </span><br><span class="line"></span><br><span class="line">[5 rows x 320 columns]</span><br><span class="line">   home_ownership_MORTGAGE  home_ownership_OWN  home_ownership_RENT</span><br><span class="line">0                        0                   0                    1</span><br><span class="line">1                        1                   0                    0</span><br><span class="line">2                        1                   0                    0</span><br><span class="line">3                        0                   0                    1</span><br><span class="line">4                        0                   0                    1</span><br><span class="line">   verification_status_Not Verified  verification_status_Source Verified  \</span><br><span class="line">0                                 0                                    1   </span><br><span class="line">1                                 1                                    0   </span><br><span class="line">2                                 0                                    0   </span><br><span class="line">3                                 0                                    1   </span><br><span class="line">4                                 0                                    1   </span><br><span class="line"></span><br><span class="line">   verification_status_Verified  </span><br><span class="line">0                             0  </span><br><span class="line">1                             0  </span><br><span class="line">2                             1  </span><br><span class="line">3                             0  </span><br><span class="line">4                             0  </span><br></pre></td></tr></table></figure><hr><h3 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h3><p><a href="https://pan.baidu.com/s/1uu73xf2SVsJsAjBQceRfKA?pwd=2023">Lending Club2015年公开数据集下载</a></p><p><a href="https://blog.csdn.net/weixin_46945026/article/details/116856574"> Lending Club贷款数据转换与融合</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据分析与可视化-上机实践3（Pandas-数据预处理）&quot;&gt;&lt;a href=&quot;#数据分析与可视化-上机实践3（Pandas-数据预处理）&quot; class=&quot;headerlink&quot; title=&quot;数据分析与可视化 上机实践3（Pandas 数据预处理）&quot;&gt;&lt;/a&gt;数据</summary>
      
    
    
    
    <category term="数据分析与可视化" scheme="https://ariesfun.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
    <category term="学习记录" scheme="https://ariesfun.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Python" scheme="https://ariesfun.gitee.io/tags/Python/"/>
    
    <category term="Pandas" scheme="https://ariesfun.gitee.io/tags/Pandas/"/>
    
  </entry>
  
</feed>
