<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CUM15-445-P1 Buffer Pool Manager | AriesfunのBlog</title><meta name="keywords" content="学习记录,C/C++,LAB学习,数据库内核"><meta name="author" content="Ariesfun"><meta name="copyright" content="Ariesfun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[CMU15-445] P1 Buffer Pool Manager【视频 前置知识-缓冲池】 【文档 p1-lab详情地址】 Task #1 - LRU-K Replacement Policy任务要求This component is responsible for tracking page usage in the buffer pool. You will implement a new">
<meta property="og:type" content="article">
<meta property="og:title" content="CUM15-445-P1 Buffer Pool Manager">
<meta property="og:url" content="https://ariesfun.gitee.io/posts/cmu445p1.html">
<meta property="og:site_name" content="AriesfunのBlog">
<meta property="og:description" content="[CMU15-445] P1 Buffer Pool Manager【视频 前置知识-缓冲池】 【文档 p1-lab详情地址】 Task #1 - LRU-K Replacement Policy任务要求This component is responsible for tracking page usage in the buffer pool. You will implement a new">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230827120007265.png">
<meta property="article:published_time" content="2023-08-27T04:03:59.249Z">
<meta property="article:modified_time" content="2023-08-27T04:31:10.730Z">
<meta property="article:author" content="Ariesfun">
<meta property="article:tag" content="学习记录">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="LAB学习">
<meta property="article:tag" content="数据库内核">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230827120007265.png"><link rel="shortcut icon" href="/img/logo_22.png"><link rel="canonical" href="https://ariesfun.gitee.io/posts/cmu445p1"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Ariesfun","link":"链接: ","source":"来源: AriesfunのBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CUM15-445-P1 Buffer Pool Manager',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-27 12:31:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/gradient_background.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="AriesfunのBlog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-dark.css" type="text/css"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/logo_22.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230827120007265.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">AriesfunのBlog</a></span><div id="he-plugin-simple"></div><div id="none_space"></div><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CUM15-445-P1 Buffer Pool Manager</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-27T04:03:59.249Z" title="发表于 2023-08-27 12:03:59">2023-08-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-27T04:31:10.730Z" title="更新于 2023-08-27 12:31:10">2023-08-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CMU15-445/">CMU15-445</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CUM15-445-P1 Buffer Pool Manager"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="CMU15-445-P1-Buffer-Pool-Manager"><a href="#CMU15-445-P1-Buffer-Pool-Manager" class="headerlink" title="[CMU15-445] P1 Buffer Pool Manager"></a>[CMU15-445] P1 Buffer Pool Manager</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1VP4y1H7TL/?share_source=copy_web&vd_source=64863a79f6edd334371cb7b41a0df347">【视频 前置知识-缓冲池】</a></p>
<p><a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/project1/">【文档 p1-lab详情地址】</a></p>
<h2 id="Task-1-LRU-K-Replacement-Policy"><a href="#Task-1-LRU-K-Replacement-Policy" class="headerlink" title="Task #1 - LRU-K Replacement Policy"></a>Task #1 - LRU-K Replacement Policy</h2><h3 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h3><p>This component is responsible for tracking page usage in the buffer pool. You will implement a new class called <code>LRUKReplacer</code> in <code>src/include/buffer/lru_k_replacer.h</code> and its corresponding implementation file in <code>src/buffer/lru_k_replacer.cpp</code>. Note that <code>LRUKReplacer</code> is a stand-alone class and is not related to any of the other <code>Replacer</code> classes. You are expected to implement only the LRU-K replacement policy. You don’t have to implement LRU or a clock replacement policy, even if there is a corresponding file for it.</p>
<p>The LRU-K algorithm evicts a frame whose backward k-distance is maximum of all frames in the replacer. Backward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access. A frame with fewer than k historical accesses is given +inf as its backward k-distance. </p>
<p><strong>When multiple frames have +inf backward k-distance, the replacer evicts the frame with the earliest overall timestamp (i.e., the frame whose least-recent recorded access is the overall least recent access, overall, out of all frames).</strong></p>
<p>LRU-K算法会淘汰在替换器中所有帧中，后向k距离最大的帧，即<code>backward k-distance</code></p>
<p><strong>后向k距离是当前时间戳和第k次以前访问的时间戳之间的差值。</strong></p>
<p>历史访问次数少于k的帧被赋予+inf作为其后向k距离。</p>
<p>当多个帧具有+inf的后向k距离时，替换器将淘汰具有最早整体时间戳（即最近记录的访问，是所有帧中最近的访问）的帧。</p>
<p><strong>总结：</strong></p>
<ul>
<li><p><strong>优先淘汰距离最大的frame (Backward k-distance)</strong></p>
</li>
<li><p><strong>少于K次访问，距离是无穷大inf，优先被淘汰。</strong></p>
</li>
<li><p><strong>当有多个无穷大时，优先淘汰整体时间戳最早的，FIFO策略</strong></p>
</li>
</ul>
<p>The maximum size for the <code>LRUKReplacer</code> is the same as the size of the buffer pool since it contains placeholders for all of the frames in the <code>BufferPoolManager</code>. However, at any given moment, not all the frames in the replacer are considered to be evictable. The size of <code>LRUKReplacer</code> is represented by the number of <em>evictable</em> frames. The <code>LRUKReplacer</code> is initialized to have no frames in it. Then, only when a frame is marked as evictable, replacer’s size will increase.</p>
<p><strong>LRUK替换器的最大大小与缓冲池的大小相同，因为它包含缓冲池管理器中所有帧的占位符。</strong>然而，在任何时刻，替换器中的并非所有帧都被视为可驱逐的。</p>
<p>LRU-K替换器的大小由可驱逐帧的数量表示。LRUK替换器被初始化为空，只有在标记某个帧为可驱逐时，替换器的大小才会增加。</p>
<p><strong>总结：</strong></p>
<ul>
<li><strong>只有被标记为可驱逐的frame 并且传入是要驱逐时，才能被驱逐，替换器的大小才会增加</strong></li>
</ul>
<p><strong>要求实现以下5个API,</strong></p>
<p>You will need to implement the <em>LRU-K</em> policy discussed in this course. You will need to implement the following methods as defined in the header file (<code>src/include/buffer/lru_k_replacer.h</code>) and in the source file (<code>src/buffer/lru_k_replacer.cpp</code>):</p>
<ul>
<li><p><code>Evict(frame_id_t* frame_id)</code> : Evict the frame with largest backward k-distance compared to all other <strong>evictable</strong> frames being tracked by the <code>Replacer</code>. Store the frame id in the output parameter and return <code>True</code>. If there are no evictable frames return <code>False</code>.</p>
<p><strong>淘汰：淘汰具有与替换器跟踪的所有其他可淘汰帧，相比最大后向k距离的帧。</strong></p>
<p>将<code>frame id</code>存储在输出参数中并返回True。  </p>
<p>如果没有可淘汰的帧，则返回False。</p>
</li>
<li><p><code>RecordAccess(frame_id_t frame_id)</code> : Record that given frame id is accessed at current timestamp. This method should be called after a page is pinned in the <code>BufferPoolManager</code>.</p>
<p><strong>访问帧：记录给定的帧ID在当前时间戳被访问。</strong></p>
<p>此方法应在页面在BufferPoolManager中固定之后调用。</p>
</li>
<li><p><code>Remove(frame_id_t frame_id)</code> : Clear all access history associated with a frame. This method should be called only when a page is deleted in the <code>BufferPoolManager</code>.</p>
<p><strong>移除帧：清除与帧相关联的所有访问历史记录。</strong></p>
<p>此方法仅在BufferPoolManager中删除页面时调用。</p>
</li>
<li><p><code>SetEvictable(frame_id_t frame_id, bool set_evictable)</code> : This method controls whether a frame is evictable or not. It also controls <code>LRUKReplacer</code>‘s size. You’ll know when to call this function when you implement the <code>BufferPoolManager</code>. To be specific, when pin count of a page reaches 0, its corresponding frame is marked evictable and replacer’s size is incremented.</p>
<p><strong>设置为可驱逐：此方法控制帧是否可淘汰。它还控制LRUKReplacer的大小。</strong></p>
<p>当您实现BufferPoolManager时，将会知道何时调用此函数。</p>
<p>具体而言，当页面的固定计数达到0时，其对应的帧将被标记为可淘汰，并增加替换器的大小。</p>
</li>
<li><p><code>Size()</code> : <strong>This method returns the number of evictable frames that are currently in the <code>LRUKReplacer</code>.</strong></p>
<p><strong>容量大小：此方法返回当前在LRUKReplacer中可淘汰的帧数，即LRU-K替换器的大小。</strong></p>
</li>
</ul>
<p>The implementation details are up to you. You are allowed to use built-in STL containers. You may assume that you will not run out of memory, but you must make sure that your implementation is thread-safe.</p>
<hr>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><blockquote>
<p><strong>通用的lab分析流程</strong></p>
<ul>
<li><p>从测试代码入手（TDD：测试驱动开发）</p>
</li>
<li><p>分析类的成员函数（实现5个API）</p>
</li>
<li><p>根据要求或提示，实现每个函数具体的细节</p>
</li>
<li><p>调试时格式化代码</p>
</li>
</ul>
</blockquote>
<hr>
<p> 这部分需要我们完成该组件中，<strong>负责跟踪缓冲池中的页面使用情况的实现，即LRU-K替换策略的实现</strong>    </p>
<ul>
<li><p>先要理清LRU-K的原理，这里使用两个队列来实现</p>
</li>
<li><p>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。</p>
<p><strong>只有当数据的访问次数达到K次的时候，才会将数据放入缓存队列。</strong></p>
<p><strong>当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c4e4d55706ff">【参考文档 LRU-K相关原理介绍】</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/6570221/">【题解 LeetCode 146. LRU缓存机制】</a></p>
<blockquote>
<p>01.历史队列</p>
<ul>
<li>历史队列中的数据为第一次访问时的位置，只要未达到k次访问频率，位置一直保持不变。</li>
<li>实现数据结构：双向链表+哈希表</li>
<li>淘汰策略：FIFO</li>
</ul>
<p>02.缓存队列</p>
<ul>
<li>大于等于k次的访问频率，需要根据最近的访问时间切换元素在队列中的位置，类似于LRU。</li>
<li>实现数据结构：双向链表+哈希表</li>
<li>淘汰策略：LRU</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="实现5个API"><a href="#实现5个API" class="headerlink" title="实现5个API"></a>实现5个API</h3><p><strong>每个<code>frame_id</code>都唯一对应一个<code>Page_Table</code>中的一个<code>page_id</code>, 可以理解为放入队列中槽的具体位置</strong></p>
<p>每次缓冲池的新建页表或者取出一个页表，都要进行LRU-K的策略(淘汰不常用的内存页面，来保证读写的高效性)</p>
<p><strong>注意事项:</strong></p>
<p><strong>构造函数要补充完整，给自定义成员变量完成初始化操作;</strong></p>
<p><strong>同时要保证多线程情况下是线程安全的;</strong></p>
<p><strong>考虑边界情况，进行入参判断。</strong></p>
<p><strong>具体处理逻辑:</strong></p>
<ul>
<li><p><code>RecordAccess(frame_id_t frame_id)</code></p>
<p><strong>访问帧操作，(考虑把帧放入历史队列还是缓存队列)</strong></p>
<p>利用哈希表，每次访问统计<code>frame_id</code>的出现频次</p>
<p>01.到达<code>LRU-K</code>的<code>K</code>次时，放入缓存队列</p>
<p>02.超过<code>K</code>次时，表明它已经在缓存队列里了，需要更新它在缓存队列的位置（放在队头）</p>
<p>03.小于<code>K</code>次时，只对于第一次访问时，放入历史队列（放在队头）</p>
</li>
<li><p><code>SetEvictable(frame_id_t frame_id, bool set_evictable)</code> </p>
<p><strong>通过传入的参数<code>set_evictable</code>，来设置当前<code>frame_id</code>是否可以淘汰/驱逐；</strong></p>
<p>根据原先的<code>is_accessible_[frame_id]</code> 和 当前<code>set_evictable</code>的状态，更新当前替换器的大小；</p>
<p>同时更新标记当前帧是否可驱逐掉的状态。</p>
</li>
<li><p><code>Evict(frame_id_t* frame_id)</code> FIFO策略 + LRU策略</p>
<p><strong>开始进行淘汰操作，返回的是实际被淘汰掉的帧id, 并且返回给<code>frame_id</code></strong></p>
<p>从两个队列的尾部开始遍历，找到一个可驱逐的帧id；</p>
<p>需要注意以下两个操作的实现步骤区别；</p>
<p>注意，这里先要移除hash表中的值，再从队列里的链表移除对应的指针（防止访问已经被释放的内存，防止出现内存泄漏）；</p>
<p>01.驱逐前先要将已有的帧信息清空(包括从哈希表中移除，*it才可得到帧id)     </p>
<p>02.后面才从队列移除it，并更新替换器的大小，让缓存池容量减1 </p>
</li>
<li><p><code>Remove(frame_id_t frame_id)</code> </p>
<p><strong>移除/删除操作，清理两个队列中的数据，清除与帧相关联的所有访问历史记录。</strong></p>
<p>未到<code>K</code>，在历史队列中，否则在缓存队列中，都要完成哈希表和对应队列的数据移除。</p>
</li>
</ul>
<ul>
<li><p><code>Size()</code></p>
<p>返回当前替换器的容量/缓存池的容量。</p>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>balabala…</p>
<hr>
<h2 id="Task-2-Buffer-Pool-Manager"><a href="#Task-2-Buffer-Pool-Manager" class="headerlink" title="Task #2 - Buffer Pool Manager"></a>Task #2 - Buffer Pool Manager</h2><h3 id="任务要求-1"><a href="#任务要求-1" class="headerlink" title="任务要求"></a>任务要求</h3><p>Next, implement the buffer pool manager (<code>BufferPoolManager</code>). The <code>BufferPoolManager</code> is responsible for fetching database pages from the <code>DiskManager</code> and storing them in memory. The <code>BufferPoolManager</code> can also write dirty pages out to disk when it is either explicitly instructed to do so or when it needs to evict a page to make space for a new page.</p>
<p><strong>// 负责实现从<code>BufferPoolManager</code>中获取数据库页面<code>DiskManager</code>并将其存储在内存中。</strong></p>
<p><strong>// <code>BufferPoolManager</code>当明确指示这样做或需要逐出页面以为新页面腾出空间时，也可以将脏页面写入磁盘。</strong></p>
<p><strong>// 刷脏的时机是什么？从缓冲池中淘汰掉一个帧页面；刷新内存页面到磁盘时；</strong></p>
<p>To make sure that your implementation works correctly with the rest of the system, we will provide you with some functions already filled in. You will also not need to implement the code that actually reads and writes data to disk (this is called the <code>DiskManager</code> in our implementation). We will provide that functionality.</p>
<p>All in-memory pages in the system are represented by <code>Page</code> objects. The <code>BufferPoolManager</code> does not need to understand the contents of these pages. But it is important for you as the system developer to understand that <code>Page</code> objects are just containers for memory in the buffer pool and thus are not specific to a unique page. That is, each <code>Page</code> object contains a block of memory that the <code>DiskManager</code> will use as a location to copy the contents of a <strong>physical page</strong> that it reads from disk. The <code>BufferPoolManager</code> will reuse the same <code>Page</code> object to store data as it moves back and forth to disk. This means that the same <code>Page</code> object may contain a different physical page throughout the life of the system. The <code>Page</code> object’s identifer (<code>page_id</code>) keeps track of what physical page it contains; if a <code>Page</code> object does not contain a physical page, then its <code>page_id</code> must be set to <code>INVALID_PAGE_ID</code>.</p>
<p><strong>// 如果<code>Page</code>对象不包含物理页，则<code>page_id</code>必须将其设置为<code>INVALID_PAGE_ID</code>。</strong></p>
<p>Each <code>Page</code> object also maintains a counter for the number of threads that have “pinned” that page. </p>
<p><strong>// 每个<code>Page</code>对象还维护一个计数器，用于记录“固定”该页面的线程数量。</strong></p>
<p><strong>// 引用计数是用来跟踪页面当前被多少个操作或线程引用的的一个机制。</strong></p>
<p>Your <code>BufferPoolManager</code> is not allowed to free a <code>Page</code> that is pinned. Each <code>Page</code> object also keeps track of whether it is dirty or not. It is your job to record whether a page was modified before it is unpinned. Your <code>BufferPoolManager</code> must write the contents of a dirty <code>Page</code> back to disk before that object can be reused.</p>
<p>Your <code>BufferPoolManager</code> implementation will use the <code>LRUKReplacer</code> class that you created in the previous steps of this assignment. The <code>LRUKReplacer</code> will keep track of when <code>Page</code> objects are accessed so that it can decide which one to evict when it must free a frame to make room for copying a new physical page from disk. When mapping <code>page_id</code> to <code>frame_id</code> in the <code>BufferPoolManager</code>, again be warned that STL containers are not thread-safe.</p>
<p>You will need to implement the following functions defined in the header file (<code>src/include/buffer/buffer_pool_manager.h</code>) and in the source file (<code>src/buffer/buffer_pool_manager.cpp</code>):</p>
<ul>
<li><code>FetchPage(page_id_t page_id)</code></li>
<li><code>UnpinPage(page_id_t page_id, bool is_dirty)</code></li>
<li><code>FlushPage(page_id_t page_id)</code></li>
<li><code>NewPage(page_id_t* page_id)</code></li>
<li><code>DeletePage(page_id_t page_id)</code></li>
<li><code>FlushAllPages()</code></li>
</ul>
<p>For <code>FetchPage</code>, you should return nullptr if no page is available in the free list and all other pages are currently pinned. <strong><code>FlushPage</code> should flush a page regardless of its pin status.</strong></p>
<p><strong>// <code>FlushPage</code>无论其引脚状态如何，都应该刷新页面。</strong></p>
<p>For <code>UnpinPage</code>, the is_dirty parameter keeps track of whether a page was modified while it was pinned.</p>
<p><strong>// 对于<code>UnpinPage</code>，is_dirty 参数跟踪页面在固定时是否被修改。</strong></p>
<p>The <code>AllocatePage</code> private method provides the <code>BufferPoolManager</code> a unique new page id when you want to create a new page in <code>NewPage()</code>. On the other hand, the <code>DeallocatePage()</code> method is a no-op that imitates freeing a page on the disk and you should call this in your <code>DeletePage()</code> implementation.</p>
<p><strong>// <code>DeallocatePage()</code>该方法是模拟释放磁盘上页面的操作。</strong></p>
<p><strong>Disk Manager</strong></p>
<p>The Disk Manager class (<code>src/include/storage/disk/disk_manager.h</code>) reads and writes the page data from and to the disk. Your buffer pool manager will use <code>DiskManager::ReadPage()</code> and <code>DiskManager::WritePage()</code> whenever it needs to fetch a page to the buffer pool or flush a page to the disk.</p>
<hr>
<h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><p><strong>BufferPoolManager</strong>，<strong>几个重要的成员变量信息</strong></p>
<blockquote>
<p>const size_t pool_size_; // 缓冲池的容量</p>
<p>Page *pages_; // 从磁盘读取数据放入内存中，带有(<code>meta-data</code>元数据 + 磁盘读取的Data)</p>
<p>std::unique_ptr<LRUKReplacer> replacer_; // Task#1的LRU-K替换策略类</p>
<p>std::unordered_map&lt;page_id_t, frame_id_t&gt; page_table_; // 内存页表，用来绑定<code>page_id</code>和<code>frame_id</code>间的映射关系</p>
<p>std::list<frame_id_t> free_list_; // 管理空闲帧的列表，大小受<code>pool_size</code>影响</p>
<p>std::mutex latch_; // 底层的锁(用于给配置加锁)</p>
</blockquote>
<p><code>内存Page</code>: 以数组形式记录每个内存Page的信息<strong>（meta-data + 磁盘中读到的数据）</strong></p>
<img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230826170744774.png" alt="image-20230826170744774" style="zoom:33%;" />

<p>成员变量<code>pin_count</code>引用计数的含义和作用，</p>
<p><strong>“pin_count” 表示页面当前被固定（正在被使用）的次数，以确保在页面上进行操作时数据的一致性和可靠性。</strong></p>
<p>利用ChatGpt进行辅助理解，</p>
<img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230826024651175.png" alt="image-20230826024651175" style="zoom:50%;" />

<p><strong>一些问题的理解：</strong></p>
<p><strong>01.<code>内存Page</code>和<code>磁盘Page</code>有什么区别？</strong></p>
<p><strong>page_table</strong>是内存池上的索引，用于表示每个内存页面的<code>page_id</code>对应在缓冲池中的槽的位置<code>frame_id</code>，</p>
<p><strong>page_directory</strong>是磁盘上的数据文件索引，标识<code>page_id</code>对应的数据文件位置。</p>
<p><strong>区别：</strong></p>
<p><code>内存Page</code>的容量更小，可以提供快速的数据访问；</p>
<p><code>磁盘Page</code>通常是帮助<code>内存Page</code>从磁盘找到对应的页表数据的位置；</p>
<p>再从磁盘读到内存中，放入一个成员变量data中(磁盘Page中包含的实际数据)</p>
<p>【面向磁盘的关系型数据库输入读取过程】</p>
<p>据库系统倾向于将热门数据或索引保留在内存中，以提高性能。</p>
<p>下图展示了，当用户读取数据库中数据的一个流程，</p>
<p>**(SQL执行)执行器 —-&gt; 缓冲池 (找到，返回给执行器) **</p>
<p><strong>(SQL执行)执行器 —-&gt; 缓冲池（没找到）在对应磁盘Page中取 —-&gt; 载入缓冲池(free_list检测 + LRU替换策略) —-&gt; 返回给执行器</strong></p>
<img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230826172956486.png" alt="image-20230826172956486" style="zoom:50%;" />

<hr>
<p><strong>02.<code>NewPage()</code>和<code>FetchPage()</code>操作的区别是什么？</strong></p>
<p><strong>NewPage</strong>是在缓冲池中新创建一个只在内存中的页面，磁盘上没有该页面，得到一个新初始化的新页面并返回；</p>
<p><strong>FetchPage</strong>是这个页面已经在缓冲池中存在了，我只需要取出来，并返回这个页面的信息；</p>
<hr>
<p><strong>03.刷脏的时机是什么？</strong></p>
<p>从缓冲池中淘汰掉一个帧页面时；刷新内存页面到磁盘时；</p>
<hr>
<h3 id="实现6个API"><a href="#实现6个API" class="headerlink" title="实现6个API"></a>实现6个API</h3><p>实现缓冲池管理器（<code>BufferPoolManager</code>）,负责<code>BufferPoolManager</code>从 中获取数据库页面<code>DiskManager</code>并将其存储在内存中。</p>
<p>构造函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BufferPoolManager</span>(<span class="type">size_t</span> pool_size, DiskManager *disk_manager, <span class="type">size_t</span> replacer_k = LRUK_REPLACER_K,</span><br><span class="line">				  LogManager *log_manager = <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<p>初始时，利用缓冲池容量大小<code>pool_size</code>初始化了<strong>空闲链表<code>free_list</code>的大小，用来表示当前空闲着的帧列表</strong></p>
<p><strong>注意：</strong></p>
<p><code>FetchPage</code>操作没在缓存池中找到信息，需要从磁盘读取信息到内存，</p>
<p><code>Flush</code>操作不需要reset数据。</p>
<p><strong>具体处理逻辑:</strong></p>
<ul>
<li><p><code>NewPage(page_id_t* page_id)</code></p>
<p><strong>新建页面操作</strong></p>
<p>获取一个可用的<code>frame_id</code>；</p>
<ul>
<li><p>空闲链表里非空，还有帧id可用，直接从<code>free_list</code>末尾拿一个帧页面就行</p>
</li>
<li><p>空闲链表里没有空闲的帧时，需要从缓冲池中淘汰掉一个帧页面，得到可用的帧id（<code>Task#1 Evict()</code>淘汰机制）</p>
<p>注意：若当前页面是脏状态，需要先进行刷脏，将数据写入磁盘再继续操作</p>
<p>然后，删除每个页表对应的帧id的索引，解除映射关系</p>
</li>
</ul>
<p>与申请到的新的<code>new_page_id</code>和<code>frame_id</code>，建立一对新映射关系；</p>
<p>对于<code>page_table_</code>数组进行数据初始化<code>meta-data</code>，并reset清空Data信息；</p>
<p>同步也要在，在LRU-K的替换器中进行访问帧和驱逐帧的操作</p>
<p>返回这个新的<code>pages_</code></p>
</li>
</ul>
<ul>
<li><p><code>FetchPage(page_id_t page_id)</code></p>
<p><strong>从缓冲池中取出一个内存页，操作过程类似NewPage</strong></p>
<p>若page_id能在缓冲池找到，</p>
<ul>
<li><p>更新页面的引用计数</p>
</li>
<li><p>在LRU-K的替换器中进行访问帧和驱逐帧的操作</p>
</li>
</ul>
<p>缓冲池中没有找到，在磁盘中读取，</p>
<ul>
<li>先获取一个可用的<code>frame_id</code></li>
<li>初始化meta-data信息，从磁盘中<strong>读数据</strong>存入pages_的data成员变量中</li>
<li>要在LRU-K的替换器中进行访问帧和驱逐帧的操作</li>
</ul>
<p>返回当前拿到的<code>pages_</code></p>
</li>
<li><p><code>UnpinPage(page_id_t page_id, bool is_dirty)</code></p>
<p><strong>用于将目标页面从缓冲池中解除固定, 同时传入该内存页面的脏状态</strong></p>
<p>先是入参判断，传入的<code>page_id</code>要有效，并且可以在内存页表里找到</p>
<p>获取<code>page_id</code>对应的<code>frame_id</code></p>
<p>通过<strong>按位或</strong>来，更新页面的脏状态（将传入的 <code>is_dirty</code> 参数的状态合并到页面的脏状态中）</p>
<p><strong>（按位或：这样的做的目的，确保在更新页面状态时不会丢失页面的脏状态信息）</strong></p>
<p>当前页面的引用计数大于0，每次解除固定操作只会让<code>pin_count_</code>减1</p>
<ul>
<li>只有引用计数为零时，页面才可以被置换(驱逐)出缓冲池（<code>Task#1 Evict()</code>淘汰机制）</li>
</ul>
<p>返回解除操作是否成功</p>
</li>
<li><p><code>FlushPage(page_id_t page_id)</code></p>
<p><strong>刷新一个内存页面到磁盘，写入数据操作</strong></p>
<p>注意FlushPage, 只管刷新页面不管其pin的状态，内存页面也不必清空</p>
<p>该页面能够在<code>page_table_</code>中找到时，获取对应的<code>frame_id</code></p>
<p>进行刷脏，利用<code>disk_manager_</code>写入数据到磁盘中，并且更新页面的脏状态</p>
</li>
</ul>
<ul>
<li><p><code>FlushAllPages()</code></p>
<p><strong>刷新所有内存页面到磁盘</strong></p>
<p>当前页面是脏状态，并且<code>page_id</code>是有效的，就可以满足刷脏操作</p>
<p>利用<code>disk_manager_</code>写入数据到磁盘中，并且更新页面的脏状态</p>
</li>
</ul>
<ul>
<li><p><code>DeletePage(page_id_t page_id)</code></p>
<p><strong>删除缓冲池的内存页面</strong></p>
<p>边界考虑，</p>
<p>要删除的<code>page_id</code>并不存在，即不在缓冲池中，返回true，</p>
<p>该页面正在被使用时，不能删；</p>
<p>删除前，页面数据还没写入磁盘时，需要先刷脏</p>
<p>然后要清空页面中的<code>meta-data</code>信息，</p>
<p>注意<code>reset</code>清空data, 标记<code>page_id</code>为无效ID<code>INVALID_PAGE_ID</code>(Page对象不包含物理页);</p>
<p>最后在<code>page_table</code>、<code>replacer</code>、<code>free_list</code>中进行清除，</p>
<p>然后<code>DeallocatePage()</code>释放磁盘页面</p>
</li>
</ul>
<hr>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>注意：</strong></p>
<p>开始实现代码时，需要将<code>throw NotImplementedException()</code>的代码移除，以便于后续可以正常完成<code>GTest</code>.</p>
<p>balabala…</p>
<hr>
<h2 id="Task-3-Read-Write-Page-Guards"><a href="#Task-3-Read-Write-Page-Guards" class="headerlink" title="Task #3 - Read/Write Page Guards"></a>Task #3 - Read/Write Page Guards</h2><h3 id="任务要求-2"><a href="#任务要求-2" class="headerlink" title="任务要求"></a>任务要求</h3><p>In the Buffer Pool Manager, <code>FetchPage</code> and <code>NewPage</code> functions return pointers to pages that are already pinned. The pinning mechanism ensures that the pages are not evicted until there are no more reads and writes on the page. To indicate that the page is no longer needed in memory, the programmer has to manually call <code>UnpinPage</code>.</p>
<p>On the other hand, if the programmer forgets to call <code>UnpinPage</code>, the page will never be evicted out of the buffer pool. As the buffer pool operates with an effectively smaller number of frames, there will be more swapping of pages in and out of the disk. Not only the performance takes a hit, the bug is also difficult to be detected.</p>
<p>You will implement <code>BasicPageGuard</code> which store the pointers to <code>BufferPoolManager</code> and <code>Page</code> objects. </p>
<p><strong>// 你将实现<code>BasicPageGuard</code>存储指向<code>BufferPoolManager</code>和<code>Page</code>对象的指针，进行读/写页面的防护</strong></p>
<p>A page guard ensures that <code>UnpinPage</code> is called on the corresponding <code>Page</code> object as soon as it goes out of scope. Note that it should still expose a method for a programmer to manually unpin the page.</p>
<p>As <code>BasicPageGuard</code> hides the underlying <code>Page</code> pointer, it can also provide read-only/write data APIs that provide compile-time checks to ensure that the <code>is_dirty</code> flag is set correctly for each use case.</p>
<p>In the future projects, multiple threads will be reading and writing from the same pages, thus reader-writer latches are required to ensure the correctness of the data. Note that in the <code>Page</code> class, there are relevant latching methods for this purpose. Similar to unpinning of a page, a programmer can forget to unlatch a page after use. To mitigate the problem, you will implement <code>ReadPageGuard</code> and <code>WritePageGuard</code> which automatically unlatch the pages as soon as they go out of scope.</p>
<p>You will need to implement the following functions for all <code>BasicPageGuard</code>, <code>ReadPageGuard</code> and <code>WritePageGuard</code>.</p>
<ul>
<li><code>PageGuard(PageGuard &amp;&amp;that)</code> : Move constructor. <strong>// 移动构造函数</strong></li>
<li><code>operator=(PageGuard &amp;&amp;that)</code> : Move operator. <strong>// 移动操作符</strong></li>
<li><code>Drop()</code> : Unpin and/or unlatch. <strong>// 取消固定和或解锁</strong></li>
<li><code>~PageGuard()</code> : Destructor. </li>
</ul>
<p>With the new page guards, implement the following wrappers in <code>BufferPoolManager</code>.</p>
<ul>
<li><code>FetchPageBasic(page_id_t page_id)</code></li>
<li><code>FetchPageRead(page_id_t page_id)</code></li>
<li><code>FetchPageWrite(page_id_t page_id)</code></li>
<li><code>NewPageGuarded(page_id_t *page_id)</code></li>
</ul>
<p>Please refer to the header files (<code>lru_k_replacer.h</code>, <code>buffer_pool_manager.h</code>, <code>page_guard.h</code>) for more detailed specs and documentations.</p>
<hr>
<h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><p>移动构造函数和移动赋值运算符的使用</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170">【参考文档 移动构造函数和移动赋值运算符 (C++)】</a></p>
<blockquote>
<p><strong>创建移动构造函数</strong></p>
<p>01.定义一个空的构造函数方法，该方法采用一个对类类型的右值引用作为参数</p>
<p>02.在移动构造函数中，将源对象中的类数据成员添加到要构造的对象（拷贝操作）</p>
<p>03.将源对象的数据成员分配默认值。 这可以防止析构函数多次释放资源</p>
</blockquote>
<blockquote>
<p><strong>创建移动赋值运算符</strong></p>
<p>01.定义一个空的赋值运算符，该运算符采用一个对类类型的右值引用作为参数并返回一个对类类型的引用</p>
<p>02.在移动赋值运算符中，如果尝试将对象赋给自身，则添加不执行运算的条件语句</p>
<p>03.在条件语句中，从要将其赋值的对象中释放所有资源（如内存）</p>
<ul>
<li>执行移动构造函数的02,03步骤</li>
</ul>
<p>04.返回对当前对象的引用</p>
</blockquote>
<p><strong>注意事项：</strong></p>
<p>入参判断，检查操作的指针变量是否为空 </p>
<p>释放资源时，需要将Page页面从缓冲池中解除固定（<strong>UnpinPage()操作</strong>）</p>
<p>在<code>BufferPoolManager</code>中，缓冲池的读写操作都需要加锁</p>
<hr>
<h3 id="相关API的实现"><a href="#相关API的实现" class="headerlink" title="相关API的实现"></a>相关API的实现</h3><p>在<code>BasicPageGuard</code>中，需要实现<code>ReadPageGuard</code>和<code>WritePageGuard</code>。</p>
<ul>
<li><p><strong><code>PageGuard(PageGuard &amp;&amp;that)</code>：移动构造函数。</strong></p>
<p>01.不空时，先清空</p>
<p>02.拷贝另一个数据的成员变量</p>
<p>03.将源对象的数据成员变为默认值，来释放资源</p>
</li>
<li><p><strong><code>operator=(PageGuard &amp;&amp;that)</code>：移动操作符。</strong></p>
<p>边界情况：不是自己时才能进行赋值</p>
<p>01.先清空</p>
<p>02.拷贝数据成员</p>
<p>03.源对象置为默认值</p>
</li>
<li><p><strong><code>Drop()</code>：取消固定和读写的解锁。</strong></p>
<p>操作的指针非空的判断；</p>
<p>不空时，需要将Page页面从缓冲池中解除固定；</p>
<p>将该对象信息，置为默认值。</p>
<p>关于<code>ReadPageGuard</code>和<code>WritePageGuard</code>的<code>Drop</code>实现;</p>
<p>需要先释放对应页面的读锁或写锁;</p>
<p>然后释放<code>BasicPageGuard</code>对象<code>guard_</code>的资源。</p>
</li>
</ul>
<ul>
<li><p><strong><code>~PageGuard()</code>: 析构函数。</strong></p>
<p>调用上面的<code>Drop()</code></p>
<p>使用新的页面防护，在<code>BufferPoolManager</code>中.</p>
<p>利用Task#2的API操作实现，</p>
</li>
<li><p><code>FetchPageBasic(page_id_t page_id)</code></p>
<p>返回取到的内存页面</p>
</li>
<li><p><code>FetchPageRead(page_id_t page_id)</code></p>
<p>返回取到的内存页面前，需要先加读锁</p>
</li>
<li><p><code>FetchPageWrite(page_id_t page_id)</code></p>
<p>返回取到的内存页面前，需要先加写锁</p>
</li>
<li><p><code>NewPageGuarded(page_id_t *page_id)</code></p>
<p>返回新创建的页面</p>
</li>
</ul>
<hr>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>balabala…</p>
<hr>
<h2 id="代码提交评测"><a href="#代码提交评测" class="headerlink" title="代码提交评测"></a>代码提交评测</h2><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230826215737631.png" alt="image-20230826215737631" style="zoom:50%;" />

<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ariesfun.gitee.io">Ariesfun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ariesfun.gitee.io/posts/cmu445p1.html">https://ariesfun.gitee.io/posts/cmu445p1.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ariesfun.gitee.io" target="_blank">AriesfunのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">学习记录</a><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/LAB%E5%AD%A6%E4%B9%A0/">LAB学习</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E6%A0%B8/">数据库内核</a></div><div class="post_share"><div class="social-share" data-image="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230827120007265.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/cmu445p0.html"><img class="next-cover" src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230827120007265.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CUM15-445-P0 C++ Primer</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/cmu445p0.html" title="CUM15-445-P0 C++ Primer"><img class="cover" src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230827120007265.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-27</div><div class="title">CUM15-445-P0 C++ Primer</div></div></a></div><div><a href="/posts/cmu15445.html" title="CUM 15-445 2023-Spring Lab记录合集"><img class="cover" src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230827120007265.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-27</div><div class="title">CUM 15-445 2023-Spring Lab记录合集</div></div></a></div><div><a href="/posts/21e5.html" title="C++ 设计模式(单例+工厂)"><img class="cover" src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202308090027619.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-09</div><div class="title">C++ 设计模式(单例+工厂)</div></div></a></div><div><a href="/posts/6d6b.html" title="C&#x2F;C++ 内存四区总结"><img class="cover" src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202308090026441.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-09</div><div class="title">C&#x2F;C++ 内存四区总结</div></div></a></div><div><a href="/posts/b9aa.html" title="机器学习与数据挖掘 刷题练习(复习版)"><img class="cover" src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306040216162.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-04</div><div class="title">机器学习与数据挖掘 刷题练习(复习版)</div></div></a></div><div><a href="/posts/5544.html" title="23生产实习 大数据开发实训笔记合集 更新中..."><img class="cover" src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202306040105742.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-04</div><div class="title">23生产实习 大数据开发实训笔记合集 更新中...</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/logo_22.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ariesfun</div><div class="author-info__description">这里有互联网技术分享、计算机专业知识学习和生活日志...</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ariesfun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2018351840&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://space.bilibili.com/172382106" target="_blank" title="Bilibili"><i class="fab fa-bilibili"></i></a><a class="social-icon" href="mailto:ariesfun2019@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://github.com/ariesfun" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一些资源共享: (仅限校友内网访问)
http://10.200.21.35:8100/s/WJhg
</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CMU15-445-P1-Buffer-Pool-Manager"><span class="toc-text">[CMU15-445] P1 Buffer Pool Manager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task-1-LRU-K-Replacement-Policy"><span class="toc-text">Task #1 - LRU-K Replacement Policy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%A6%81%E6%B1%82"><span class="toc-text">任务要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">前置知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B05%E4%B8%AAAPI"><span class="toc-text">实现5个API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task-2-Buffer-Pool-Manager"><span class="toc-text">Task #2 - Buffer Pool Manager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%A6%81%E6%B1%82-1"><span class="toc-text">任务要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3"><span class="toc-text">概念理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B06%E4%B8%AAAPI"><span class="toc-text">实现6个API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task-3-Read-Write-Page-Guards"><span class="toc-text">Task #3 - Read&#x2F;Write Page Guards</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%A6%81%E6%B1%82-2"><span class="toc-text">任务要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">相关知识点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3API%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">相关API的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%AF%84%E6%B5%8B"><span class="toc-text">代码提交评测</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/cmu445p1.html" title="CUM15-445-P1 Buffer Pool Manager"><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230827120007265.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CUM15-445-P1 Buffer Pool Manager"/></a><div class="content"><a class="title" href="/posts/cmu445p1.html" title="CUM15-445-P1 Buffer Pool Manager">CUM15-445-P1 Buffer Pool Manager</a><time datetime="2023-08-27T04:03:59.249Z" title="发表于 2023-08-27 12:03:59">2023-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/cmu445p0.html" title="CUM15-445-P0 C++ Primer"><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230827120007265.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CUM15-445-P0 C++ Primer"/></a><div class="content"><a class="title" href="/posts/cmu445p0.html" title="CUM15-445-P0 C++ Primer">CUM15-445-P0 C++ Primer</a><time datetime="2023-08-27T04:03:40.136Z" title="发表于 2023-08-27 12:03:40">2023-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/cmu15445.html" title="CUM 15-445 2023-Spring Lab记录合集"><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230827120007265.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CUM 15-445 2023-Spring Lab记录合集"/></a><div class="content"><a class="title" href="/posts/cmu15445.html" title="CUM 15-445 2023-Spring Lab记录合集">CUM 15-445 2023-Spring Lab记录合集</a><time datetime="2023-08-27T03:47:38.888Z" title="发表于 2023-08-27 11:47:38">2023-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/21e5.html" title="C++ 设计模式(单例+工厂)"><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202308090027619.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ 设计模式(单例+工厂)"/></a><div class="content"><a class="title" href="/posts/21e5.html" title="C++ 设计模式(单例+工厂)">C++ 设计模式(单例+工厂)</a><time datetime="2023-08-08T16:29:53.011Z" title="发表于 2023-08-09 00:29:53">2023-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6d6b.html" title="C/C++ 内存四区总结"><img src="https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/202308090026441.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C/C++ 内存四区总结"/></a><div class="content"><a class="title" href="/posts/6d6b.html" title="C/C++ 内存四区总结">C/C++ 内存四区总结</a><time datetime="2023-08-08T16:29:53.008Z" title="发表于 2023-08-09 00:29:53">2023-08-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://imgbed-funblog.oss-cn-chengdu.aliyuncs.com/img/image-20230827120007265.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Ariesfun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-teal-two.vercel.app',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-teal-two.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="/js/weather.js"></script> <script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>